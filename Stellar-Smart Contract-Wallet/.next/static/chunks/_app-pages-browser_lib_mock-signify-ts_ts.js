"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_N_E"] = self["webpackChunk_N_E"] || []).push([["_app-pages-browser_lib_mock-signify-ts_ts"],{

/***/ "(app-pages-browser)/./lib/mock-signify-ts.ts":
/*!********************************!*\
  !*** ./lib/mock-signify-ts.ts ***!
  \********************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   MockSignifyClient: function() { return /* binding */ MockSignifyClient; },\n/* harmony export */   Tier: function() { return /* binding */ Tier; },\n/* harmony export */   randomPasscode: function() { return /* binding */ randomPasscode; },\n/* harmony export */   ready: function() { return /* binding */ ready; }\n/* harmony export */ });\n// Mock Signify-TS implementation for Phase 1\n// In Phase 2, this will be replaced with the real signify-ts package\nvar Tier;\n(function(Tier) {\n    Tier[\"low\"] = \"low\";\n    Tier[\"medium\"] = \"medium\";\n    Tier[\"high\"] = \"high\";\n})(Tier || (Tier = {}));\nclass MockSignifyClient {\n    async initialize() {\n        console.log(\"\\uD83D\\uDE80 Mock KERIA initialization process\");\n        await this.boot();\n        await this.connect();\n    }\n    async boot() {\n        console.log(\"\\uD83D\\uDE80 Mock KERIA boot process\");\n        await new Promise((resolve)=>setTimeout(resolve, 1000));\n    }\n    async connect() {\n        console.log(\"\\uD83D\\uDD17 Mock KERIA connection established\");\n        await new Promise((resolve)=>setTimeout(resolve, 500));\n    }\n    identifiers() {\n        return {\n            async create (name, options) {\n                console.log(\"\\uD83D\\uDCDD Creating mock identifier: \".concat(name));\n                await new Promise((resolve)=>setTimeout(resolve, 1000));\n                return {\n                    async op () {\n                        console.log(\"⏳ Mock operation for identifier: \".concat(name));\n                        await new Promise((resolve)=>setTimeout(resolve, 500));\n                        return {\n                            name,\n                            status: \"success\"\n                        };\n                    }\n                };\n            },\n            async get (name) {\n                console.log(\"\\uD83D\\uDD0D Retrieving mock identifier: \".concat(name));\n                await new Promise((resolve)=>setTimeout(resolve, 300));\n                return {\n                    prefix: \"E\".concat(Math.random().toString(36).substring(2, 15).toUpperCase())\n                };\n            }\n        };\n    }\n    credentials() {\n        return {\n            async issue (issuer, issuee, schema, data, edges) {\n                console.log(\"\\uD83D\\uDCDC Issuing mock credential: \".concat(schema));\n                await new Promise((resolve)=>setTimeout(resolve, 1000));\n                return {\n                    sad: {\n                        d: \"SAID_\".concat(Math.random().toString(36).substring(2, 15)),\n                        i: issuer,\n                        a: {\n                            i: issuee,\n                            ...data\n                        },\n                        e: edges\n                    }\n                };\n            },\n            async verify (credential) {\n                console.log(\"✅ Mock credential verification\");\n                await new Promise((resolve)=>setTimeout(resolve, 500));\n                return true // Mock always returns valid\n                ;\n            },\n            async list (aid) {\n                console.log(\"\\uD83D\\uDCCB Listing mock credentials for: \".concat(aid));\n                await new Promise((resolve)=>setTimeout(resolve, 300));\n                return [] // Mock returns empty list\n                ;\n            }\n        };\n    }\n    operations() {\n        return {\n            async wait (op) {\n                console.log(\"⏳ Waiting for mock operation to complete\");\n                await new Promise((resolve)=>setTimeout(resolve, 1000));\n            }\n        };\n    }\n    // Additional methods for VLEI service compatibility\n    async createOrganizationAID(orgInfo) {\n        console.log(\"\\uD83C\\uDFE2 Creating mock organizational AID for \".concat(orgInfo.name, \"...\"));\n        await new Promise((resolve)=>setTimeout(resolve, 1000));\n        const aid = \"E\".concat(Math.random().toString(36).substring(2, 15).toUpperCase());\n        console.log(\"✅ Mock organizational AID created: \".concat(aid));\n        return aid;\n    }\n    async createPersonAID(personInfo) {\n        console.log(\"\\uD83D\\uDC64 Creating mock personal AID for \".concat(personInfo.name, \"...\"));\n        await new Promise((resolve)=>setTimeout(resolve, 1000));\n        const aid = \"E\".concat(Math.random().toString(36).substring(2, 15).toUpperCase());\n        console.log(\"✅ Mock personal AID created: \".concat(aid));\n        return aid;\n    }\n    async issueOORCredential(orgAid, personAid, personInfo) {\n        console.log(\"\\uD83D\\uDCDC Issuing mock OOR credential for \".concat(personInfo.name, \"...\"));\n        await new Promise((resolve)=>setTimeout(resolve, 1000));\n        return {\n            sad: {\n                d: \"OOR_\".concat(Date.now()),\n                i: orgAid,\n                a: {\n                    i: personAid,\n                    ...personInfo\n                }\n            }\n        };\n    }\n    async issueECRCredential(orgAid, personAid, personInfo, oorCredentialSAID, spendingLimit, maxContractValue) {\n        console.log(\"\\uD83D\\uDCDC Issuing mock ECR credential for \".concat(personInfo.name, \"...\"));\n        await new Promise((resolve)=>setTimeout(resolve, 1000));\n        return {\n            sad: {\n                d: \"ECR_\".concat(Date.now()),\n                i: orgAid,\n                a: {\n                    i: personAid,\n                    ...personInfo,\n                    spendingLimit,\n                    maxContractValue\n                },\n                e: {\n                    auth: oorCredentialSAID\n                }\n            }\n        };\n    }\n    async verifyCredentialChain(ecrCredential, oorCredential, qviCredential) {\n        console.log(\"\\uD83D\\uDD0D Mock credential chain verification\");\n        await new Promise((resolve)=>setTimeout(resolve, 500));\n        return {\n            valid: true,\n            orgLEI: qviCredential.sad.a.LEI || \"506700GE1G29325QX363\",\n            personName: ecrCredential.sad.a.personLegalName || \"John Doe\",\n            role: ecrCredential.sad.a.engagementContextRole || \"Procurement Manager\",\n            spendingLimit: ecrCredential.sad.a.spendingLimit || 100000,\n            maxContractValue: ecrCredential.sad.a.maxContractValue || 500000,\n            details: {\n                orgName: qviCredential.sad.a.legalName || \"TechCorp Inc.\",\n                lei: qviCredential.sad.a.LEI || \"506700GE1G29325QX363\",\n                personName: ecrCredential.sad.a.personLegalName || \"John Doe\",\n                role: ecrCredential.sad.a.engagementContextRole || \"Procurement Manager\",\n                spendingLimit: ecrCredential.sad.a.spendingLimit || 100000,\n                maxContractValue: ecrCredential.sad.a.maxContractValue || 500000\n            }\n        };\n    }\n    constructor(url, bran, tier, bootUrl){\n        this.url = url;\n        this.bran = bran;\n        this.tier = tier;\n    }\n}\nfunction randomPasscode() {\n    return Math.random().toString(36).substring(2, 15);\n}\nasync function ready() {\n    console.log(\"\\uD83C\\uDFAF Mock Signify-TS ready\");\n    await new Promise((resolve)=>setTimeout(resolve, 100));\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2xpYi9tb2NrLXNpZ25pZnktdHMudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUFBLDZDQUE2QztBQUM3QyxxRUFBcUU7O1VBRXpEQTs7OztHQUFBQSxTQUFBQTtBQXdCTCxNQUFNQztJQVdYLE1BQU1DLGFBQTRCO1FBQ2hDQyxRQUFRQyxHQUFHLENBQUM7UUFDWixNQUFNLElBQUksQ0FBQ0MsSUFBSTtRQUNmLE1BQU0sSUFBSSxDQUFDQyxPQUFPO0lBQ3BCO0lBRUEsTUFBTUQsT0FBc0I7UUFDMUJGLFFBQVFDLEdBQUcsQ0FBQztRQUNaLE1BQU0sSUFBSUcsUUFBUUMsQ0FBQUEsVUFBV0MsV0FBV0QsU0FBUztJQUNuRDtJQUVBLE1BQU1GLFVBQXlCO1FBQzdCSCxRQUFRQyxHQUFHLENBQUM7UUFDWixNQUFNLElBQUlHLFFBQVFDLENBQUFBLFVBQVdDLFdBQVdELFNBQVM7SUFDbkQ7SUFFQUUsY0FBYztRQUNaLE9BQU87WUFDTCxNQUFNQyxRQUFPQyxJQUFZLEVBQUVDLE9BQVk7Z0JBQ3JDVixRQUFRQyxHQUFHLENBQUMsMENBQXFDLE9BQUxRO2dCQUM1QyxNQUFNLElBQUlMLFFBQVFDLENBQUFBLFVBQVdDLFdBQVdELFNBQVM7Z0JBRWpELE9BQU87b0JBQ0wsTUFBTU07d0JBQ0pYLFFBQVFDLEdBQUcsQ0FBQyxvQ0FBeUMsT0FBTFE7d0JBQ2hELE1BQU0sSUFBSUwsUUFBUUMsQ0FBQUEsVUFBV0MsV0FBV0QsU0FBUzt3QkFDakQsT0FBTzs0QkFBRUk7NEJBQU1HLFFBQVE7d0JBQVU7b0JBQ25DO2dCQUNGO1lBQ0Y7WUFFQSxNQUFNQyxLQUFJSixJQUFZO2dCQUNwQlQsUUFBUUMsR0FBRyxDQUFDLDRDQUF1QyxPQUFMUTtnQkFDOUMsTUFBTSxJQUFJTCxRQUFRQyxDQUFBQSxVQUFXQyxXQUFXRCxTQUFTO2dCQUVqRCxPQUFPO29CQUNMUyxRQUFRLElBQThELE9BQTFEQyxLQUFLQyxNQUFNLEdBQUdDLFFBQVEsQ0FBQyxJQUFJ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Z0MscUJBQXFCLElBQUk7Z0JBQ25EYixlQUFlSSxjQUFjMUIsR0FBRyxDQUFDRyxDQUFDLENBQUNtQixhQUFhLElBQUk7Z0JBQ3BEQyxrQkFBa0JHLGNBQWMxQixHQUFHLENBQUNHLENBQUMsQ0FBQ29CLGdCQUFnQixJQUFJO1lBQzVEO1FBQ0Y7SUFDRjtJQXpKQWlCLFlBQVlDLEdBQVcsRUFBRUMsSUFBWSxFQUFFQyxJQUFVLEVBQUVDLE9BQWdCLENBQUU7UUFDbkUsSUFBSSxDQUFDSCxHQUFHLEdBQUdBO1FBQ1gsSUFBSSxDQUFDQyxJQUFJLEdBQUdBO1FBQ1osSUFBSSxDQUFDQyxJQUFJLEdBQUdBO0lBQ2Q7QUFzSkY7QUFFTyxTQUFTRTtJQUNkLE9BQU96RCxLQUFLQyxNQUFNLEdBQUdDLFFBQVEsQ0FBQyxJQUFJQyxTQUFTLENBQUMsR0FBRztBQUNqRDtBQUVPLGVBQWV1RDtJQUNwQnpFLFFBQVFDLEdBQUcsQ0FBQztJQUNaLE1BQU0sSUFBSUcsUUFBUUMsQ0FBQUEsVUFBV0MsV0FBV0QsU0FBUztBQUNuRCIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9saWIvbW9jay1zaWduaWZ5LXRzLnRzP2VhOTIiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gTW9jayBTaWduaWZ5LVRTIGltcGxlbWVudGF0aW9uIGZvciBQaGFzZSAxXG4vLyBJbiBQaGFzZSAyLCB0aGlzIHdpbGwgYmUgcmVwbGFjZWQgd2l0aCB0aGUgcmVhbCBzaWduaWZ5LXRzIHBhY2thZ2VcblxuZXhwb3J0IGVudW0gVGllciB7XG4gIGxvdyA9ICdsb3cnLFxuICBtZWRpdW0gPSAnbWVkaXVtJyxcbiAgaGlnaCA9ICdoaWdoJ1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFNpZ25pZnlDbGllbnQge1xuICBpZGVudGlmaWVycygpOiB7XG4gICAgY3JlYXRlKG5hbWU6IHN0cmluZywgb3B0aW9uczogYW55KTogUHJvbWlzZTx7IG9wKCk6IFByb21pc2U8YW55PiB9PlxuICAgIGdldChuYW1lOiBzdHJpbmcpOiBQcm9taXNlPHsgcHJlZml4OiBzdHJpbmcgfT5cbiAgfVxuICBjcmVkZW50aWFscygpOiB7XG4gICAgaXNzdWUoaXNzdWVyOiBzdHJpbmcsIGlzc3VlZTogc3RyaW5nLCBzY2hlbWE6IHN0cmluZywgZGF0YTogYW55LCBlZGdlcz86IGFueSk6IFByb21pc2U8YW55PlxuICAgIHZlcmlmeShjcmVkZW50aWFsOiBhbnkpOiBQcm9taXNlPGJvb2xlYW4+XG4gICAgbGlzdChhaWQ6IHN0cmluZyk6IFByb21pc2U8YW55W10+XG4gIH1cbiAgb3BlcmF0aW9ucygpOiB7XG4gICAgd2FpdChvcDogYW55KTogUHJvbWlzZTx2b2lkPlxuICB9XG4gIGluaXRpYWxpemUoKTogUHJvbWlzZTx2b2lkPlxuICBib290KCk6IFByb21pc2U8dm9pZD5cbiAgY29ubmVjdCgpOiBQcm9taXNlPHZvaWQ+XG59XG5cbmV4cG9ydCBjbGFzcyBNb2NrU2lnbmlmeUNsaWVudCBpbXBsZW1lbnRzIFNpZ25pZnlDbGllbnQge1xuICBwcml2YXRlIGJyYW46IHN0cmluZ1xuICBwcml2YXRlIHVybDogc3RyaW5nXG4gIHByaXZhdGUgdGllcjogVGllclxuXG4gIGNvbnN0cnVjdG9yKHVybDogc3RyaW5nLCBicmFuOiBzdHJpbmcsIHRpZXI6IFRpZXIsIGJvb3RVcmw/OiBzdHJpbmcpIHtcbiAgICB0aGlzLnVybCA9IHVybFxuICAgIHRoaXMuYnJhbiA9IGJyYW5cbiAgICB0aGlzLnRpZXIgPSB0aWVyXG4gIH1cblxuICBhc3luYyBpbml0aWFsaXplKCk6IFByb21pc2U8dm9pZD4ge1xuICAgIGNvbnNvbGUubG9nKCfwn5qAIE1vY2sgS0VSSUEgaW5pdGlhbGl6YXRpb24gcHJvY2VzcycpXG4gICAgYXdhaXQgdGhpcy5ib290KClcbiAgICBhd2FpdCB0aGlzLmNvbm5lY3QoKVxuICB9XG5cbiAgYXN5bmMgYm9vdCgpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICBjb25zb2xlLmxvZygn8J+agCBNb2NrIEtFUklBIGJvb3QgcHJvY2VzcycpXG4gICAgYXdhaXQgbmV3IFByb21pc2UocmVzb2x2ZSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIDEwMDApKVxuICB9XG5cbiAgYXN5bmMgY29ubmVjdCgpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICBjb25zb2xlLmxvZygn8J+UlyBNb2NrIEtFUklBIGNvbm5lY3Rpb24gZXN0YWJsaXNoZWQnKVxuICAgIGF3YWl0IG5ldyBQcm9taXNlKHJlc29sdmUgPT4gc2V0VGltZW91dChyZXNvbHZlLCA1MDApKVxuICB9XG5cbiAgaWRlbnRpZmllcnMoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGFzeW5jIGNyZWF0ZShuYW1lOiBzdHJpbmcsIG9wdGlvbnM6IGFueSk6IFByb21pc2U8eyBvcCgpOiBQcm9taXNlPGFueT4gfT4ge1xuICAgICAgICBjb25zb2xlLmxvZyhg8J+TnSBDcmVhdGluZyBtb2NrIGlkZW50aWZpZXI6ICR7bmFtZX1gKVxuICAgICAgICBhd2FpdCBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgMTAwMCkpXG4gICAgICAgIFxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGFzeW5jIG9wKCk6IFByb21pc2U8YW55PiB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhg4o+zIE1vY2sgb3BlcmF0aW9uIGZvciBpZGVudGlmaWVyOiAke25hbWV9YClcbiAgICAgICAgICAgIGF3YWl0IG5ldyBQcm9taXNlKHJlc29sdmUgPT4gc2V0VGltZW91dChyZXNvbHZlLCA1MDApKVxuICAgICAgICAgICAgcmV0dXJuIHsgbmFtZSwgc3RhdHVzOiAnc3VjY2VzcycgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIFxuICAgICAgYXN5bmMgZ2V0KG5hbWU6IHN0cmluZyk6IFByb21pc2U8eyBwcmVmaXg6IHN0cmluZyB9PiB7XG4gICAgICAgIGNvbnNvbGUubG9nKGDwn5SNIFJldHJpZXZpbmcgbW9jayBpZGVudGlmaWVyOiAke25hbWV9YClcbiAgICAgICAgYXdhaXQgbmV3IFByb21pc2UocmVzb2x2ZSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIDMwMCkpXG4gICAgICAgIFxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHByZWZpeDogYEUke01hdGgucmFuZG9tKCkudG9TdHJpbmcoMzYpLnN1YnN0cmluZygyLCAxNSkudG9VcHBlckNhc2UoKX1gXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBjcmVkZW50aWFscygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgYXN5bmMgaXNzdWUoaXNzdWVyOiBzdHJpbmcsIGlzc3VlZTogc3RyaW5nLCBzY2hlbWE6IHN0cmluZywgZGF0YTogYW55LCBlZGdlcz86IGFueSk6IFByb21pc2U8YW55PiB7XG4gICAgICAgIGNvbnNvbGUubG9nKGDwn5OcIElzc3VpbmcgbW9jayBjcmVkZW50aWFsOiAke3NjaGVtYX1gKVxuICAgICAgICBhd2FpdCBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgMTAwMCkpXG4gICAgICAgIFxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHNhZDoge1xuICAgICAgICAgICAgZDogYFNBSURfJHtNYXRoLnJhbmRvbSgpLnRvU3RyaW5nKDM2KS5zdWJzdHJpbmcoMiwgMTUpfWAsXG4gICAgICAgICAgICBpOiBpc3N1ZXIsXG4gICAgICAgICAgICBhOiB7IGk6IGlzc3VlZSwgLi4uZGF0YSB9LFxuICAgICAgICAgICAgZTogZWRnZXNcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBcbiAgICAgIGFzeW5jIHZlcmlmeShjcmVkZW50aWFsOiBhbnkpOiBQcm9taXNlPGJvb2xlYW4+IHtcbiAgICAgICAgY29uc29sZS5sb2coJ+KchSBNb2NrIGNyZWRlbnRpYWwgdmVyaWZpY2F0aW9uJylcbiAgICAgICAgYXdhaXQgbmV3IFByb21pc2UocmVzb2x2ZSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIDUwMCkpXG4gICAgICAgIHJldHVybiB0cnVlIC8vIE1vY2sgYWx3YXlzIHJldHVybnMgdmFsaWRcbiAgICAgIH0sXG4gICAgICBcbiAgICAgIGFzeW5jIGxpc3QoYWlkOiBzdHJpbmcpOiBQcm9taXNlPGFueVtdPiB7XG4gICAgICAgIGNvbnNvbGUubG9nKGDwn5OLIExpc3RpbmcgbW9jayBjcmVkZW50aWFscyBmb3I6ICR7YWlkfWApXG4gICAgICAgIGF3YWl0IG5ldyBQcm9taXNlKHJlc29sdmUgPT4gc2V0VGltZW91dChyZXNvbHZlLCAzMDApKVxuICAgICAgICByZXR1cm4gW10gLy8gTW9jayByZXR1cm5zIGVtcHR5IGxpc3RcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBvcGVyYXRpb25zKCkge1xuICAgIHJldHVybiB7XG4gICAgICBhc3luYyB3YWl0KG9wOiBhbnkpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICAgICAgY29uc29sZS5sb2coJ+KPsyBXYWl0aW5nIGZvciBtb2NrIG9wZXJhdGlvbiB0byBjb21wbGV0ZScpXG4gICAgICAgIGF3YWl0IG5ldyBQcm9taXNlKHJlc29sdmUgPT4gc2V0VGltZW91dChyZXNvbHZlLCAxMDAwKSlcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyBBZGRpdGlvbmFsIG1ldGhvZHMgZm9yIFZMRUkgc2VydmljZSBjb21wYXRpYmlsaXR5XG4gIGFzeW5jIGNyZWF0ZU9yZ2FuaXphdGlvbkFJRChvcmdJbmZvOiBhbnkpOiBQcm9taXNlPHN0cmluZz4ge1xuICAgIGNvbnNvbGUubG9nKGDwn4+iIENyZWF0aW5nIG1vY2sgb3JnYW5pemF0aW9uYWwgQUlEIGZvciAke29yZ0luZm8ubmFtZX0uLi5gKVxuICAgIGF3YWl0IG5ldyBQcm9taXNlKHJlc29sdmUgPT4gc2V0VGltZW91dChyZXNvbHZlLCAxMDAwKSlcbiAgICBcbiAgICBjb25zdCBhaWQgPSBgRSR7TWF0aC5yYW5kb20oKS50b1N0cmluZygzNikuc3Vic3RyaW5nKDIsIDE1KS50b1VwcGVyQ2FzZSgpfWBcbiAgICBjb25zb2xlLmxvZyhg4pyFIE1vY2sgb3JnYW5pemF0aW9uYWwgQUlEIGNyZWF0ZWQ6ICR7YWlkfWApXG4gICAgcmV0dXJuIGFpZFxuICB9XG5cbiAgYXN5bmMgY3JlYXRlUGVyc29uQUlEKHBlcnNvbkluZm86IGFueSk6IFByb21pc2U8c3RyaW5nPiB7XG4gICAgY29uc29sZS5sb2coYPCfkaQgQ3JlYXRpbmcgbW9jayBwZXJzb25hbCBBSUQgZm9yICR7cGVyc29uSW5mby5uYW1lfS4uLmApXG4gICAgYXdhaXQgbmV3IFByb21pc2UocmVzb2x2ZSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIDEwMDApKVxuICAgIFxuICAgIGNvbnN0IGFpZCA9IGBFJHtNYXRoLnJhbmRvbSgpLnRvU3RyaW5nKDM2KS5zdWJzdHJpbmcoMiwgMTUpLnRvVXBwZXJDYXNlKCl9YFxuICAgIGNvbnNvbGUubG9nKGDinIUgTW9jayBwZXJzb25hbCBBSUQgY3JlYXRlZDogJHthaWR9YClcbiAgICByZXR1cm4gYWlkXG4gIH1cblxuICBhc3luYyBpc3N1ZU9PUkNyZWRlbnRpYWwob3JnQWlkOiBzdHJpbmcsIHBlcnNvbkFpZDogc3RyaW5nLCBwZXJzb25JbmZvOiBhbnkpOiBQcm9taXNlPGFueT4ge1xuICAgIGNvbnNvbGUubG9nKGDwn5OcIElzc3VpbmcgbW9jayBPT1IgY3JlZGVudGlhbCBmb3IgJHtwZXJzb25JbmZvLm5hbWV9Li4uYClcbiAgICBhd2FpdCBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgMTAwMCkpXG4gICAgXG4gICAgcmV0dXJuIHtcbiAgICAgIHNhZDoge1xuICAgICAgICBkOiBgT09SXyR7RGF0ZS5ub3coKX1gLFxuICAgICAgICBpOiBvcmdBaWQsXG4gICAgICAgIGE6IHsgaTogcGVyc29uQWlkLCAuLi5wZXJzb25JbmZvIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBhc3luYyBpc3N1ZUVDUkNyZWRlbnRpYWwob3JnQWlkOiBzdHJpbmcsIHBlcnNvbkFpZDogc3RyaW5nLCBwZXJzb25JbmZvOiBhbnksIG9vckNyZWRlbnRpYWxTQUlEOiBzdHJpbmcsIHNwZW5kaW5nTGltaXQ/OiBudW1iZXIsIG1heENvbnRyYWN0VmFsdWU/OiBudW1iZXIpOiBQcm9taXNlPGFueT4ge1xuICAgIGNvbnNvbGUubG9nKGDwn5OcIElzc3VpbmcgbW9jayBFQ1IgY3JlZGVudGlhbCBmb3IgJHtwZXJzb25JbmZvLm5hbWV9Li4uYClcbiAgICBhd2FpdCBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgMTAwMCkpXG4gICAgXG4gICAgcmV0dXJuIHtcbiAgICAgIHNhZDoge1xuICAgICAgICBkOiBgRUNSXyR7RGF0ZS5ub3coKX1gLFxuICAgICAgICBpOiBvcmdBaWQsXG4gICAgICAgIGE6IHsgaTogcGVyc29uQWlkLCAuLi5wZXJzb25JbmZvLCBzcGVuZGluZ0xpbWl0LCBtYXhDb250cmFjdFZhbHVlIH0sXG4gICAgICAgIGU6IHsgYXV0aDogb29yQ3JlZGVudGlhbFNBSUQgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGFzeW5jIHZlcmlmeUNyZWRlbnRpYWxDaGFpbihlY3JDcmVkZW50aWFsOiBhbnksIG9vckNyZWRlbnRpYWw6IGFueSwgcXZpQ3JlZGVudGlhbDogYW55KTogUHJvbWlzZTxhbnk+IHtcbiAgICBjb25zb2xlLmxvZygn8J+UjSBNb2NrIGNyZWRlbnRpYWwgY2hhaW4gdmVyaWZpY2F0aW9uJylcbiAgICBhd2FpdCBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgNTAwKSlcbiAgICBcbiAgICByZXR1cm4ge1xuICAgICAgdmFsaWQ6IHRydWUsXG4gICAgICBvcmdMRUk6IHF2aUNyZWRlbnRpYWwuc2FkLmEuTEVJIHx8ICc1MDY3MDBHRTFHMjkzMjVRWDM2MycsXG4gICAgICBwZXJzb25OYW1lOiBlY3JDcmVkZW50aWFsLnNhZC5hLnBlcnNvbkxlZ2FsTmFtZSB8fCAnSm9obiBEb2UnLFxuICAgICAgcm9sZTogZWNyQ3JlZGVudGlhbC5zYWQuYS5lbmdhZ2VtZW50Q29udGV4dFJvbGUgfHwgJ1Byb2N1cmVtZW50IE1hbmFnZXInLFxuICAgICAgc3BlbmRpbmdMaW1pdDogZWNyQ3JlZGVudGlhbC5zYWQuYS5zcGVuZGluZ0xpbWl0IHx8IDEwMDAwMCxcbiAgICAgIG1heENvbnRyYWN0VmFsdWU6IGVjckNyZWRlbnRpYWwuc2FkLmEubWF4Q29udHJhY3RWYWx1ZSB8fCA1MDAwMDAsXG4gICAgICBkZXRhaWxzOiB7XG4gICAgICAgIG9yZ05hbWU6IHF2aUNyZWRlbnRpYWwuc2FkLmEubGVnYWxOYW1lIHx8ICdUZWNoQ29ycCBJbmMuJyxcbiAgICAgICAgbGVpOiBxdmlDcmVkZW50aWFsLnNhZC5hLkxFSSB8fCAnNTA2NzAwR0UxRzI5MzI1UVgzNjMnLFxuICAgICAgICBwZXJzb25OYW1lOiBlY3JDcmVkZW50aWFsLnNhZC5hLnBlcnNvbkxlZ2FsTmFtZSB8fCAnSm9obiBEb2UnLFxuICAgICAgICByb2xlOiBlY3JDcmVkZW50aWFsLnNhZC5hLmVuZ2FnZW1lbnRDb250ZXh0Um9sZSB8fCAnUHJvY3VyZW1lbnQgTWFuYWdlcicsXG4gICAgICAgIHNwZW5kaW5nTGltaXQ6IGVjckNyZWRlbnRpYWwuc2FkLmEuc3BlbmRpbmdMaW1pdCB8fCAxMDAwMDAsXG4gICAgICAgIG1heENvbnRyYWN0VmFsdWU6IGVjckNyZWRlbnRpYWwuc2FkLmEubWF4Q29udHJhY3RWYWx1ZSB8fCA1MDAwMDAsXG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiByYW5kb21QYXNzY29kZSgpOiBzdHJpbmcge1xuICByZXR1cm4gTWF0aC5yYW5kb20oKS50b1N0cmluZygzNikuc3Vic3RyaW5nKDIsIDE1KVxufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gcmVhZHkoKTogUHJvbWlzZTx2b2lkPiB7XG4gIGNvbnNvbGUubG9nKCfwn46vIE1vY2sgU2lnbmlmeS1UUyByZWFkeScpXG4gIGF3YWl0IG5ldyBQcm9taXNlKHJlc29sdmUgPT4gc2V0VGltZW91dChyZXNvbHZlLCAxMDApKVxufVxuIl0sIm5hbWVzIjpbIlRpZXIiLCJNb2NrU2lnbmlmeUNsaWVudCIsImluaXRpYWxpemUiLCJjb25zb2xlIiwibG9nIiwiYm9vdCIsImNvbm5lY3QiLCJQcm9taXNlIiwicmVzb2x2ZSIsInNldFRpbWVvdXQiLCJpZGVudGlmaWVycyIsImNyZWF0ZSIsIm5hbWUiLCJvcHRpb25zIiwib3AiLCJzdGF0dXMiLCJnZXQiLCJwcmVmaXgiLCJNYXRoIiwicmFuZG9tIiwidG9TdHJpbmciLCJzdWJzdHJpbmciLCJ0b1VwcGVyQ2FzZSIsImNyZWRlbnRpYWxzIiwiaXNzdWUiLCJpc3N1ZXIiLCJpc3N1ZWUiLCJzY2hlbWEiLCJkYXRhIiwiZWRnZXMiLCJzYWQiLCJkIiwiaSIsImEiLCJlIiwidmVyaWZ5IiwiY3JlZGVudGlhbCIsImxpc3QiLCJhaWQiLCJvcGVyYXRpb25zIiwid2FpdCIsImNyZWF0ZU9yZ2FuaXphdGlvbkFJRCIsIm9yZ0luZm8iLCJjcmVhdGVQZXJzb25BSUQiLCJwZXJzb25JbmZvIiwiaXNzdWVPT1JDcmVkZW50aWFsIiwib3JnQWlkIiwicGVyc29uQWlkIiwiRGF0ZSIsIm5vdyIsImlzc3VlRUNSQ3JlZGVudGlhbCIsIm9vckNyZWRlbnRpYWxTQUlEIiwic3BlbmRpbmdMaW1pdCIsIm1heENvbnRyYWN0VmFsdWUiLCJhdXRoIiwidmVyaWZ5Q3JlZGVudGlhbENoYWluIiwiZWNyQ3JlZGVudGlhbCIsIm9vckNyZWRlbnRpYWwiLCJxdmlDcmVkZW50aWFsIiwidmFsaWQiLCJvcmdMRUkiLCJMRUkiLCJwZXJzb25OYW1lIiwicGVyc29uTGVnYWxOYW1lIiwicm9sZSIsImVuZ2FnZW1lbnRDb250ZXh0Um9sZSIsImRldGFpbHMiLCJvcmdOYW1lIiwibGVnYWxOYW1lIiwibGVpIiwiY29uc3RydWN0b3IiLCJ1cmwiLCJicmFuIiwidGllciIsImJvb3RVcmwiLCJyYW5kb21QYXNzY29kZSIsInJlYWR5Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./lib/mock-signify-ts.ts\n"));

/***/ })

}]);