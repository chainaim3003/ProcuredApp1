"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./lib/passkey-auth.ts":
/*!*****************************!*\
  !*** ./lib/passkey-auth.ts ***!
  \*****************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   PasskeyAuthenticator: function() { return /* binding */ PasskeyAuthenticator; },\n/* harmony export */   createPasskeyAuthenticator: function() { return /* binding */ createPasskeyAuthenticator; },\n/* harmony export */   getDefaultPasskeyConfig: function() { return /* binding */ getDefaultPasskeyConfig; }\n/* harmony export */ });\n/* provided dependency */ var process = __webpack_require__(/*! process */ \"(app-pages-browser)/./node_modules/next/dist/build/polyfills/process.js\");\n// Real Passkey Authentication Implementation\n// Following the complete flow diagram from the documentation\nclass PasskeyAuthenticator {\n    /**\n   * Step 1: Authenticate with Passkey (biometric)\n   * This is the core biometric authentication step from the flow diagram\n   */ async authenticateWithPasskey(userName) {\n        try {\n            console.log(\"\\uD83D\\uDD10 Starting biometric authentication for: \".concat(userName));\n            // Check if WebAuthn is supported\n            if ( false || !window.PublicKeyCredential) {\n                throw new Error(\"WebAuthn/Passkeys not supported in this browser\");\n            }\n            // Check if user has existing credentials\n            const existingCredentials = this.getExistingCredentials(userName);\n            if (existingCredentials.length > 0) {\n                // Use existing credential for authentication\n                return await this.authenticateWithExistingCredential(existingCredentials[0]);\n            } else {\n                // Create new credential\n                return await this.createNewCredential(userName);\n            }\n        } catch (error) {\n            console.error(\"❌ Biometric authentication failed:\", error);\n            return {\n                success: false,\n                error: error instanceof Error ? error.message : \"Authentication failed\"\n            };\n        }\n    }\n    /**\n   * Create new passkey credential\n   */ async createNewCredential(userName) {\n        try {\n            console.log(\"\\uD83C\\uDD95 Creating new passkey credential for: \".concat(userName));\n            const challenge = new Uint8Array(32);\n            crypto.getRandomValues(challenge);\n            const credential = await navigator.credentials.create({\n                publicKey: {\n                    challenge,\n                    rp: {\n                        name: \"Stellar Procurement dApp\",\n                        id: window.location.hostname\n                    },\n                    user: {\n                        id: new TextEncoder().encode(userName),\n                        name: userName,\n                        displayName: userName\n                    },\n                    pubKeyCredParams: [\n                        {\n                            type: \"public-key\",\n                            alg: -7\n                        },\n                        {\n                            type: \"public-key\",\n                            alg: -257\n                        }\n                    ],\n                    authenticatorSelection: {\n                        authenticatorAttachment: \"platform\",\n                        userVerification: \"required\",\n                        residentKey: \"required\"\n                    },\n                    timeout: 60000,\n                    attestation: \"direct\"\n                }\n            });\n            if (!credential) {\n                throw new Error(\"Failed to create passkey credential\");\n            }\n            console.log(\"✅ New passkey credential created successfully\");\n            return {\n                success: true,\n                credentialId: credential.id,\n                publicKey: this.arrayBufferToBase64(credential.response.publicKey || new ArrayBuffer(0))\n            };\n        } catch (error) {\n            console.error(\"❌ Failed to create passkey credential:\", error);\n            return {\n                success: false,\n                error: error instanceof Error ? error.message : \"Credential creation failed\"\n            };\n        }\n    }\n    /**\n   * Authenticate with existing credential\n   */ async authenticateWithExistingCredential(credentialId) {\n        try {\n            console.log(\"\\uD83D\\uDD11 Authenticating with existing credential: \".concat(credentialId));\n            const challenge = new Uint8Array(32);\n            crypto.getRandomValues(challenge);\n            const assertion = await navigator.credentials.get({\n                publicKey: {\n                    challenge,\n                    allowCredentials: [\n                        {\n                            type: \"public-key\",\n                            id: this.base64ToArrayBuffer(credentialId)\n                        }\n                    ],\n                    userVerification: \"required\",\n                    timeout: 60000\n                }\n            });\n            if (!assertion) {\n                throw new Error(\"Failed to authenticate with passkey\");\n            }\n            console.log(\"✅ Biometric authentication successful\");\n            return {\n                success: true,\n                credentialId: assertion.id,\n                signature: this.arrayBufferToBase64(assertion.response.signature)\n            };\n        } catch (error) {\n            console.error(\"❌ Failed to authenticate with existing credential:\", error);\n            return {\n                success: false,\n                error: error instanceof Error ? error.message : \"Authentication failed\"\n            };\n        }\n    }\n    /**\n   * Get existing credentials for a user\n   */ getExistingCredentials(userName) {\n        try {\n            // In a real implementation, you would store credential IDs\n            // For now, we'll check localStorage\n            const storedCredentials = localStorage.getItem(\"passkey_credentials_\".concat(userName));\n            return storedCredentials ? JSON.parse(storedCredentials) : [];\n        } catch (error) {\n            console.error(\"❌ Failed to get existing credentials:\", error);\n            return [];\n        }\n    }\n    /**\n   * Store credential ID for future use\n   */ storeCredentialId(userName, credentialId) {\n        try {\n            const existingCredentials = this.getExistingCredentials(userName);\n            if (!existingCredentials.includes(credentialId)) {\n                existingCredentials.push(credentialId);\n                localStorage.setItem(\"passkey_credentials_\".concat(userName), JSON.stringify(existingCredentials));\n            }\n        } catch (error) {\n            console.error(\"❌ Failed to store credential ID:\", error);\n        }\n    }\n    /**\n   * Step 2: Create or connect to Stellar smart wallet\n   * This follows the \"Passkey-Kit signs transaction\" step from the flow\n   */ async createOrConnectWallet(userName, role) {\n        try {\n            console.log(\"\\uD83C\\uDFE6 Creating/connecting smart wallet for \".concat(role, \": \").concat(userName));\n            // First authenticate with passkey\n            const authResult = await this.authenticateWithPasskey(userName);\n            if (!authResult.success) {\n                throw new Error(\"Biometric authentication failed: \".concat(authResult.error));\n            }\n            // Store credential ID for future use\n            if (authResult.credentialId) {\n                this.storeCredentialId(userName, authResult.credentialId);\n            }\n            // Generate Stellar keypair (in real implementation, this would be derived from passkey)\n            const keypair = this.generateStellarKeypair(authResult.credentialId || userName);\n            // Create smart wallet contract (simplified - in real implementation, this would use Passkey-Kit)\n            const contractId = await this.deploySmartWallet(keypair, userName, role);\n            this.walletInfo = {\n                address: keypair.publicKey(),\n                contractId: contractId,\n                isConnected: true\n            };\n            console.log(\"✅ Smart wallet created/connected successfully\");\n            console.log(\"\\uD83D\\uDCCD Address: \".concat(this.walletInfo.address));\n            console.log(\"\\uD83D\\uDCC4 Contract ID: \".concat(this.walletInfo.contractId));\n            return this.walletInfo;\n        } catch (error) {\n            console.error(\"❌ Failed to create/connect wallet:\", error);\n            throw error;\n        }\n    }\n    /**\n   * Step 3: Sign transaction with passkey\n   * This is the \"Passkey-Kit signs transaction\" step from the flow\n   */ async signTransactionWithPasskey(transaction, userName) {\n        try {\n            console.log(\"✍️ Signing transaction with passkey for: \".concat(userName));\n            // Authenticate with passkey first\n            const authResult = await this.authenticateWithPasskey(userName);\n            if (!authResult.success) {\n                throw new Error(\"Biometric authentication failed: \".concat(authResult.error));\n            }\n            // In a real implementation, you would use the passkey signature to sign the transaction\n            // For now, we'll simulate the signing process\n            console.log(\"✅ Transaction signed with passkey successfully\");\n            return transaction;\n        } catch (error) {\n            console.error(\"❌ Failed to sign transaction with passkey:\", error);\n            throw error;\n        }\n    }\n    /**\n   * Generate Stellar keypair (simplified implementation)\n   */ generateStellarKeypair(seed) {\n        // In a real implementation, this would use proper key derivation\n        // For now, we'll create a deterministic keypair\n        const hash = new TextEncoder().encode(seed);\n        const keypair = {\n            publicKey: ()=>\"G\".concat(seed.substring(0, 55)),\n            secret: ()=>\"S\".concat(seed.substring(0, 55))\n        };\n        return keypair;\n    }\n    /**\n   * Deploy smart wallet contract (simplified implementation)\n   */ async deploySmartWallet(keypair, userName, role) {\n        // In a real implementation, this would deploy an actual smart wallet contract\n        // For now, we'll return a mock contract ID\n        const contractId = \"CC\".concat(role.toUpperCase(), \"_\").concat(userName.replace(/\\s+/g, \"_\"), \"_\").concat(Date.now());\n        console.log(\"\\uD83D\\uDCC4 Smart wallet contract deployed: \".concat(contractId));\n        return contractId;\n    }\n    /**\n   * Utility functions\n   */ arrayBufferToBase64(buffer) {\n        const bytes = new Uint8Array(buffer);\n        let binary = \"\";\n        for(let i = 0; i < bytes.byteLength; i++){\n            binary += String.fromCharCode(bytes[i]);\n        }\n        return btoa(binary);\n    }\n    base64ToArrayBuffer(base64) {\n        const binary = atob(base64);\n        const bytes = new Uint8Array(binary.length);\n        for(let i = 0; i < binary.length; i++){\n            bytes[i] = binary.charCodeAt(i);\n        }\n        return bytes.buffer;\n    }\n    /**\n   * Get current wallet info\n   */ getWalletInfo() {\n        return this.walletInfo;\n    }\n    /**\n   * Disconnect wallet\n   */ disconnect() {\n        this.walletInfo = null;\n        console.log(\"\\uD83D\\uDD0C Wallet disconnected\");\n    }\n    constructor(config){\n        this.walletInfo = null;\n        this.config = config;\n    }\n}\n// Factory function to create PasskeyAuthenticator\nfunction createPasskeyAuthenticator(config) {\n    return new PasskeyAuthenticator(config);\n}\n// Default configuration\nfunction getDefaultPasskeyConfig() {\n    return {\n        rpcUrl: process.env.NEXT_PUBLIC_RPC_URL || \"https://soroban-testnet.stellar.org\",\n        networkPassphrase: process.env.NEXT_PUBLIC_NETWORK_PASSPHRASE || \"Test SDF Network ; September 2015\",\n        factoryContractId: process.env.NEXT_PUBLIC_FACTORY_CONTRACT_ID || \"CCWJFJ7YQHZ3QH2GQYQZQZQZQZQZQZQZQZQZQZQZQZQZQZQ\"\n    };\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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LElBQUk7UUFDakVDLG1CQUFtQkwsT0FBT0EsQ0FBQ0MsR0FBRyxDQUFDSywrQkFBK0IsSUFBSTtJQUNwRTtBQUNGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL2xpYi9wYXNza2V5LWF1dGgudHM/N2YzYSJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBSZWFsIFBhc3NrZXkgQXV0aGVudGljYXRpb24gSW1wbGVtZW50YXRpb25cbi8vIEZvbGxvd2luZyB0aGUgY29tcGxldGUgZmxvdyBkaWFncmFtIGZyb20gdGhlIGRvY3VtZW50YXRpb25cblxuaW1wb3J0IHsgQ29udHJhY3QsIFNvcm9iYW5ScGMsIE5ldHdvcmtzLCBUcmFuc2FjdGlvbiwgQkFTRV9GRUUgfSBmcm9tICdAc3RlbGxhci9zdGVsbGFyLXNkaydcblxuZXhwb3J0IGludGVyZmFjZSBQYXNza2V5QXV0aENvbmZpZyB7XG4gIHJwY1VybDogc3RyaW5nXG4gIG5ldHdvcmtQYXNzcGhyYXNlOiBzdHJpbmdcbiAgZmFjdG9yeUNvbnRyYWN0SWQ6IHN0cmluZ1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIEJpb21ldHJpY0F1dGhSZXN1bHQge1xuICBzdWNjZXNzOiBib29sZWFuXG4gIGNyZWRlbnRpYWxJZD86IHN0cmluZ1xuICBwdWJsaWNLZXk/OiBzdHJpbmdcbiAgc2lnbmF0dXJlPzogc3RyaW5nXG4gIGVycm9yPzogc3RyaW5nXG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgV2FsbGV0SW5mbyB7XG4gIGFkZHJlc3M6IHN0cmluZ1xuICBjb250cmFjdElkOiBzdHJpbmdcbiAgaXNDb25uZWN0ZWQ6IGJvb2xlYW5cbn1cblxuZXhwb3J0IGNsYXNzIFBhc3NrZXlBdXRoZW50aWNhdG9yIHtcbiAgcHJpdmF0ZSBjb25maWc6IFBhc3NrZXlBdXRoQ29uZmlnXG4gIHByaXZhdGUgd2FsbGV0SW5mbzogV2FsbGV0SW5mbyB8IG51bGwgPSBudWxsXG5cbiAgY29uc3RydWN0b3IoY29uZmlnOiBQYXNza2V5QXV0aENvbmZpZykge1xuICAgIHRoaXMuY29uZmlnID0gY29uZmlnXG4gIH1cblxuICAvKipcbiAgICogU3RlcCAxOiBBdXRoZW50aWNhdGUgd2l0aCBQYXNza2V5IChiaW9tZXRyaWMpXG4gICAqIFRoaXMgaXMgdGhlIGNvcmUgYmlvbWV0cmljIGF1dGhlbnRpY2F0aW9uIHN0ZXAgZnJvbSB0aGUgZmxvdyBkaWFncmFtXG4gICAqL1xuICBhc3luYyBhdXRoZW50aWNhdGVXaXRoUGFzc2tleSh1c2VyTmFtZTogc3RyaW5nKTogUHJvbWlzZTxCaW9tZXRyaWNBdXRoUmVzdWx0PiB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnNvbGUubG9nKGDwn5SQIFN0YXJ0aW5nIGJpb21ldHJpYyBhdXRoZW50aWNhdGlvbiBmb3I6ICR7dXNlck5hbWV9YClcbiAgICAgIFxuICAgICAgLy8gQ2hlY2sgaWYgV2ViQXV0aG4gaXMgc3VwcG9ydGVkXG4gICAgICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcgfHwgIXdpbmRvdy5QdWJsaWNLZXlDcmVkZW50aWFsKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignV2ViQXV0aG4vUGFzc2tleXMgbm90IHN1cHBvcnRlZCBpbiB0aGlzIGJyb3dzZXInKVxuICAgICAgfVxuXG4gICAgICAvLyBDaGVjayBpZiB1c2VyIGhhcyBleGlzdGluZyBjcmVkZW50aWFsc1xuICAgICAgY29uc3QgZXhpc3RpbmdDcmVkZW50aWFscyA9IHRoaXMuZ2V0RXhpc3RpbmdDcmVkZW50aWFscyh1c2VyTmFtZSlcbiAgICAgIFxuICAgICAgaWYgKGV4aXN0aW5nQ3JlZGVudGlhbHMubGVuZ3RoID4gMCkge1xuICAgICAgICAvLyBVc2UgZXhpc3RpbmcgY3JlZGVudGlhbCBmb3IgYXV0aGVudGljYXRpb25cbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuYXV0aGVudGljYXRlV2l0aEV4aXN0aW5nQ3JlZGVudGlhbChleGlzdGluZ0NyZWRlbnRpYWxzWzBdKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gQ3JlYXRlIG5ldyBjcmVkZW50aWFsXG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLmNyZWF0ZU5ld0NyZWRlbnRpYWwodXNlck5hbWUpXG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ+KdjCBCaW9tZXRyaWMgYXV0aGVudGljYXRpb24gZmFpbGVkOicsIGVycm9yKVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgc3VjY2VzczogZmFsc2UsXG4gICAgICAgIGVycm9yOiBlcnJvciBpbnN0YW5jZW9mIEVycm9yID8gZXJyb3IubWVzc2FnZSA6ICdBdXRoZW50aWNhdGlvbiBmYWlsZWQnXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBuZXcgcGFzc2tleSBjcmVkZW50aWFsXG4gICAqL1xuICBwcml2YXRlIGFzeW5jIGNyZWF0ZU5ld0NyZWRlbnRpYWwodXNlck5hbWU6IHN0cmluZyk6IFByb21pc2U8QmlvbWV0cmljQXV0aFJlc3VsdD4ge1xuICAgIHRyeSB7XG4gICAgICBjb25zb2xlLmxvZyhg8J+GlSBDcmVhdGluZyBuZXcgcGFzc2tleSBjcmVkZW50aWFsIGZvcjogJHt1c2VyTmFtZX1gKVxuICAgICAgXG4gICAgICBjb25zdCBjaGFsbGVuZ2UgPSBuZXcgVWludDhBcnJheSgzMilcbiAgICAgIGNyeXB0by5nZXRSYW5kb21WYWx1ZXMoY2hhbGxlbmdlKVxuXG4gICAgICBjb25zdCBjcmVkZW50aWFsID0gYXdhaXQgbmF2aWdhdG9yLmNyZWRlbnRpYWxzLmNyZWF0ZSh7XG4gICAgICAgIHB1YmxpY0tleToge1xuICAgICAgICAgIGNoYWxsZW5nZSxcbiAgICAgICAgICBycDoge1xuICAgICAgICAgICAgbmFtZTogXCJTdGVsbGFyIFByb2N1cmVtZW50IGRBcHBcIixcbiAgICAgICAgICAgIGlkOiB3aW5kb3cubG9jYXRpb24uaG9zdG5hbWUsXG4gICAgICAgICAgfSxcbiAgICAgICAgICB1c2VyOiB7XG4gICAgICAgICAgICBpZDogbmV3IFRleHRFbmNvZGVyKCkuZW5jb2RlKHVzZXJOYW1lKSxcbiAgICAgICAgICAgIG5hbWU6IHVzZXJOYW1lLFxuICAgICAgICAgICAgZGlzcGxheU5hbWU6IHVzZXJOYW1lLFxuICAgICAgICAgIH0sXG4gICAgICAgICAgcHViS2V5Q3JlZFBhcmFtczogW1xuICAgICAgICAgICAgeyB0eXBlOiBcInB1YmxpYy1rZXlcIiwgYWxnOiAtNyB9LCAvLyBFUzI1NlxuICAgICAgICAgICAgeyB0eXBlOiBcInB1YmxpYy1rZXlcIiwgYWxnOiAtMjU3IH0sIC8vIFJTMjU2XG4gICAgICAgICAgXSxcbiAgICAgICAgICBhdXRoZW50aWNhdG9yU2VsZWN0aW9uOiB7XG4gICAgICAgICAgICBhdXRoZW50aWNhdG9yQXR0YWNobWVudDogXCJwbGF0Zm9ybVwiLCAvLyBCdWlsdC1pbiBhdXRoZW50aWNhdG9yc1xuICAgICAgICAgICAgdXNlclZlcmlmaWNhdGlvbjogXCJyZXF1aXJlZFwiLFxuICAgICAgICAgICAgcmVzaWRlbnRLZXk6IFwicmVxdWlyZWRcIixcbiAgICAgICAgICB9LFxuICAgICAgICAgIHRpbWVvdXQ6IDYwMDAwLFxuICAgICAgICAgIGF0dGVzdGF0aW9uOiBcImRpcmVjdFwiLFxuICAgICAgICB9LFxuICAgICAgfSkgYXMgUHVibGljS2V5Q3JlZGVudGlhbFxuXG4gICAgICBpZiAoIWNyZWRlbnRpYWwpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdGYWlsZWQgdG8gY3JlYXRlIHBhc3NrZXkgY3JlZGVudGlhbCcpXG4gICAgICB9XG5cbiAgICAgIGNvbnNvbGUubG9nKGDinIUgTmV3IHBhc3NrZXkgY3JlZGVudGlhbCBjcmVhdGVkIHN1Y2Nlc3NmdWxseWApXG4gICAgICBcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHN1Y2Nlc3M6IHRydWUsXG4gICAgICAgIGNyZWRlbnRpYWxJZDogY3JlZGVudGlhbC5pZCxcbiAgICAgICAgcHVibGljS2V5OiB0aGlzLmFycmF5QnVmZmVyVG9CYXNlNjQoY3JlZGVudGlhbC5yZXNwb25zZS5wdWJsaWNLZXkgfHwgbmV3IEFycmF5QnVmZmVyKDApKVxuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCfinYwgRmFpbGVkIHRvIGNyZWF0ZSBwYXNza2V5IGNyZWRlbnRpYWw6JywgZXJyb3IpXG4gICAgICByZXR1cm4ge1xuICAgICAgICBzdWNjZXNzOiBmYWxzZSxcbiAgICAgICAgZXJyb3I6IGVycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvci5tZXNzYWdlIDogJ0NyZWRlbnRpYWwgY3JlYXRpb24gZmFpbGVkJ1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBBdXRoZW50aWNhdGUgd2l0aCBleGlzdGluZyBjcmVkZW50aWFsXG4gICAqL1xuICBwcml2YXRlIGFzeW5jIGF1dGhlbnRpY2F0ZVdpdGhFeGlzdGluZ0NyZWRlbnRpYWwoY3JlZGVudGlhbElkOiBzdHJpbmcpOiBQcm9taXNlPEJpb21ldHJpY0F1dGhSZXN1bHQ+IHtcbiAgICB0cnkge1xuICAgICAgY29uc29sZS5sb2coYPCflJEgQXV0aGVudGljYXRpbmcgd2l0aCBleGlzdGluZyBjcmVkZW50aWFsOiAke2NyZWRlbnRpYWxJZH1gKVxuICAgICAgXG4gICAgICBjb25zdCBjaGFsbGVuZ2UgPSBuZXcgVWludDhBcnJheSgzMilcbiAgICAgIGNyeXB0by5nZXRSYW5kb21WYWx1ZXMoY2hhbGxlbmdlKVxuXG4gICAgICBjb25zdCBhc3NlcnRpb24gPSBhd2FpdCBuYXZpZ2F0b3IuY3JlZGVudGlhbHMuZ2V0KHtcbiAgICAgICAgcHVibGljS2V5OiB7XG4gICAgICAgICAgY2hhbGxlbmdlLFxuICAgICAgICAgIGFsbG93Q3JlZGVudGlhbHM6IFt7XG4gICAgICAgICAgICB0eXBlOiAncHVibGljLWtleScsXG4gICAgICAgICAgICBpZDogdGhpcy5iYXNlNjRUb0FycmF5QnVmZmVyKGNyZWRlbnRpYWxJZCksXG4gICAgICAgICAgfV0sXG4gICAgICAgICAgdXNlclZlcmlmaWNhdGlvbjogXCJyZXF1aXJlZFwiLFxuICAgICAgICAgIHRpbWVvdXQ6IDYwMDAwLFxuICAgICAgICB9LFxuICAgICAgfSkgYXMgUHVibGljS2V5Q3JlZGVudGlhbFxuXG4gICAgICBpZiAoIWFzc2VydGlvbikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZhaWxlZCB0byBhdXRoZW50aWNhdGUgd2l0aCBwYXNza2V5JylcbiAgICAgIH1cblxuICAgICAgY29uc29sZS5sb2coYOKchSBCaW9tZXRyaWMgYXV0aGVudGljYXRpb24gc3VjY2Vzc2Z1bGApXG4gICAgICBcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHN1Y2Nlc3M6IHRydWUsXG4gICAgICAgIGNyZWRlbnRpYWxJZDogYXNzZXJ0aW9uLmlkLFxuICAgICAgICBzaWduYXR1cmU6IHRoaXMuYXJyYXlCdWZmZXJUb0Jhc2U2NChhc3NlcnRpb24ucmVzcG9uc2Uuc2lnbmF0dXJlKVxuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCfinYwgRmFpbGVkIHRvIGF1dGhlbnRpY2F0ZSB3aXRoIGV4aXN0aW5nIGNyZWRlbnRpYWw6JywgZXJyb3IpXG4gICAgICByZXR1cm4ge1xuICAgICAgICBzdWNjZXNzOiBmYWxzZSxcbiAgICAgICAgZXJyb3I6IGVycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvci5tZXNzYWdlIDogJ0F1dGhlbnRpY2F0aW9uIGZhaWxlZCdcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogR2V0IGV4aXN0aW5nIGNyZWRlbnRpYWxzIGZvciBhIHVzZXJcbiAgICovXG4gIHByaXZhdGUgZ2V0RXhpc3RpbmdDcmVkZW50aWFscyh1c2VyTmFtZTogc3RyaW5nKTogc3RyaW5nW10ge1xuICAgIHRyeSB7XG4gICAgICAvLyBJbiBhIHJlYWwgaW1wbGVtZW50YXRpb24sIHlvdSB3b3VsZCBzdG9yZSBjcmVkZW50aWFsIElEc1xuICAgICAgLy8gRm9yIG5vdywgd2UnbGwgY2hlY2sgbG9jYWxTdG9yYWdlXG4gICAgICBjb25zdCBzdG9yZWRDcmVkZW50aWFscyA9IGxvY2FsU3RvcmFnZS5nZXRJdGVtKGBwYXNza2V5X2NyZWRlbnRpYWxzXyR7dXNlck5hbWV9YClcbiAgICAgIHJldHVybiBzdG9yZWRDcmVkZW50aWFscyA/IEpTT04ucGFyc2Uoc3RvcmVkQ3JlZGVudGlhbHMpIDogW11cbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcign4p2MIEZhaWxlZCB0byBnZXQgZXhpc3RpbmcgY3JlZGVudGlhbHM6JywgZXJyb3IpXG4gICAgICByZXR1cm4gW11cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogU3RvcmUgY3JlZGVudGlhbCBJRCBmb3IgZnV0dXJlIHVzZVxuICAgKi9cbiAgcHJpdmF0ZSBzdG9yZUNyZWRlbnRpYWxJZCh1c2VyTmFtZTogc3RyaW5nLCBjcmVkZW50aWFsSWQ6IHN0cmluZyk6IHZvaWQge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBleGlzdGluZ0NyZWRlbnRpYWxzID0gdGhpcy5nZXRFeGlzdGluZ0NyZWRlbnRpYWxzKHVzZXJOYW1lKVxuICAgICAgaWYgKCFleGlzdGluZ0NyZWRlbnRpYWxzLmluY2x1ZGVzKGNyZWRlbnRpYWxJZCkpIHtcbiAgICAgICAgZXhpc3RpbmdDcmVkZW50aWFscy5wdXNoKGNyZWRlbnRpYWxJZClcbiAgICAgICAgbG9jYWxTdG9yYWdlLnNldEl0ZW0oYHBhc3NrZXlfY3JlZGVudGlhbHNfJHt1c2VyTmFtZX1gLCBKU09OLnN0cmluZ2lmeShleGlzdGluZ0NyZWRlbnRpYWxzKSlcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcign4p2MIEZhaWxlZCB0byBzdG9yZSBjcmVkZW50aWFsIElEOicsIGVycm9yKVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBTdGVwIDI6IENyZWF0ZSBvciBjb25uZWN0IHRvIFN0ZWxsYXIgc21hcnQgd2FsbGV0XG4gICAqIFRoaXMgZm9sbG93cyB0aGUgXCJQYXNza2V5LUtpdCBzaWducyB0cmFuc2FjdGlvblwiIHN0ZXAgZnJvbSB0aGUgZmxvd1xuICAgKi9cbiAgYXN5bmMgY3JlYXRlT3JDb25uZWN0V2FsbGV0KHVzZXJOYW1lOiBzdHJpbmcsIHJvbGU6ICdidXllcicgfCAnc2VsbGVyJyk6IFByb21pc2U8V2FsbGV0SW5mbz4ge1xuICAgIHRyeSB7XG4gICAgICBjb25zb2xlLmxvZyhg8J+PpiBDcmVhdGluZy9jb25uZWN0aW5nIHNtYXJ0IHdhbGxldCBmb3IgJHtyb2xlfTogJHt1c2VyTmFtZX1gKVxuICAgICAgXG4gICAgICAvLyBGaXJzdCBhdXRoZW50aWNhdGUgd2l0aCBwYXNza2V5XG4gICAgICBjb25zdCBhdXRoUmVzdWx0ID0gYXdhaXQgdGhpcy5hdXRoZW50aWNhdGVXaXRoUGFzc2tleSh1c2VyTmFtZSlcbiAgICAgIFxuICAgICAgaWYgKCFhdXRoUmVzdWx0LnN1Y2Nlc3MpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBCaW9tZXRyaWMgYXV0aGVudGljYXRpb24gZmFpbGVkOiAke2F1dGhSZXN1bHQuZXJyb3J9YClcbiAgICAgIH1cblxuICAgICAgLy8gU3RvcmUgY3JlZGVudGlhbCBJRCBmb3IgZnV0dXJlIHVzZVxuICAgICAgaWYgKGF1dGhSZXN1bHQuY3JlZGVudGlhbElkKSB7XG4gICAgICAgIHRoaXMuc3RvcmVDcmVkZW50aWFsSWQodXNlck5hbWUsIGF1dGhSZXN1bHQuY3JlZGVudGlhbElkKVxuICAgICAgfVxuXG4gICAgICAvLyBHZW5lcmF0ZSBTdGVsbGFyIGtleXBhaXIgKGluIHJlYWwgaW1wbGVtZW50YXRpb24sIHRoaXMgd291bGQgYmUgZGVyaXZlZCBmcm9tIHBhc3NrZXkpXG4gICAgICBjb25zdCBrZXlwYWlyID0gdGhpcy5nZW5lcmF0ZVN0ZWxsYXJLZXlwYWlyKGF1dGhSZXN1bHQuY3JlZGVudGlhbElkIHx8IHVzZXJOYW1lKVxuICAgICAgXG4gICAgICAvLyBDcmVhdGUgc21hcnQgd2FsbGV0IGNvbnRyYWN0IChzaW1wbGlmaWVkIC0gaW4gcmVhbCBpbXBsZW1lbnRhdGlvbiwgdGhpcyB3b3VsZCB1c2UgUGFzc2tleS1LaXQpXG4gICAgICBjb25zdCBjb250cmFjdElkID0gYXdhaXQgdGhpcy5kZXBsb3lTbWFydFdhbGxldChrZXlwYWlyLCB1c2VyTmFtZSwgcm9sZSlcbiAgICAgIFxuICAgICAgdGhpcy53YWxsZXRJbmZvID0ge1xuICAgICAgICBhZGRyZXNzOiBrZXlwYWlyLnB1YmxpY0tleSgpLFxuICAgICAgICBjb250cmFjdElkOiBjb250cmFjdElkLFxuICAgICAgICBpc0Nvbm5lY3RlZDogdHJ1ZVxuICAgICAgfVxuXG4gICAgICBjb25zb2xlLmxvZyhg4pyFIFNtYXJ0IHdhbGxldCBjcmVhdGVkL2Nvbm5lY3RlZCBzdWNjZXNzZnVsbHlgKVxuICAgICAgY29uc29sZS5sb2coYPCfk40gQWRkcmVzczogJHt0aGlzLndhbGxldEluZm8uYWRkcmVzc31gKVxuICAgICAgY29uc29sZS5sb2coYPCfk4QgQ29udHJhY3QgSUQ6ICR7dGhpcy53YWxsZXRJbmZvLmNvbnRyYWN0SWR9YClcbiAgICAgIFxuICAgICAgcmV0dXJuIHRoaXMud2FsbGV0SW5mb1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCfinYwgRmFpbGVkIHRvIGNyZWF0ZS9jb25uZWN0IHdhbGxldDonLCBlcnJvcilcbiAgICAgIHRocm93IGVycm9yXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFN0ZXAgMzogU2lnbiB0cmFuc2FjdGlvbiB3aXRoIHBhc3NrZXlcbiAgICogVGhpcyBpcyB0aGUgXCJQYXNza2V5LUtpdCBzaWducyB0cmFuc2FjdGlvblwiIHN0ZXAgZnJvbSB0aGUgZmxvd1xuICAgKi9cbiAgYXN5bmMgc2lnblRyYW5zYWN0aW9uV2l0aFBhc3NrZXkodHJhbnNhY3Rpb246IFRyYW5zYWN0aW9uLCB1c2VyTmFtZTogc3RyaW5nKTogUHJvbWlzZTxUcmFuc2FjdGlvbj4ge1xuICAgIHRyeSB7XG4gICAgICBjb25zb2xlLmxvZyhg4pyN77iPIFNpZ25pbmcgdHJhbnNhY3Rpb24gd2l0aCBwYXNza2V5IGZvcjogJHt1c2VyTmFtZX1gKVxuICAgICAgXG4gICAgICAvLyBBdXRoZW50aWNhdGUgd2l0aCBwYXNza2V5IGZpcnN0XG4gICAgICBjb25zdCBhdXRoUmVzdWx0ID0gYXdhaXQgdGhpcy5hdXRoZW50aWNhdGVXaXRoUGFzc2tleSh1c2VyTmFtZSlcbiAgICAgIFxuICAgICAgaWYgKCFhdXRoUmVzdWx0LnN1Y2Nlc3MpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBCaW9tZXRyaWMgYXV0aGVudGljYXRpb24gZmFpbGVkOiAke2F1dGhSZXN1bHQuZXJyb3J9YClcbiAgICAgIH1cblxuICAgICAgLy8gSW4gYSByZWFsIGltcGxlbWVudGF0aW9uLCB5b3Ugd291bGQgdXNlIHRoZSBwYXNza2V5IHNpZ25hdHVyZSB0byBzaWduIHRoZSB0cmFuc2FjdGlvblxuICAgICAgLy8gRm9yIG5vdywgd2UnbGwgc2ltdWxhdGUgdGhlIHNpZ25pbmcgcHJvY2Vzc1xuICAgICAgY29uc29sZS5sb2coYOKchSBUcmFuc2FjdGlvbiBzaWduZWQgd2l0aCBwYXNza2V5IHN1Y2Nlc3NmdWxseWApXG4gICAgICBcbiAgICAgIHJldHVybiB0cmFuc2FjdGlvblxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCfinYwgRmFpbGVkIHRvIHNpZ24gdHJhbnNhY3Rpb24gd2l0aCBwYXNza2V5OicsIGVycm9yKVxuICAgICAgdGhyb3cgZXJyb3JcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogR2VuZXJhdGUgU3RlbGxhciBrZXlwYWlyIChzaW1wbGlmaWVkIGltcGxlbWVudGF0aW9uKVxuICAgKi9cbiAgcHJpdmF0ZSBnZW5lcmF0ZVN0ZWxsYXJLZXlwYWlyKHNlZWQ6IHN0cmluZyk6IGFueSB7XG4gICAgLy8gSW4gYSByZWFsIGltcGxlbWVudGF0aW9uLCB0aGlzIHdvdWxkIHVzZSBwcm9wZXIga2V5IGRlcml2YXRpb25cbiAgICAvLyBGb3Igbm93LCB3ZSdsbCBjcmVhdGUgYSBkZXRlcm1pbmlzdGljIGtleXBhaXJcbiAgICBjb25zdCBoYXNoID0gbmV3IFRleHRFbmNvZGVyKCkuZW5jb2RlKHNlZWQpXG4gICAgY29uc3Qga2V5cGFpciA9IHtcbiAgICAgIHB1YmxpY0tleTogKCkgPT4gYEcke3NlZWQuc3Vic3RyaW5nKDAsIDU1KX1gLFxuICAgICAgc2VjcmV0OiAoKSA9PiBgUyR7c2VlZC5zdWJzdHJpbmcoMCwgNTUpfWBcbiAgICB9XG4gICAgcmV0dXJuIGtleXBhaXJcbiAgfVxuXG4gIC8qKlxuICAgKiBEZXBsb3kgc21hcnQgd2FsbGV0IGNvbnRyYWN0IChzaW1wbGlmaWVkIGltcGxlbWVudGF0aW9uKVxuICAgKi9cbiAgcHJpdmF0ZSBhc3luYyBkZXBsb3lTbWFydFdhbGxldChrZXlwYWlyOiBhbnksIHVzZXJOYW1lOiBzdHJpbmcsIHJvbGU6IHN0cmluZyk6IFByb21pc2U8c3RyaW5nPiB7XG4gICAgLy8gSW4gYSByZWFsIGltcGxlbWVudGF0aW9uLCB0aGlzIHdvdWxkIGRlcGxveSBhbiBhY3R1YWwgc21hcnQgd2FsbGV0IGNvbnRyYWN0XG4gICAgLy8gRm9yIG5vdywgd2UnbGwgcmV0dXJuIGEgbW9jayBjb250cmFjdCBJRFxuICAgIGNvbnN0IGNvbnRyYWN0SWQgPSBgQ0Mke3JvbGUudG9VcHBlckNhc2UoKX1fJHt1c2VyTmFtZS5yZXBsYWNlKC9cXHMrL2csICdfJyl9XyR7RGF0ZS5ub3coKX1gXG4gICAgY29uc29sZS5sb2coYPCfk4QgU21hcnQgd2FsbGV0IGNvbnRyYWN0IGRlcGxveWVkOiAke2NvbnRyYWN0SWR9YClcbiAgICByZXR1cm4gY29udHJhY3RJZFxuICB9XG5cbiAgLyoqXG4gICAqIFV0aWxpdHkgZnVuY3Rpb25zXG4gICAqL1xuICBwcml2YXRlIGFycmF5QnVmZmVyVG9CYXNlNjQoYnVmZmVyOiBBcnJheUJ1ZmZlcik6IHN0cmluZyB7XG4gICAgY29uc3QgYnl0ZXMgPSBuZXcgVWludDhBcnJheShidWZmZXIpXG4gICAgbGV0IGJpbmFyeSA9ICcnXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBieXRlcy5ieXRlTGVuZ3RoOyBpKyspIHtcbiAgICAgIGJpbmFyeSArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGJ5dGVzW2ldKVxuICAgIH1cbiAgICByZXR1cm4gYnRvYShiaW5hcnkpXG4gIH1cblxuICBwcml2YXRlIGJhc2U2NFRvQXJyYXlCdWZmZXIoYmFzZTY0OiBzdHJpbmcpOiBBcnJheUJ1ZmZlciB7XG4gICAgY29uc3QgYmluYXJ5ID0gYXRvYihiYXNlNjQpXG4gICAgY29uc3QgYnl0ZXMgPSBuZXcgVWludDhBcnJheShiaW5hcnkubGVuZ3RoKVxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYmluYXJ5Lmxlbmd0aDsgaSsrKSB7XG4gICAgICBieXRlc1tpXSA9IGJpbmFyeS5jaGFyQ29kZUF0KGkpXG4gICAgfVxuICAgIHJldHVybiBieXRlcy5idWZmZXJcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgY3VycmVudCB3YWxsZXQgaW5mb1xuICAgKi9cbiAgZ2V0V2FsbGV0SW5mbygpOiBXYWxsZXRJbmZvIHwgbnVsbCB7XG4gICAgcmV0dXJuIHRoaXMud2FsbGV0SW5mb1xuICB9XG5cbiAgLyoqXG4gICAqIERpc2Nvbm5lY3Qgd2FsbGV0XG4gICAqL1xuICBkaXNjb25uZWN0KCk6IHZvaWQge1xuICAgIHRoaXMud2FsbGV0SW5mbyA9IG51bGxcbiAgICBjb25zb2xlLmxvZygn8J+UjCBXYWxsZXQgZGlzY29ubmVjdGVkJylcbiAgfVxufVxuXG4vLyBGYWN0b3J5IGZ1bmN0aW9uIHRvIGNyZWF0ZSBQYXNza2V5QXV0aGVudGljYXRvclxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZVBhc3NrZXlBdXRoZW50aWNhdG9yKGNvbmZpZzogUGFzc2tleUF1dGhDb25maWcpOiBQYXNza2V5QXV0aGVudGljYXRvciB7XG4gIHJldHVybiBuZXcgUGFzc2tleUF1dGhlbnRpY2F0b3IoY29uZmlnKVxufVxuXG4vLyBEZWZhdWx0IGNvbmZpZ3VyYXRpb25cbmV4cG9ydCBmdW5jdGlvbiBnZXREZWZhdWx0UGFzc2tleUNvbmZpZygpOiBQYXNza2V5QXV0aENvbmZpZyB7XG4gIHJldHVybiB7XG4gICAgcnBjVXJsOiBwcm9jZXNzLmVudi5ORVhUX1BVQkxJQ19SUENfVVJMIHx8ICdodHRwczovL3Nvcm9iYW4tdGVzdG5ldC5zdGVsbGFyLm9yZycsXG4gICAgbmV0d29ya1Bhc3NwaHJhc2U6IHByb2Nlc3MuZW52Lk5FWFRfUFVCTElDX05FVFdPUktfUEFTU1BIUkFTRSB8fCAnVGVzdCBTREYgTmV0d29yayA7IFNlcHRlbWJlciAyMDE1JyxcbiAgICBmYWN0b3J5Q29udHJhY3RJZDogcHJvY2Vzcy5lbnYuTkVYVF9QVUJMSUNfRkFDVE9SWV9DT05UUkFDVF9JRCB8fCAnQ0NXSkZKN1lRSFozUUgyR1FZUVpRWlFaUVpRWlFaUVpRWlFaUVpRWlFaUVpRWlEnXG4gIH1cbn1cbiJdLCJuYW1lcyI6WyJQYXNza2V5QXV0aGVudGljYXRvciIsImF1dGhlbnRpY2F0ZVdpdGhQYXNza2V5IiwidXNlck5hbWUiLCJjb25zb2xlIiwibG9nIiwid2luZG93IiwiUHVibGljS2V5Q3JlZGVudGlhbCIsIkVycm9yIiwiZXhpc3RpbmdDcmVkZW50aWFscyIsImdldEV4aXN0aW5nQ3JlZGVudGlhbHMiLCJsZW5ndGgiLCJhdXRoZW50aWNhdGVXaXRoRXhpc3RpbmdDcmVkZW50aWFsIiwiY3JlYXRlTmV3Q3JlZGVudGlhbCIsImVycm9yIiwic3VjY2VzcyIsIm1lc3NhZ2UiLCJjaGFsbGVuZ2UiLCJVaW50OEFycmF5IiwiY3J5cHRvIiwiZ2V0UmFuZG9tVmFsdWVzIiwiY3JlZGVudGlhbCIsIm5hdmlnYXRvciIsImNyZWRlbnRpYWxzIiwiY3JlYXRlIiwicHVibGljS2V5IiwicnAiLCJuYW1lIiwiaWQiLCJsb2NhdGlvbiIsImhvc3RuYW1lIiwidXNlciIsIlRleHRFbmNvZGVyIiwiZW5jb2RlIiwiZGlzcGxheU5hbWUiLCJwdWJLZXlDcmVkUGFyYW1zIiwidHlwZSIsImFsZyIsImF1dGhlbnRpY2F0b3JTZWxlY3Rpb24iLCJhdXRoZW50aWNhdG9yQXR0YWNobWVudCIsInVzZXJWZXJpZmljYXRpb24iLCJyZXNpZGVudEtleSIsInRpbWVvdXQiLCJhdHRlc3RhdGlvbiIsImNyZWRlbnRpYWxJZCIsImFycmF5QnVmZmVyVG9CYXNlNjQiLCJyZXNwb25zZSIsIkFycmF5QnVmZmVyIiwiYXNzZXJ0aW9uIiwiZ2V0IiwiYWxsb3dDcmVkZW50aWFscyIsImJhc2U2NFRvQXJyYXlCdWZmZXIiLCJzaWduYXR1cmUiLCJzdG9yZWRDcmVkZW50aWFscyIsImxvY2FsU3RvcmFnZSIsImdldEl0ZW0iLCJKU09OIiwicGFyc2UiLCJzdG9yZUNyZWRlbnRpYWxJZCIsImluY2x1ZGVzIiwicHVzaCIsInNldEl0ZW0iLCJzdHJpbmdpZnkiLCJjcmVhdGVPckNvbm5lY3RXYWxsZXQiLCJyb2xlIiwiYXV0aFJlc3VsdCIsImtleXBhaXIiLCJnZW5lcmF0ZVN0ZWxsYXJLZXlwYWlyIiwiY29udHJhY3RJZCIsImRlcGxveVNtYXJ0V2FsbGV0Iiwid2FsbGV0SW5mbyIsImFkZHJlc3MiLCJpc0Nvbm5lY3RlZCIsInNpZ25UcmFuc2FjdGlvbldpdGhQYXNza2V5IiwidHJhbnNhY3Rpb24iLCJzZWVkIiwiaGFzaCIsInN1YnN0cmluZyIsInNlY3JldCIsInRvVXBwZXJDYXNlIiwiRGF0ZSIsInJlcGxhY2UiLCJub3ciLCJidWZmZXIiLCJieXRlcyIsImJpbmFyeSIsImkiLCJieXRlTGVuZ3RoIiwiU3RyaW5nIiwiZnJvbUNoYXJDb2RlIiwiYnRvYSIsImJhc2U2NCIsImF0b2IiLCJjaGFyQ29kZUF0IiwiZ2V0V2FsbGV0SW5mbyIsImRpc2Nvbm5lY3QiLCJjb25zdHJ1Y3RvciIsImNvbmZpZyIsImNyZWF0ZVBhc3NrZXlBdXRoZW50aWNhdG9yIiwiZ2V0RGVmYXVsdFBhc3NrZXlDb25maWciLCJycGNVcmwiLCJwcm9jZXNzIiwiZW52IiwiTkVYVF9QVUJMSUNfUlBDX1VSTCIsIm5ldHdvcmtQYXNzcGhyYXNlIiwiTkVYVF9QVUJMSUNfTkVUV09SS19QQVNTUEhSQVNFIiwiZmFjdG9yeUNvbnRyYWN0SWQiLCJORVhUX1BVQkxJQ19GQUNUT1JZX0NPTlRSQUNUX0lEIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./lib/passkey-auth.ts\n"));

/***/ })

});