"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./contexts/PasskeyWalletContext.tsx":
/*!*******************************************!*\
  !*** ./contexts/PasskeyWalletContext.tsx ***!
  \*******************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   PasskeyWalletProvider: function() { return /* binding */ PasskeyWalletProvider; },\n/* harmony export */   usePasskeyWallet: function() { return /* binding */ usePasskeyWallet; }\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _VLEIContext__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./VLEIContext */ \"(app-pages-browser)/./contexts/VLEIContext.tsx\");\n/* provided dependency */ var process = __webpack_require__(/*! process */ \"(app-pages-browser)/./node_modules/next/dist/build/polyfills/process.js\");\n/* __next_internal_client_entry_do_not_use__ usePasskeyWallet,PasskeyWalletProvider auto */ \nvar _s = $RefreshSig$(), _s1 = $RefreshSig$();\n\n\nconst PasskeyWalletContext = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.createContext)(undefined);\nfunction usePasskeyWallet() {\n    _s();\n    const context = (0,react__WEBPACK_IMPORTED_MODULE_1__.useContext)(PasskeyWalletContext);\n    if (context === undefined) {\n        throw new Error(\"usePasskeyWallet must be used within a PasskeyWalletProvider\");\n    }\n    return context;\n}\n_s(usePasskeyWallet, \"b9L3QQ+jgeyIrH0NfHrJ8nn7VMU=\");\nfunction PasskeyWalletProvider(param) {\n    let { children } = param;\n    _s1();\n    const { vlei, verifyCredentials } = (0,_VLEIContext__WEBPACK_IMPORTED_MODULE_2__.useVLEI)();\n    const [wallet, setWallet] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)({\n        isConnected: false,\n        address: null,\n        contractId: null,\n        role: null,\n        credentials: null,\n        error: null,\n        loading: false\n    });\n    const [passkeyService, setPasskeyService] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n    const connectWallet = async (role)=>{\n        try {\n            setWallet((prev)=>({\n                    ...prev,\n                    error: null,\n                    loading: true\n                }));\n            // Use mock implementation for now (Phase 2 will use real implementation when packages are stable)\n            const mockModule = await __webpack_require__.e(/*! import() */ \"_app-pages-browser_lib_mock-passkey-kit_ts\").then(__webpack_require__.bind(__webpack_require__, /*! @/lib/mock-passkey-kit */ \"(app-pages-browser)/./lib/mock-passkey-kit.ts\"));\n            const PasskeyService = mockModule.PasskeyKit;\n            const getDefaultStellarConfig = ()=>({\n                    rpcUrl: process.env.NEXT_PUBLIC_RPC_URL || \"https://soroban-testnet.stellar.org\",\n                    networkPassphrase: process.env.NEXT_PUBLIC_NETWORK_PASSPHRASE || \"Test SDF Network ; September 2015\",\n                    factoryContractId: process.env.NEXT_PUBLIC_FACTORY_CONTRACT_ID || \"CCWJFJ7YQHZ3QH2GQYQZQZQZQZQZQZQZQZQZQZQZQZQZQZQ\"\n                });\n            // Create PasskeyService instance\n            const config = getDefaultStellarConfig();\n            const service = new PasskeyService(config);\n            setPasskeyService(service);\n            // Connect to wallet\n            const contractId = await service.connectWallet({\n                name: role === \"buyer\" ? \"John Doe - TechCorp CFO\" : \"Jane Smith - SupplierCo Sales\",\n                description: \"Procurement wallet with vLEI credentials\"\n            });\n            const address = service.getAddress();\n            // Verify vLEI credentials\n            let credentials = null;\n            if (vlei.isInitialized) {\n                try {\n                    credentials = await verifyCredentials(role);\n                } catch (error) {\n                    console.warn(\"vLEI credential verification failed:\", error);\n                // Continue without credentials for now\n                }\n            }\n            setWallet({\n                isConnected: true,\n                address,\n                contractId,\n                role,\n                credentials,\n                error: null,\n                loading: false\n            });\n            // Store in localStorage for persistence\n            localStorage.setItem(\"passkeyWalletState\", JSON.stringify({\n                isConnected: true,\n                address,\n                contractId,\n                role,\n                credentials\n            }));\n            console.log(\"✅ \".concat(role, \" wallet connected successfully\"));\n        } catch (error) {\n            const errorMessage = error instanceof Error ? error.message : \"Failed to connect wallet\";\n            setWallet((prev)=>({\n                    ...prev,\n                    error: errorMessage,\n                    loading: false\n                }));\n            console.error(\"❌ Wallet connection failed:\", error);\n        }\n    };\n    const disconnectWallet = ()=>{\n        if (passkeyService) {\n            passkeyService.disconnect();\n        }\n        setWallet({\n            isConnected: false,\n            address: null,\n            contractId: null,\n            role: null,\n            credentials: null,\n            error: null,\n            loading: false\n        });\n        setPasskeyService(null);\n        localStorage.removeItem(\"passkeyWalletState\");\n        console.log(\"\\uD83D\\uDD0C Wallet disconnected\");\n    };\n    const switchRole = async (role)=>{\n        if (wallet.isConnected) {\n            await connectWallet(role);\n        }\n    };\n    const executeTransaction = async (params)=>{\n        if (!passkeyService || !wallet.isConnected) {\n            throw new Error(\"Wallet not connected\");\n        }\n        try {\n            setWallet((prev)=>({\n                    ...prev,\n                    loading: true,\n                    error: null\n                }));\n            const result = await passkeyService.executeTransaction(params);\n            setWallet((prev)=>({\n                    ...prev,\n                    loading: false\n                }));\n            return result;\n        } catch (error) {\n            const errorMessage = error instanceof Error ? error.message : \"Transaction failed\";\n            setWallet((prev)=>({\n                    ...prev,\n                    error: errorMessage,\n                    loading: false\n                }));\n            throw error;\n        }\n    };\n    const getAccountInfo = async ()=>{\n        if (!passkeyService || !wallet.isConnected) {\n            throw new Error(\"Wallet not connected\");\n        }\n        return await passkeyService.getAccountInfo();\n    };\n    // Restore wallet state on mount\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        const savedState = localStorage.getItem(\"passkeyWalletState\");\n        if (savedState) {\n            try {\n                const parsed = JSON.parse(savedState);\n                if (parsed.isConnected && parsed.role) {\n                    // Don't auto-connect, just restore the state\n                    setWallet((prev)=>({\n                            ...prev,\n                            ...parsed,\n                            loading: false,\n                            error: null\n                        }));\n                }\n            } catch (error) {\n                console.error(\"Failed to restore wallet state:\", error);\n                localStorage.removeItem(\"passkeyWalletState\");\n            }\n        }\n    }, []);\n    // Update credentials when vLEI is initialized and credentials are available\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        if (vlei.isInitialized && wallet.isConnected && wallet.role) {\n            // Check if credentials are available before trying to verify\n            const hasCredentials = wallet.role === \"buyer\" ? vlei.credentials.john && vlei.credentials.techcorp : vlei.credentials.jane && vlei.credentials.supplierco;\n            if (hasCredentials) {\n                verifyCredentials(wallet.role).then((credentials)=>{\n                    setWallet((prev)=>({\n                            ...prev,\n                            credentials\n                        }));\n                }).catch((error)=>{\n                    console.warn(\"Failed to update credentials:\", error);\n                });\n            } else {\n                // Use mock credentials if real ones aren't available yet\n                const mockCredentials = {\n                    valid: true,\n                    orgLEI: wallet.role === \"buyer\" ? \"506700GE1G29325QX363\" : \"549300XOCUZD4EMKGY96\",\n                    personName: wallet.role === \"buyer\" ? \"John Doe\" : \"Jane Smith\",\n                    role: wallet.role === \"buyer\" ? \"Procurement Manager\" : \"Contract Signer\",\n                    spendingLimit: wallet.role === \"buyer\" ? 100000 : 500000,\n                    maxContractValue: wallet.role === \"buyer\" ? 100000 : 500000,\n                    details: {\n                        orgName: wallet.role === \"buyer\" ? \"TechCorp Inc.\" : \"SupplierCo LLC\",\n                        lei: wallet.role === \"buyer\" ? \"506700GE1G29325QX363\" : \"549300XOCUZD4EMKGY96\",\n                        personName: wallet.role === \"buyer\" ? \"John Doe\" : \"Jane Smith\",\n                        role: wallet.role === \"buyer\" ? \"Procurement Manager\" : \"Contract Signer\",\n                        spendingLimit: wallet.role === \"buyer\" ? 100000 : 500000,\n                        maxContractValue: wallet.role === \"buyer\" ? 100000 : 500000\n                    }\n                };\n                setWallet((prev)=>({\n                        ...prev,\n                        credentials: mockCredentials\n                    }));\n            }\n        }\n    }, [\n        vlei.isInitialized,\n        wallet.isConnected,\n        wallet.role,\n        vlei.credentials\n    ]);\n    const value = {\n        wallet,\n        connectWallet,\n        disconnectWallet,\n        switchRole,\n        executeTransaction,\n        getAccountInfo\n    };\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(PasskeyWalletContext.Provider, {\n        value: value,\n        children: children\n    }, void 0, false, {\n        fileName: \"/Users/amanpal/Desktop/Stellar-Smart Contract-Wallets/contexts/PasskeyWalletContext.tsx\",\n        lineNumber: 245,\n        columnNumber: 5\n    }, this);\n}\n_s1(PasskeyWalletProvider, \"LgI1+g3DTq8nAWsUs9BBnVbs2c0=\", false, function() {\n    return [\n        _VLEIContext__WEBPACK_IMPORTED_MODULE_2__.useVLEI\n    ];\n});\n_c = PasskeyWalletProvider;\nvar _c;\n$RefreshReg$(_c, \"PasskeyWalletProvider\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2NvbnRleHRzL1Bhc3NrZXlXYWxsZXRDb250ZXh0LnRzeCIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7QUFFd0Y7QUFDakQ7QUFxQnZDLE1BQU1NLHFDQUF1Qkwsb0RBQWFBLENBQXVDTTtBQUUxRSxTQUFTQzs7SUFDZCxNQUFNQyxVQUFVUCxpREFBVUEsQ0FBQ0k7SUFDM0IsSUFBSUcsWUFBWUYsV0FBVztRQUN6QixNQUFNLElBQUlHLE1BQU07SUFDbEI7SUFDQSxPQUFPRDtBQUNUO0dBTmdCRDtBQVlULFNBQVNHLHNCQUFzQixLQUF3QztRQUF4QyxFQUFFQyxRQUFRLEVBQThCLEdBQXhDOztJQUNwQyxNQUFNLEVBQUVDLElBQUksRUFBRUMsaUJBQWlCLEVBQUUsR0FBR1QscURBQU9BO0lBQzNDLE1BQU0sQ0FBQ1UsUUFBUUMsVUFBVSxHQUFHYiwrQ0FBUUEsQ0FBcUI7UUFDdkRjLGFBQWE7UUFDYkMsU0FBUztRQUNUQyxZQUFZO1FBQ1pDLE1BQU07UUFDTkMsYUFBYTtRQUNiQyxPQUFPO1FBQ1BDLFNBQVM7SUFDWDtJQUVBLE1BQU0sQ0FBQ0MsZ0JBQWdCQyxrQkFBa0IsR0FBR3RCLCtDQUFRQSxDQUF3QjtJQUU1RSxNQUFNdUIsZ0JBQWdCLE9BQU9OO1FBQzNCLElBQUk7WUFDRkosVUFBVVcsQ0FBQUEsT0FBUztvQkFBRSxHQUFHQSxJQUFJO29CQUFFTCxPQUFPO29CQUFNQyxTQUFTO2dCQUFLO1lBRXpELGtHQUFrRztZQUNsRyxNQUFNSyxhQUFhLE1BQU0sc05BQU87WUFDaEMsTUFBTUMsaUJBQWlCRCxXQUFXRSxVQUFVO1lBQzVDLE1BQU1DLDBCQUEwQixJQUFPO29CQUNyQ0MsUUFBUUMsT0FBT0EsQ0FBQ0MsR0FBRyxDQUFDQyxtQkFBbUIsSUFBSTtvQkFDM0NDLG1CQUFtQkgsT0FBT0EsQ0FBQ0MsR0FBRyxDQUFDRyw4QkFBOEIsSUFBSTtvQkFDakVDLG1CQUFtQkwsT0FBT0EsQ0FBQ0MsR0FBRyxDQUFDSywrQkFB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QUFPSyxJQUFJLEtBQUssVUFBVSxhQUFhO29CQUNuREEsTUFBTUwsT0FBT0ssSUFBSSxLQUFLLFVBQVUsd0JBQXdCO29CQUN4RDBELGVBQWUvRCxPQUFPSyxJQUFJLEtBQUssVUFBVSxTQUFTO29CQUNsRDJELGtCQUFrQmhFLE9BQU9LLElBQUksS0FBSyxVQUFVLFNBQVM7b0JBQ3JENEQsU0FBUzt3QkFDUEMsU0FBU2xFLE9BQU9LLElBQUksS0FBSyxVQUFVLGtCQUFrQjt3QkFDckQ4RCxLQUFLbkUsT0FBT0ssSUFBSSxLQUFLLFVBQVUseUJBQXlCO3dCQUN4RHlELFlBQVk5RCxPQUFPSyxJQUFJLEtBQUssVUFBVSxhQUFhO3dCQUNuREEsTUFBTUwsT0FBT0ssSUFBSSxLQUFLLFVBQVUsd0JBQXdCO3dCQUN4RDBELGVBQWUvRCxPQUFPSyxJQUFJLEtBQUssVUFBVSxTQUFTO3dCQUNsRDJELGtCQUFrQmhFLE9BQU9LLElBQUksS0FBSyxVQUFVLFNBQVM7b0JBQ3ZEO2dCQUNGO2dCQUNBSixVQUFVVyxDQUFBQSxPQUFTO3dCQUFFLEdBQUdBLElBQUk7d0JBQUVOLGFBQWFxRDtvQkFBZ0I7WUFDN0Q7UUFDRjtJQUNGLEdBQUc7UUFBQzdELEtBQUtnQyxhQUFhO1FBQUU5QixPQUFPRSxXQUFXO1FBQUVGLE9BQU9LLElBQUk7UUFBRVAsS0FBS1EsV0FBVztLQUFDO0lBRTFFLE1BQU04RCxRQUFrQztRQUN0Q3BFO1FBQ0FXO1FBQ0E2QjtRQUNBRztRQUNBQztRQUNBRztJQUNGO0lBRUEscUJBQ0UsOERBQUN4RCxxQkFBcUI4RSxRQUFRO1FBQUNELE9BQU9BO2tCQUNuQ3ZFOzs7Ozs7QUFHUDtJQWxOZ0JEOztRQUNzQk4saURBQU9BOzs7S0FEN0JNIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL2NvbnRleHRzL1Bhc3NrZXlXYWxsZXRDb250ZXh0LnRzeD9mZjE3Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2UgY2xpZW50J1xuXG5pbXBvcnQgUmVhY3QsIHsgY3JlYXRlQ29udGV4dCwgdXNlQ29udGV4dCwgdXNlU3RhdGUsIHVzZUVmZmVjdCwgUmVhY3ROb2RlIH0gZnJvbSAncmVhY3QnXG5pbXBvcnQgeyB1c2VWTEVJIH0gZnJvbSAnLi9WTEVJQ29udGV4dCdcblxuZXhwb3J0IGludGVyZmFjZSBQYXNza2V5V2FsbGV0U3RhdGUge1xuICBpc0Nvbm5lY3RlZDogYm9vbGVhblxuICBhZGRyZXNzOiBzdHJpbmcgfCBudWxsXG4gIGNvbnRyYWN0SWQ6IHN0cmluZyB8IG51bGxcbiAgcm9sZTogJ2J1eWVyJyB8ICdzZWxsZXInIHwgbnVsbFxuICBjcmVkZW50aWFsczogYW55IHwgbnVsbFxuICBlcnJvcjogc3RyaW5nIHwgbnVsbFxuICBsb2FkaW5nOiBib29sZWFuXG59XG5cbmludGVyZmFjZSBQYXNza2V5V2FsbGV0Q29udGV4dFR5cGUge1xuICB3YWxsZXQ6IFBhc3NrZXlXYWxsZXRTdGF0ZVxuICBjb25uZWN0V2FsbGV0OiAocm9sZTogJ2J1eWVyJyB8ICdzZWxsZXInKSA9PiBQcm9taXNlPHZvaWQ+XG4gIGRpc2Nvbm5lY3RXYWxsZXQ6ICgpID0+IHZvaWRcbiAgc3dpdGNoUm9sZTogKHJvbGU6ICdidXllcicgfCAnc2VsbGVyJykgPT4gdm9pZFxuICBleGVjdXRlVHJhbnNhY3Rpb246IChwYXJhbXM6IGFueSkgPT4gUHJvbWlzZTxhbnk+XG4gIGdldEFjY291bnRJbmZvOiAoKSA9PiBQcm9taXNlPGFueT5cbn1cblxuY29uc3QgUGFzc2tleVdhbGxldENvbnRleHQgPSBjcmVhdGVDb250ZXh0PFBhc3NrZXlXYWxsZXRDb250ZXh0VHlwZSB8IHVuZGVmaW5lZD4odW5kZWZpbmVkKVxuXG5leHBvcnQgZnVuY3Rpb24gdXNlUGFzc2tleVdhbGxldCgpIHtcbiAgY29uc3QgY29udGV4dCA9IHVzZUNvbnRleHQoUGFzc2tleVdhbGxldENvbnRleHQpXG4gIGlmIChjb250ZXh0ID09PSB1bmRlZmluZWQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3VzZVBhc3NrZXlXYWxsZXQgbXVzdCBiZSB1c2VkIHdpdGhpbiBhIFBhc3NrZXlXYWxsZXRQcm92aWRlcicpXG4gIH1cbiAgcmV0dXJuIGNvbnRleHRcbn1cblxuaW50ZXJmYWNlIFBhc3NrZXlXYWxsZXRQcm92aWRlclByb3BzIHtcbiAgY2hpbGRyZW46IFJlYWN0Tm9kZVxufVxuXG5leHBvcnQgZnVuY3Rpb24gUGFzc2tleVdhbGxldFByb3ZpZGVyKHsgY2hpbGRyZW4gfTogUGFzc2tleVdhbGxldFByb3ZpZGVyUHJvcHMpIHtcbiAgY29uc3QgeyB2bGVpLCB2ZXJpZnlDcmVkZW50aWFscyB9ID0gdXNlVkxFSSgpXG4gIGNvbnN0IFt3YWxsZXQsIHNldFdhbGxldF0gPSB1c2VTdGF0ZTxQYXNza2V5V2FsbGV0U3RhdGU+KHtcbiAgICBpc0Nvbm5lY3RlZDogZmFsc2UsXG4gICAgYWRkcmVzczogbnVsbCxcbiAgICBjb250cmFjdElkOiBudWxsLFxuICAgIHJvbGU6IG51bGwsXG4gICAgY3JlZGVudGlhbHM6IG51bGwsXG4gICAgZXJyb3I6IG51bGwsXG4gICAgbG9hZGluZzogZmFsc2UsXG4gIH0pXG5cbiAgY29uc3QgW3Bhc3NrZXlTZXJ2aWNlLCBzZXRQYXNza2V5U2VydmljZV0gPSB1c2VTdGF0ZTxQYXNza2V5U2VydmljZSB8IG51bGw+KG51bGwpXG5cbiAgY29uc3QgY29ubmVjdFdhbGxldCA9IGFzeW5jIChyb2xlOiAnYnV5ZXInIHwgJ3NlbGxlcicpID0+IHtcbiAgICB0cnkge1xuICAgICAgc2V0V2FsbGV0KHByZXYgPT4gKHsgLi4ucHJldiwgZXJyb3I6IG51bGwsIGxvYWRpbmc6IHRydWUgfSkpXG5cbiAgICAgIC8vIFVzZSBtb2NrIGltcGxlbWVudGF0aW9uIGZvciBub3cgKFBoYXNlIDIgd2lsbCB1c2UgcmVhbCBpbXBsZW1lbnRhdGlvbiB3aGVuIHBhY2thZ2VzIGFyZSBzdGFibGUpXG4gICAgICBjb25zdCBtb2NrTW9kdWxlID0gYXdhaXQgaW1wb3J0KCdAL2xpYi9tb2NrLXBhc3NrZXkta2l0JylcbiAgICAgIGNvbnN0IFBhc3NrZXlTZXJ2aWNlID0gbW9ja01vZHVsZS5QYXNza2V5S2l0XG4gICAgICBjb25zdCBnZXREZWZhdWx0U3RlbGxhckNvbmZpZyA9ICgpID0+ICh7XG4gICAgICAgIHJwY1VybDogcHJvY2Vzcy5lbnYuTkVYVF9QVUJMSUNfUlBDX1VSTCB8fCAnaHR0cHM6Ly9zb3JvYmFuLXRlc3RuZXQuc3RlbGxhci5vcmcnLFxuICAgICAgICBuZXR3b3JrUGFzc3BocmFzZTogcHJvY2Vzcy5lbnYuTkVYVF9QVUJMSUNfTkVUV09SS19QQVNTUEhSQVNFIHx8ICdUZXN0IFNERiBOZXR3b3JrIDsgU2VwdGVtYmVyIDIwMTUnLFxuICAgICAgICBmYWN0b3J5Q29udHJhY3RJZDogcHJvY2Vzcy5lbnYuTkVYVF9QVUJMSUNfRkFDVE9SWV9DT05UUkFDVF9JRCB8fCAnQ0NXSkZKN1lRSFozUUgyR1FZUVpRWlFaUVpRWlFaUVpRWlFaUVpRWlFaUVpRWlEnXG4gICAgICB9KVxuXG4gICAgICAvLyBDcmVhdGUgUGFzc2tleVNlcnZpY2UgaW5zdGFuY2VcbiAgICAgIGNvbnN0IGNvbmZpZyA9IGdldERlZmF1bHRTdGVsbGFyQ29uZmlnKClcbiAgICAgIGNvbnN0IHNlcnZpY2UgPSBuZXcgUGFzc2tleVNlcnZpY2UoY29uZmlnKVxuICAgICAgc2V0UGFzc2tleVNlcnZpY2Uoc2VydmljZSlcblxuICAgICAgLy8gQ29ubmVjdCB0byB3YWxsZXRcbiAgICAgIGNvbnN0IGNvbnRyYWN0SWQgPSBhd2FpdCBzZXJ2aWNlLmNvbm5lY3RXYWxsZXQoe1xuICAgICAgICBuYW1lOiByb2xlID09PSAnYnV5ZXInID8gJ0pvaG4gRG9lIC0gVGVjaENvcnAgQ0ZPJyA6ICdKYW5lIFNtaXRoIC0gU3VwcGxpZXJDbyBTYWxlcycsXG4gICAgICAgIGRlc2NyaXB0aW9uOiAnUHJvY3VyZW1lbnQgd2FsbGV0IHdpdGggdkxFSSBjcmVkZW50aWFscycsXG4gICAgICB9KVxuXG4gICAgICBjb25zdCBhZGRyZXNzID0gc2VydmljZS5nZXRBZGRyZXNzKClcblxuICAgICAgLy8gVmVyaWZ5IHZMRUkgY3JlZGVudGlhbHNcbiAgICAgIGxldCBjcmVkZW50aWFscyA9IG51bGxcbiAgICAgIGlmICh2bGVpLmlzSW5pdGlhbGl6ZWQpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBjcmVkZW50aWFscyA9IGF3YWl0IHZlcmlmeUNyZWRlbnRpYWxzKHJvbGUpXG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgY29uc29sZS53YXJuKCd2TEVJIGNyZWRlbnRpYWwgdmVyaWZpY2F0aW9uIGZhaWxlZDonLCBlcnJvcilcbiAgICAgICAgICAvLyBDb250aW51ZSB3aXRob3V0IGNyZWRlbnRpYWxzIGZvciBub3dcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBzZXRXYWxsZXQoe1xuICAgICAgICBpc0Nvbm5lY3RlZDogdHJ1ZSxcbiAgICAgICAgYWRkcmVzcyxcbiAgICAgICAgY29udHJhY3RJZCxcbiAgICAgICAgcm9sZSxcbiAgICAgICAgY3JlZGVudGlhbHMsXG4gICAgICAgIGVycm9yOiBudWxsLFxuICAgICAgICBsb2FkaW5nOiBmYWxzZSxcbiAgICAgIH0pXG5cbiAgICAgIC8vIFN0b3JlIGluIGxvY2FsU3RvcmFnZSBmb3IgcGVyc2lzdGVuY2VcbiAgICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKCdwYXNza2V5V2FsbGV0U3RhdGUnLCBKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgIGlzQ29ubmVjdGVkOiB0cnVlLFxuICAgICAgICBhZGRyZXNzLFxuICAgICAgICBjb250cmFjdElkLFxuICAgICAgICByb2xlLFxuICAgICAgICBjcmVkZW50aWFscyxcbiAgICAgIH0pKVxuXG4gICAgICBjb25zb2xlLmxvZyhg4pyFICR7cm9sZX0gd2FsbGV0IGNvbm5lY3RlZCBzdWNjZXNzZnVsbHlgKVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zdCBlcnJvck1lc3NhZ2UgPSBlcnJvciBpbnN0YW5jZW9mIEVycm9yID8gZXJyb3IubWVzc2FnZSA6ICdGYWlsZWQgdG8gY29ubmVjdCB3YWxsZXQnXG4gICAgICBzZXRXYWxsZXQocHJldiA9PiAoe1xuICAgICAgICAuLi5wcmV2LFxuICAgICAgICBlcnJvcjogZXJyb3JNZXNzYWdlLFxuICAgICAgICBsb2FkaW5nOiBmYWxzZSxcbiAgICAgIH0pKVxuICAgICAgY29uc29sZS5lcnJvcign4p2MIFdhbGxldCBjb25uZWN0aW9uIGZhaWxlZDonLCBlcnJvcilcbiAgICB9XG4gIH1cblxuICBjb25zdCBkaXNjb25uZWN0V2FsbGV0ID0gKCkgPT4ge1xuICAgIGlmIChwYXNza2V5U2VydmljZSkge1xuICAgICAgcGFzc2tleVNlcnZpY2UuZGlzY29ubmVjdCgpXG4gICAgfVxuICAgIFxuICAgIHNldFdhbGxldCh7XG4gICAgICBpc0Nvbm5lY3RlZDogZmFsc2UsXG4gICAgICBhZGRyZXNzOiBudWxsLFxuICAgICAgY29udHJhY3RJZDogbnVsbCxcbiAgICAgIHJvbGU6IG51bGwsXG4gICAgICBjcmVkZW50aWFsczogbnVsbCxcbiAgICAgIGVycm9yOiBudWxsLFxuICAgICAgbG9hZGluZzogZmFsc2UsXG4gICAgfSlcbiAgICBcbiAgICBzZXRQYXNza2V5U2VydmljZShudWxsKVxuICAgIGxvY2FsU3RvcmFnZS5yZW1vdmVJdGVtKCdwYXNza2V5V2FsbGV0U3RhdGUnKVxuICAgIGNvbnNvbGUubG9nKCfwn5SMIFdhbGxldCBkaXNjb25uZWN0ZWQnKVxuICB9XG5cbiAgY29uc3Qgc3dpdGNoUm9sZSA9IGFzeW5jIChyb2xlOiAnYnV5ZXInIHwgJ3NlbGxlcicpID0+IHtcbiAgICBpZiAod2FsbGV0LmlzQ29ubmVjdGVkKSB7XG4gICAgICBhd2FpdCBjb25uZWN0V2FsbGV0KHJvbGUpXG4gICAgfVxuICB9XG5cbiAgY29uc3QgZXhlY3V0ZVRyYW5zYWN0aW9uID0gYXN5bmMgKHBhcmFtczogYW55KTogUHJvbWlzZTxhbnk+ID0+IHtcbiAgICBpZiAoIXBhc3NrZXlTZXJ2aWNlIHx8ICF3YWxsZXQuaXNDb25uZWN0ZWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignV2FsbGV0IG5vdCBjb25uZWN0ZWQnKVxuICAgIH1cblxuICAgIHRyeSB7XG4gICAgICBzZXRXYWxsZXQocHJldiA9PiAoeyAuLi5wcmV2LCBsb2FkaW5nOiB0cnVlLCBlcnJvcjogbnVsbCB9KSlcbiAgICAgIFxuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgcGFzc2tleVNlcnZpY2UuZXhlY3V0ZVRyYW5zYWN0aW9uKHBhcmFtcylcbiAgICAgIFxuICAgICAgc2V0V2FsbGV0KHByZXYgPT4gKHsgLi4ucHJldiwgbG9hZGluZzogZmFsc2UgfSkpXG4gICAgICByZXR1cm4gcmVzdWx0XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnN0IGVycm9yTWVzc2FnZSA9IGVycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvci5tZXNzYWdlIDogJ1RyYW5zYWN0aW9uIGZhaWxlZCdcbiAgICAgIHNldFdhbGxldChwcmV2ID0+ICh7IC4uLnByZXYsIGVycm9yOiBlcnJvck1lc3NhZ2UsIGxvYWRpbmc6IGZhbHNlIH0pKVxuICAgICAgdGhyb3cgZXJyb3JcbiAgICB9XG4gIH1cblxuICBjb25zdCBnZXRBY2NvdW50SW5mbyA9IGFzeW5jICgpOiBQcm9taXNlPGFueT4gPT4ge1xuICAgIGlmICghcGFzc2tleVNlcnZpY2UgfHwgIXdhbGxldC5pc0Nvbm5lY3RlZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdXYWxsZXQgbm90IGNvbm5lY3RlZCcpXG4gICAgfVxuXG4gICAgcmV0dXJuIGF3YWl0IHBhc3NrZXlTZXJ2aWNlLmdldEFjY291bnRJbmZvKClcbiAgfVxuXG4gIC8vIFJlc3RvcmUgd2FsbGV0IHN0YXRlIG9uIG1vdW50XG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgY29uc3Qgc2F2ZWRTdGF0ZSA9IGxvY2FsU3RvcmFnZS5nZXRJdGVtKCdwYXNza2V5V2FsbGV0U3RhdGUnKVxuICAgIGlmIChzYXZlZFN0YXRlKSB7XG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCBwYXJzZWQgPSBKU09OLnBhcnNlKHNhdmVkU3RhdGUpXG4gICAgICAgIGlmIChwYXJzZWQuaXNDb25uZWN0ZWQgJiYgcGFyc2VkLnJvbGUpIHtcbiAgICAgICAgICAvLyBEb24ndCBhdXRvLWNvbm5lY3QsIGp1c3QgcmVzdG9yZSB0aGUgc3RhdGVcbiAgICAgICAgICBzZXRXYWxsZXQocHJldiA9PiAoe1xuICAgICAgICAgICAgLi4ucHJldixcbiAgICAgICAgICAgIC4uLnBhcnNlZCxcbiAgICAgICAgICAgIGxvYWRpbmc6IGZhbHNlLFxuICAgICAgICAgICAgZXJyb3I6IG51bGwsXG4gICAgICAgICAgfSkpXG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ0ZhaWxlZCB0byByZXN0b3JlIHdhbGxldCBzdGF0ZTonLCBlcnJvcilcbiAgICAgICAgbG9jYWxTdG9yYWdlLnJlbW92ZUl0ZW0oJ3Bhc3NrZXlXYWxsZXRTdGF0ZScpXG4gICAgICB9XG4gICAgfVxuICB9LCBbXSlcblxuICAvLyBVcGRhdGUgY3JlZGVudGlhbHMgd2hlbiB2TEVJIGlzIGluaXRpYWxpemVkIGFuZCBjcmVkZW50aWFscyBhcmUgYXZhaWxhYmxlXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKHZsZWkuaXNJbml0aWFsaXplZCAmJiB3YWxsZXQuaXNDb25uZWN0ZWQgJiYgd2FsbGV0LnJvbGUpIHtcbiAgICAgIC8vIENoZWNrIGlmIGNyZWRlbnRpYWxzIGFyZSBhdmFpbGFibGUgYmVmb3JlIHRyeWluZyB0byB2ZXJpZnlcbiAgICAgIGNvbnN0IGhhc0NyZWRlbnRpYWxzID0gd2FsbGV0LnJvbGUgPT09ICdidXllcicgXG4gICAgICAgID8gKHZsZWkuY3JlZGVudGlhbHMuam9obiAmJiB2bGVpLmNyZWRlbnRpYWxzLnRlY2hjb3JwKVxuICAgICAgICA6ICh2bGVpLmNyZWRlbnRpYWxzLmphbmUgJiYgdmxlaS5jcmVkZW50aWFscy5zdXBwbGllcmNvKVxuICAgICAgXG4gICAgICBpZiAoaGFzQ3JlZGVudGlhbHMpIHtcbiAgICAgICAgdmVyaWZ5Q3JlZGVudGlhbHMod2FsbGV0LnJvbGUpXG4gICAgICAgICAgLnRoZW4oY3JlZGVudGlhbHMgPT4ge1xuICAgICAgICAgICAgc2V0V2FsbGV0KHByZXYgPT4gKHsgLi4ucHJldiwgY3JlZGVudGlhbHMgfSkpXG4gICAgICAgICAgfSlcbiAgICAgICAgICAuY2F0Y2goZXJyb3IgPT4ge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKCdGYWlsZWQgdG8gdXBkYXRlIGNyZWRlbnRpYWxzOicsIGVycm9yKVxuICAgICAgICAgIH0pXG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBVc2UgbW9jayBjcmVkZW50aWFscyBpZiByZWFsIG9uZXMgYXJlbid0IGF2YWlsYWJsZSB5ZXRcbiAgICAgICAgY29uc3QgbW9ja0NyZWRlbnRpYWxzID0ge1xuICAgICAgICAgIHZhbGlkOiB0cnVlLFxuICAgICAgICAgIG9yZ0xFSTogd2FsbGV0LnJvbGUgPT09ICdidXllcicgPyAnNTA2NzAwR0UxRzI5MzI1UVgzNjMnIDogJzU0OTMwMFhPQ1VaRDRFTUtHWTk2JyxcbiAgICAgICAgICBwZXJzb25OYW1lOiB3YWxsZXQucm9sZSA9PT0gJ2J1eWVyJyA/ICdKb2huIERvZScgOiAnSmFuZSBTbWl0aCcsXG4gICAgICAgICAgcm9sZTogd2FsbGV0LnJvbGUgPT09ICdidXllcicgPyAnUHJvY3VyZW1lbnQgTWFuYWdlcicgOiAnQ29udHJhY3QgU2lnbmVyJyxcbiAgICAgICAgICBzcGVuZGluZ0xpbWl0OiB3YWxsZXQucm9sZSA9PT0gJ2J1eWVyJyA/IDEwMDAwMCA6IDUwMDAwMCxcbiAgICAgICAgICBtYXhDb250cmFjdFZhbHVlOiB3YWxsZXQucm9sZSA9PT0gJ2J1eWVyJyA/IDEwMDAwMCA6IDUwMDAwMCxcbiAgICAgICAgICBkZXRhaWxzOiB7XG4gICAgICAgICAgICBvcmdOYW1lOiB3YWxsZXQucm9sZSA9PT0gJ2J1eWVyJyA/ICdUZWNoQ29ycCBJbmMuJyA6ICdTdXBwbGllckNvIExMQycsXG4gICAgICAgICAgICBsZWk6IHdhbGxldC5yb2xlID09PSAnYnV5ZXInID8gJzUwNjcwMEdFMUcyOTMyNVFYMzYzJyA6ICc1NDkzMDBYT0NVWkQ0RU1LR1k5NicsXG4gICAgICAgICAgICBwZXJzb25OYW1lOiB3YWxsZXQucm9sZSA9PT0gJ2J1eWVyJyA/ICdKb2huIERvZScgOiAnSmFuZSBTbWl0aCcsXG4gICAgICAgICAgICByb2xlOiB3YWxsZXQucm9sZSA9PT0gJ2J1eWVyJyA/ICdQcm9jdXJlbWVudCBNYW5hZ2VyJyA6ICdDb250cmFjdCBTaWduZXInLFxuICAgICAgICAgICAgc3BlbmRpbmdMaW1pdDogd2FsbGV0LnJvbGUgPT09ICdidXllcicgPyAxMDAwMDAgOiA1MDAwMDAsXG4gICAgICAgICAgICBtYXhDb250cmFjdFZhbHVlOiB3YWxsZXQucm9sZSA9PT0gJ2J1eWVyJyA/IDEwMDAwMCA6IDUwMDAwMCxcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgc2V0V2FsbGV0KHByZXYgPT4gKHsgLi4ucHJldiwgY3JlZGVudGlhbHM6IG1vY2tDcmVkZW50aWFscyB9KSlcbiAgICAgIH1cbiAgICB9XG4gIH0sIFt2bGVpLmlzSW5pdGlhbGl6ZWQsIHdhbGxldC5pc0Nvbm5lY3RlZCwgd2FsbGV0LnJvbGUsIHZsZWkuY3JlZGVudGlhbHNdKVxuXG4gIGNvbnN0IHZhbHVlOiBQYXNza2V5V2FsbGV0Q29udGV4dFR5cGUgPSB7XG4gICAgd2FsbGV0LFxuICAgIGNvbm5lY3RXYWxsZXQsXG4gICAgZGlzY29ubmVjdFdhbGxldCxcbiAgICBzd2l0Y2hSb2xlLFxuICAgIGV4ZWN1dGVUcmFuc2FjdGlvbixcbiAgICBnZXRBY2NvdW50SW5mbyxcbiAgfVxuXG4gIHJldHVybiAoXG4gICAgPFBhc3NrZXlXYWxsZXRDb250ZXh0LlByb3ZpZGVyIHZhbHVlPXt2YWx1ZX0+XG4gICAgICB7Y2hpbGRyZW59XG4gICAgPC9QYXNza2V5V2FsbGV0Q29udGV4dC5Qcm92aWRlcj5cbiAgKVxufVxuIl0sIm5hbWVzIjpbIlJlYWN0IiwiY3JlYXRlQ29udGV4dCIsInVzZUNvbnRleHQiLCJ1c2VTdGF0ZSIsInVzZUVmZmVjdCIsInVzZVZMRUkiLCJQYXNza2V5V2FsbGV0Q29udGV4dCIsInVuZGVmaW5lZCIsInVzZVBhc3NrZXlXYWxsZXQiLCJjb250ZXh0IiwiRXJyb3IiLCJQYXNza2V5V2FsbGV0UHJvdmlkZXIiLCJjaGlsZHJlbiIsInZsZWkiLCJ2ZXJpZnlDcmVkZW50aWFscyIsIndhbGxldCIsInNldFdhbGxldCIsImlzQ29ubmVjdGVkIiwiYWRkcmVzcyIsImNvbnRyYWN0SWQiLCJyb2xlIiwiY3JlZGVudGlhbHMiLCJlcnJvciIsImxvYWRpbmciLCJwYXNza2V5U2VydmljZSIsInNldFBhc3NrZXlTZXJ2aWNlIiwiY29ubmVjdFdhbGxldCIsInByZXYiLCJtb2NrTW9kdWxlIiwiUGFzc2tleVNlcnZpY2UiLCJQYXNza2V5S2l0IiwiZ2V0RGVmYXVsdFN0ZWxsYXJDb25maWciLCJycGNVcmwiLCJwcm9jZXNzIiwiZW52IiwiTkVYVF9QVUJMSUNfUlBDX1VSTCIsIm5ldHdvcmtQYXNzcGhyYXNlIiwiTkVYVF9QVUJMSUNfTkVUV09SS19QQVNTUEhSQVNFIiwiZmFjdG9yeUNvbnRyYWN0SWQiLCJORVhUX1BVQkxJQ19GQUNUT1JZX0NPTlRSQUNUX0lEIiwiY29uZmlnIiwic2VydmljZSIsIm5hbWUiLCJkZXNjcmlwdGlvbiIsImdldEFkZHJlc3MiLCJpc0luaXRpYWxpemVkIiwiY29uc29sZSIsIndhcm4iLCJsb2NhbFN0b3JhZ2UiLCJzZXRJdGVtIiwiSlNPTiIsInN0cmluZ2lmeSIsImxvZyIsImVycm9yTWVzc2FnZSIsIm1lc3NhZ2UiLCJkaXNjb25uZWN0V2FsbGV0IiwiZGlzY29ubmVjdCIsInJlbW92ZUl0ZW0iLCJzd2l0Y2hSb2xlIiwiZXhlY3V0ZVRyYW5zYWN0aW9uIiwicGFyYW1zIiwicmVzdWx0IiwiZ2V0QWNjb3VudEluZm8iLCJzYXZlZFN0YXRlIiwiZ2V0SXRlbSIsInBhcnNlZCIsInBhcnNlIiwiaGFzQ3JlZGVudGlhbHMiLCJqb2huIiwidGVjaGNvcnAiLCJqYW5lIiwic3VwcGxpZXJjbyIsInRoZW4iLCJjYXRjaCIsIm1vY2tDcmVkZW50aWFscyIsInZhbGlkIiwib3JnTEVJIiwicGVyc29uTmFtZSIsInNwZW5kaW5nTGltaXQiLCJtYXhDb250cmFjdFZhbHVlIiwiZGV0YWlscyIsIm9yZ05hbWUiLCJsZWkiLCJ2YWx1ZSIsIlByb3ZpZGVyIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./contexts/PasskeyWalletContext.tsx\n"));

/***/ })

});