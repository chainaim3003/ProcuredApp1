"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./contexts/PasskeyWalletContext.tsx":
/*!*******************************************!*\
  !*** ./contexts/PasskeyWalletContext.tsx ***!
  \*******************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   PasskeyWalletProvider: function() { return /* binding */ PasskeyWalletProvider; },\n/* harmony export */   usePasskeyWallet: function() { return /* binding */ usePasskeyWallet; }\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _VLEIContext__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./VLEIContext */ \"(app-pages-browser)/./contexts/VLEIContext.tsx\");\n/* harmony import */ var _lib_passkey_auth__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @/lib/passkey-auth */ \"(app-pages-browser)/./lib/passkey-auth.ts\");\n/* __next_internal_client_entry_do_not_use__ usePasskeyWallet,PasskeyWalletProvider auto */ \nvar _s = $RefreshSig$(), _s1 = $RefreshSig$();\n\n\n\nconst PasskeyWalletContext = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.createContext)(undefined);\nfunction usePasskeyWallet() {\n    _s();\n    const context = (0,react__WEBPACK_IMPORTED_MODULE_1__.useContext)(PasskeyWalletContext);\n    if (context === undefined) {\n        throw new Error(\"usePasskeyWallet must be used within a PasskeyWalletProvider\");\n    }\n    return context;\n}\n_s(usePasskeyWallet, \"b9L3QQ+jgeyIrH0NfHrJ8nn7VMU=\");\nfunction PasskeyWalletProvider(param) {\n    let { children } = param;\n    _s1();\n    const { vlei, verifyCredentials } = (0,_VLEIContext__WEBPACK_IMPORTED_MODULE_2__.useVLEI)();\n    const [wallet, setWallet] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)({\n        isConnected: false,\n        address: null,\n        contractId: null,\n        role: null,\n        credentials: null,\n        error: null,\n        loading: false\n    });\n    const [passkeyService, setPasskeyService] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n    const connectWallet = async (role)=>{\n        try {\n            setWallet((prev)=>({\n                    ...prev,\n                    error: null,\n                    loading: true\n                }));\n            console.log(\"\\uD83D\\uDD10 Starting biometric authentication for \".concat(role, \"...\"));\n            // Create PasskeyAuthenticator instance\n            const config = (0,_lib_passkey_auth__WEBPACK_IMPORTED_MODULE_3__.getDefaultPasskeyConfig)();\n            const authenticator = (0,_lib_passkey_auth__WEBPACK_IMPORTED_MODULE_3__.createPasskeyAuthenticator)(config);\n            // Step 1: Authenticate with Passkey (biometric) - following the flow diagram\n            const userName = role === \"buyer\" ? \"John Doe - TechCorp CFO\" : \"Jane Smith - SupplierCo Sales\";\n            // Create or connect to smart wallet with biometric authentication\n            const walletInfo = await authenticator.createOrConnectWallet(userName, role);\n            // Store authenticator for future use\n            setPasskeyService(authenticator);\n            const address = walletInfo.address;\n            const contractId = walletInfo.contractId;\n            // Verify vLEI credentials\n            let credentials = null;\n            if (vlei.isInitialized) {\n                try {\n                    credentials = await verifyCredentials(role);\n                } catch (error) {\n                    console.warn(\"vLEI credential verification failed:\", error);\n                // Continue without credentials for now\n                }\n            }\n            setWallet({\n                isConnected: true,\n                address,\n                contractId,\n                role,\n                credentials,\n                error: null,\n                loading: false\n            });\n            // Store in localStorage for persistence\n            localStorage.setItem(\"passkeyWalletState\", JSON.stringify({\n                isConnected: true,\n                address,\n                contractId,\n                role,\n                credentials\n            }));\n            console.log(\"✅ \".concat(role, \" wallet connected successfully\"));\n        } catch (error) {\n            const errorMessage = error instanceof Error ? error.message : \"Failed to connect wallet\";\n            setWallet((prev)=>({\n                    ...prev,\n                    error: errorMessage,\n                    loading: false\n                }));\n            console.error(\"❌ Wallet connection failed:\", error);\n        }\n    };\n    const disconnectWallet = ()=>{\n        try {\n            if (passkeyService && typeof passkeyService.disconnect === \"function\") {\n                passkeyService.disconnect();\n            }\n        } catch (error) {\n            console.warn(\"Error during wallet disconnect:\", error);\n        }\n        setWallet({\n            isConnected: false,\n            address: null,\n            contractId: null,\n            role: null,\n            credentials: null,\n            error: null,\n            loading: false\n        });\n        setPasskeyService(null);\n        localStorage.removeItem(\"passkeyWalletState\");\n        console.log(\"\\uD83D\\uDD0C Wallet disconnected\");\n    };\n    const switchRole = async (role)=>{\n        if (wallet.isConnected) {\n            await connectWallet(role);\n        }\n    };\n    const executeTransaction = async (params)=>{\n        if (!passkeyService || !wallet.isConnected) {\n            throw new Error(\"Wallet not connected\");\n        }\n        try {\n            setWallet((prev)=>({\n                    ...prev,\n                    loading: true,\n                    error: null\n                }));\n            const result = await passkeyService.executeTransaction(params);\n            setWallet((prev)=>({\n                    ...prev,\n                    loading: false\n                }));\n            return result;\n        } catch (error) {\n            const errorMessage = error instanceof Error ? error.message : \"Transaction failed\";\n            setWallet((prev)=>({\n                    ...prev,\n                    error: errorMessage,\n                    loading: false\n                }));\n            throw error;\n        }\n    };\n    const getAccountInfo = async ()=>{\n        if (!passkeyService || !wallet.isConnected) {\n            throw new Error(\"Wallet not connected\");\n        }\n        return await passkeyService.getAccountInfo();\n    };\n    // Restore wallet state on mount\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        const savedState = localStorage.getItem(\"passkeyWalletState\");\n        if (savedState) {\n            try {\n                const parsed = JSON.parse(savedState);\n                if (parsed.isConnected && parsed.role) {\n                    // Don't auto-connect, just restore the state\n                    setWallet((prev)=>({\n                            ...prev,\n                            ...parsed,\n                            loading: false,\n                            error: null\n                        }));\n                }\n            } catch (error) {\n                console.error(\"Failed to restore wallet state:\", error);\n                localStorage.removeItem(\"passkeyWalletState\");\n            }\n        }\n    }, []);\n    // Update credentials when vLEI is initialized and credentials are available\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        if (vlei.isInitialized && wallet.isConnected && wallet.role) {\n            // Check if credentials are available before trying to verify\n            const hasCredentials = wallet.role === \"buyer\" ? vlei.credentials.john && vlei.credentials.techcorp : vlei.credentials.jane && vlei.credentials.supplierco;\n            if (hasCredentials) {\n                verifyCredentials(wallet.role).then((credentials)=>{\n                    setWallet((prev)=>({\n                            ...prev,\n                            credentials\n                        }));\n                }).catch((error)=>{\n                    console.warn(\"Failed to update credentials:\", error);\n                });\n            } else {\n                // Use mock credentials if real ones aren't available yet\n                const mockCredentials = {\n                    valid: true,\n                    orgLEI: wallet.role === \"buyer\" ? \"506700GE1G29325QX363\" : \"549300XOCUZD4EMKGY96\",\n                    personName: wallet.role === \"buyer\" ? \"John Doe\" : \"Jane Smith\",\n                    role: wallet.role === \"buyer\" ? \"Procurement Manager\" : \"Contract Signer\",\n                    spendingLimit: wallet.role === \"buyer\" ? 100000 : 500000,\n                    maxContractValue: wallet.role === \"buyer\" ? 100000 : 500000,\n                    details: {\n                        orgName: wallet.role === \"buyer\" ? \"TechCorp Inc.\" : \"SupplierCo LLC\",\n                        lei: wallet.role === \"buyer\" ? \"506700GE1G29325QX363\" : \"549300XOCUZD4EMKGY96\",\n                        personName: wallet.role === \"buyer\" ? \"John Doe\" : \"Jane Smith\",\n                        role: wallet.role === \"buyer\" ? \"Procurement Manager\" : \"Contract Signer\",\n                        spendingLimit: wallet.role === \"buyer\" ? 100000 : 500000,\n                        maxContractValue: wallet.role === \"buyer\" ? 100000 : 500000\n                    }\n                };\n                setWallet((prev)=>({\n                        ...prev,\n                        credentials: mockCredentials\n                    }));\n            }\n        }\n    }, [\n        vlei.isInitialized,\n        wallet.isConnected,\n        wallet.role,\n        vlei.credentials\n    ]);\n    const value = {\n        wallet,\n        connectWallet,\n        disconnectWallet,\n        switchRole,\n        executeTransaction,\n        getAccountInfo\n    };\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(PasskeyWalletContext.Provider, {\n        value: value,\n        children: children\n    }, void 0, false, {\n        fileName: \"/Users/amanpal/Desktop/Stellar-Smart Contract-Wallets/contexts/PasskeyWalletContext.tsx\",\n        lineNumber: 246,\n        columnNumber: 5\n    }, this);\n}\n_s1(PasskeyWalletProvider, \"LgI1+g3DTq8nAWsUs9BBnVbs2c0=\", false, function() {\n    return [\n        _VLEIContext__WEBPACK_IMPORTED_MODULE_2__.useVLEI\n    ];\n});\n_c = PasskeyWalletProvider;\nvar _c;\n$RefreshReg$(_c, \"PasskeyWalletProvider\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2NvbnRleHRzL1Bhc3NrZXlXYWxsZXRDb250ZXh0LnRzeCIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7QUFFd0Y7QUFDakQ7QUFDdUU7QUFxQjlHLE1BQU1RLHFDQUF1QlAsb0RBQWFBLENBQXVDUTtBQUUxRSxTQUFTQzs7SUFDZCxNQUFNQyxVQUFVVCxpREFBVUEsQ0FBQ007SUFDM0IsSUFBSUcsWUFBWUYsV0FBVztRQUN6QixNQUFNLElBQUlHLE1BQU07SUFDbEI7SUFDQSxPQUFPRDtBQUNUO0dBTmdCRDtBQVlULFNBQVNHLHNCQUFzQixLQUF3QztRQUF4QyxFQUFFQyxRQUFRLEVBQThCLEdBQXhDOztJQUNwQyxNQUFNLEVBQUVDLElBQUksRUFBRUMsaUJBQWlCLEVBQUUsR0FBR1gscURBQU9BO0lBQzNDLE1BQU0sQ0FBQ1ksUUFBUUMsVUFBVSxHQUFHZiwrQ0FBUUEsQ0FBcUI7UUFDdkRnQixhQUFhO1FBQ2JDLFNBQVM7UUFDVEMsWUFBWTtRQUNaQyxNQUFNO1FBQ05DLGFBQWE7UUFDYkMsT0FBTztRQUNQQyxTQUFTO0lBQ1g7SUFFQSxNQUFNLENBQUNDLGdCQUFnQkMsa0JBQWtCLEdBQUd4QiwrQ0FBUUEsQ0FBd0I7SUFFNUUsTUFBTXlCLGdCQUFnQixPQUFPTjtRQUMzQixJQUFJO1lBQ0ZKLFVBQVVXLENBQUFBLE9BQVM7b0JBQUUsR0FBR0EsSUFBSTtvQkFBRUwsT0FBTztvQkFBTUMsU0FBUztnQkFBSztZQUV6REssUUFBUUMsR0FBRyxDQUFDLHNEQUFpRCxPQUFMVCxNQUFLO1lBRTdELHVDQUF1QztZQUN2QyxNQUFNVSxTQUFTekIsMEVBQXVCQTtZQUN0QyxNQUFNMEIsZ0JBQWdCM0IsNkVBQTBCQSxDQUFDMEI7WUFFakQsNkVBQTZFO1lBQzdFLE1BQU1FLFdBQVdaLFNBQVMsVUFBVSw0QkFBNEI7WUFFaEUsa0VBQWtFO1lBQ2xFLE1BQU1hLGFBQWEsTUFBTUYsY0FBY0cscUJBQXFCLENBQUNGLFVBQVVaO1lBRXZF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QUF3QjtvQkFDeEQ4QyxlQUFlbkQsT0FBT0ssSUFBSSxLQUFLLFVBQVUsU0FBUztvQkFDbEQrQyxrQkFBa0JwRCxPQUFPSyxJQUFJLEtBQUssVUFBVSxTQUFTO29CQUNyRGdELFNBQVM7d0JBQ1BDLFNBQVN0RCxPQUFPSyxJQUFJLEtBQUssVUFBVSxrQkFBa0I7d0JBQ3JEa0QsS0FBS3ZELE9BQU9LLElBQUksS0FBSyxVQUFVLHlCQUF5Qjt3QkFDeEQ2QyxZQUFZbEQsT0FBT0ssSUFBSSxLQUFLLFVBQVUsYUFBYTt3QkFDbkRBLE1BQU1MLE9BQU9LLElBQUksS0FBSyxVQUFVLHdCQUF3Qjt3QkFDeEQ4QyxlQUFlbkQsT0FBT0ssSUFBSSxLQUFLLFVBQVUsU0FBUzt3QkFDbEQrQyxrQkFBa0JwRCxPQUFPSyxJQUFJLEtBQUssVUFBVSxTQUFTO29CQUN2RDtnQkFDRjtnQkFDQUosVUFBVVcsQ0FBQUEsT0FBUzt3QkFBRSxHQUFHQSxJQUFJO3dCQUFFTixhQUFheUM7b0JBQWdCO1lBQzdEO1FBQ0Y7SUFDRixHQUFHO1FBQUNqRCxLQUFLc0IsYUFBYTtRQUFFcEIsT0FBT0UsV0FBVztRQUFFRixPQUFPSyxJQUFJO1FBQUVQLEtBQUtRLFdBQVc7S0FBQztJQUUxRSxNQUFNa0QsUUFBa0M7UUFDdEN4RDtRQUNBVztRQUNBaUI7UUFDQUc7UUFDQUM7UUFDQUc7SUFDRjtJQUVBLHFCQUNFLDhEQUFDNUMscUJBQXFCa0UsUUFBUTtRQUFDRCxPQUFPQTtrQkFDbkMzRDs7Ozs7O0FBR1A7SUFsTmdCRDs7UUFDc0JSLGlEQUFPQTs7O0tBRDdCUSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9jb250ZXh0cy9QYXNza2V5V2FsbGV0Q29udGV4dC50c3g/ZmYxNyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIGNsaWVudCdcblxuaW1wb3J0IFJlYWN0LCB7IGNyZWF0ZUNvbnRleHQsIHVzZUNvbnRleHQsIHVzZVN0YXRlLCB1c2VFZmZlY3QsIFJlYWN0Tm9kZSB9IGZyb20gJ3JlYWN0J1xuaW1wb3J0IHsgdXNlVkxFSSB9IGZyb20gJy4vVkxFSUNvbnRleHQnXG5pbXBvcnQgeyBQYXNza2V5QXV0aGVudGljYXRvciwgY3JlYXRlUGFzc2tleUF1dGhlbnRpY2F0b3IsIGdldERlZmF1bHRQYXNza2V5Q29uZmlnIH0gZnJvbSAnQC9saWIvcGFzc2tleS1hdXRoJ1xuXG5leHBvcnQgaW50ZXJmYWNlIFBhc3NrZXlXYWxsZXRTdGF0ZSB7XG4gIGlzQ29ubmVjdGVkOiBib29sZWFuXG4gIGFkZHJlc3M6IHN0cmluZyB8IG51bGxcbiAgY29udHJhY3RJZDogc3RyaW5nIHwgbnVsbFxuICByb2xlOiAnYnV5ZXInIHwgJ3NlbGxlcicgfCBudWxsXG4gIGNyZWRlbnRpYWxzOiBhbnkgfCBudWxsXG4gIGVycm9yOiBzdHJpbmcgfCBudWxsXG4gIGxvYWRpbmc6IGJvb2xlYW5cbn1cblxuaW50ZXJmYWNlIFBhc3NrZXlXYWxsZXRDb250ZXh0VHlwZSB7XG4gIHdhbGxldDogUGFzc2tleVdhbGxldFN0YXRlXG4gIGNvbm5lY3RXYWxsZXQ6IChyb2xlOiAnYnV5ZXInIHwgJ3NlbGxlcicpID0+IFByb21pc2U8dm9pZD5cbiAgZGlzY29ubmVjdFdhbGxldDogKCkgPT4gdm9pZFxuICBzd2l0Y2hSb2xlOiAocm9sZTogJ2J1eWVyJyB8ICdzZWxsZXInKSA9PiB2b2lkXG4gIGV4ZWN1dGVUcmFuc2FjdGlvbjogKHBhcmFtczogYW55KSA9PiBQcm9taXNlPGFueT5cbiAgZ2V0QWNjb3VudEluZm86ICgpID0+IFByb21pc2U8YW55PlxufVxuXG5jb25zdCBQYXNza2V5V2FsbGV0Q29udGV4dCA9IGNyZWF0ZUNvbnRleHQ8UGFzc2tleVdhbGxldENvbnRleHRUeXBlIHwgdW5kZWZpbmVkPih1bmRlZmluZWQpXG5cbmV4cG9ydCBmdW5jdGlvbiB1c2VQYXNza2V5V2FsbGV0KCkge1xuICBjb25zdCBjb250ZXh0ID0gdXNlQ29udGV4dChQYXNza2V5V2FsbGV0Q29udGV4dClcbiAgaWYgKGNvbnRleHQgPT09IHVuZGVmaW5lZCkge1xuICAgIHRocm93IG5ldyBFcnJvcigndXNlUGFzc2tleVdhbGxldCBtdXN0IGJlIHVzZWQgd2l0aGluIGEgUGFzc2tleVdhbGxldFByb3ZpZGVyJylcbiAgfVxuICByZXR1cm4gY29udGV4dFxufVxuXG5pbnRlcmZhY2UgUGFzc2tleVdhbGxldFByb3ZpZGVyUHJvcHMge1xuICBjaGlsZHJlbjogUmVhY3ROb2RlXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBQYXNza2V5V2FsbGV0UHJvdmlkZXIoeyBjaGlsZHJlbiB9OiBQYXNza2V5V2FsbGV0UHJvdmlkZXJQcm9wcykge1xuICBjb25zdCB7IHZsZWksIHZlcmlmeUNyZWRlbnRpYWxzIH0gPSB1c2VWTEVJKClcbiAgY29uc3QgW3dhbGxldCwgc2V0V2FsbGV0XSA9IHVzZVN0YXRlPFBhc3NrZXlXYWxsZXRTdGF0ZT4oe1xuICAgIGlzQ29ubmVjdGVkOiBmYWxzZSxcbiAgICBhZGRyZXNzOiBudWxsLFxuICAgIGNvbnRyYWN0SWQ6IG51bGwsXG4gICAgcm9sZTogbnVsbCxcbiAgICBjcmVkZW50aWFsczogbnVsbCxcbiAgICBlcnJvcjogbnVsbCxcbiAgICBsb2FkaW5nOiBmYWxzZSxcbiAgfSlcblxuICBjb25zdCBbcGFzc2tleVNlcnZpY2UsIHNldFBhc3NrZXlTZXJ2aWNlXSA9IHVzZVN0YXRlPFBhc3NrZXlTZXJ2aWNlIHwgbnVsbD4obnVsbClcblxuICBjb25zdCBjb25uZWN0V2FsbGV0ID0gYXN5bmMgKHJvbGU6ICdidXllcicgfCAnc2VsbGVyJykgPT4ge1xuICAgIHRyeSB7XG4gICAgICBzZXRXYWxsZXQocHJldiA9PiAoeyAuLi5wcmV2LCBlcnJvcjogbnVsbCwgbG9hZGluZzogdHJ1ZSB9KSlcblxuICAgICAgY29uc29sZS5sb2coYPCflJAgU3RhcnRpbmcgYmlvbWV0cmljIGF1dGhlbnRpY2F0aW9uIGZvciAke3JvbGV9Li4uYClcblxuICAgICAgLy8gQ3JlYXRlIFBhc3NrZXlBdXRoZW50aWNhdG9yIGluc3RhbmNlXG4gICAgICBjb25zdCBjb25maWcgPSBnZXREZWZhdWx0UGFzc2tleUNvbmZpZygpXG4gICAgICBjb25zdCBhdXRoZW50aWNhdG9yID0gY3JlYXRlUGFzc2tleUF1dGhlbnRpY2F0b3IoY29uZmlnKVxuXG4gICAgICAvLyBTdGVwIDE6IEF1dGhlbnRpY2F0ZSB3aXRoIFBhc3NrZXkgKGJpb21ldHJpYykgLSBmb2xsb3dpbmcgdGhlIGZsb3cgZGlhZ3JhbVxuICAgICAgY29uc3QgdXNlck5hbWUgPSByb2xlID09PSAnYnV5ZXInID8gJ0pvaG4gRG9lIC0gVGVjaENvcnAgQ0ZPJyA6ICdKYW5lIFNtaXRoIC0gU3VwcGxpZXJDbyBTYWxlcydcbiAgICAgIFxuICAgICAgLy8gQ3JlYXRlIG9yIGNvbm5lY3QgdG8gc21hcnQgd2FsbGV0IHdpdGggYmlvbWV0cmljIGF1dGhlbnRpY2F0aW9uXG4gICAgICBjb25zdCB3YWxsZXRJbmZvID0gYXdhaXQgYXV0aGVudGljYXRvci5jcmVhdGVPckNvbm5lY3RXYWxsZXQodXNlck5hbWUsIHJvbGUpXG4gICAgICBcbiAgICAgIC8vIFN0b3JlIGF1dGhlbnRpY2F0b3IgZm9yIGZ1dHVyZSB1c2VcbiAgICAgIHNldFBhc3NrZXlTZXJ2aWNlKGF1dGhlbnRpY2F0b3IgYXMgYW55KVxuXG4gICAgICBjb25zdCBhZGRyZXNzID0gd2FsbGV0SW5mby5hZGRyZXNzXG4gICAgICBjb25zdCBjb250cmFjdElkID0gd2FsbGV0SW5mby5jb250cmFjdElkXG5cbiAgICAgIC8vIFZlcmlmeSB2TEVJIGNyZWRlbnRpYWxzXG4gICAgICBsZXQgY3JlZGVudGlhbHMgPSBudWxsXG4gICAgICBpZiAodmxlaS5pc0luaXRpYWxpemVkKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgY3JlZGVudGlhbHMgPSBhd2FpdCB2ZXJpZnlDcmVkZW50aWFscyhyb2xlKVxuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgIGNvbnNvbGUud2FybigndkxFSSBjcmVkZW50aWFsIHZlcmlmaWNhdGlvbiBmYWlsZWQ6JywgZXJyb3IpXG4gICAgICAgICAgLy8gQ29udGludWUgd2l0aG91dCBjcmVkZW50aWFscyBmb3Igbm93XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgc2V0V2FsbGV0KHtcbiAgICAgICAgaXNDb25uZWN0ZWQ6IHRydWUsXG4gICAgICAgIGFkZHJlc3MsXG4gICAgICAgIGNvbnRyYWN0SWQsXG4gICAgICAgIHJvbGUsXG4gICAgICAgIGNyZWRlbnRpYWxzLFxuICAgICAgICBlcnJvcjogbnVsbCxcbiAgICAgICAgbG9hZGluZzogZmFsc2UsXG4gICAgICB9KVxuXG4gICAgICAvLyBTdG9yZSBpbiBsb2NhbFN0b3JhZ2UgZm9yIHBlcnNpc3RlbmNlXG4gICAgICBsb2NhbFN0b3JhZ2Uuc2V0SXRlbSgncGFzc2tleVdhbGxldFN0YXRlJywgSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgICBpc0Nvbm5lY3RlZDogdHJ1ZSxcbiAgICAgICAgYWRkcmVzcyxcbiAgICAgICAgY29udHJhY3RJZCxcbiAgICAgICAgcm9sZSxcbiAgICAgICAgY3JlZGVudGlhbHMsXG4gICAgICB9KSlcblxuICAgICAgY29uc29sZS5sb2coYOKchSAke3JvbGV9IHdhbGxldCBjb25uZWN0ZWQgc3VjY2Vzc2Z1bGx5YClcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc3QgZXJyb3JNZXNzYWdlID0gZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yLm1lc3NhZ2UgOiAnRmFpbGVkIHRvIGNvbm5lY3Qgd2FsbGV0J1xuICAgICAgc2V0V2FsbGV0KHByZXYgPT4gKHtcbiAgICAgICAgLi4ucHJldixcbiAgICAgICAgZXJyb3I6IGVycm9yTWVzc2FnZSxcbiAgICAgICAgbG9hZGluZzogZmFsc2UsXG4gICAgICB9KSlcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ+KdjCBXYWxsZXQgY29ubmVjdGlvbiBmYWlsZWQ6JywgZXJyb3IpXG4gICAgfVxuICB9XG5cbiAgY29uc3QgZGlzY29ubmVjdFdhbGxldCA9ICgpID0+IHtcbiAgICB0cnkge1xuICAgICAgaWYgKHBhc3NrZXlTZXJ2aWNlICYmIHR5cGVvZiBwYXNza2V5U2VydmljZS5kaXNjb25uZWN0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHBhc3NrZXlTZXJ2aWNlLmRpc2Nvbm5lY3QoKVxuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLndhcm4oJ0Vycm9yIGR1cmluZyB3YWxsZXQgZGlzY29ubmVjdDonLCBlcnJvcilcbiAgICB9XG4gICAgXG4gICAgc2V0V2FsbGV0KHtcbiAgICAgIGlzQ29ubmVjdGVkOiBmYWxzZSxcbiAgICAgIGFkZHJlc3M6IG51bGwsXG4gICAgICBjb250cmFjdElkOiBudWxsLFxuICAgICAgcm9sZTogbnVsbCxcbiAgICAgIGNyZWRlbnRpYWxzOiBudWxsLFxuICAgICAgZXJyb3I6IG51bGwsXG4gICAgICBsb2FkaW5nOiBmYWxzZSxcbiAgICB9KVxuICAgIFxuICAgIHNldFBhc3NrZXlTZXJ2aWNlKG51bGwpXG4gICAgbG9jYWxTdG9yYWdlLnJlbW92ZUl0ZW0oJ3Bhc3NrZXlXYWxsZXRTdGF0ZScpXG4gICAgY29uc29sZS5sb2coJ/CflIwgV2FsbGV0IGRpc2Nvbm5lY3RlZCcpXG4gIH1cblxuICBjb25zdCBzd2l0Y2hSb2xlID0gYXN5bmMgKHJvbGU6ICdidXllcicgfCAnc2VsbGVyJykgPT4ge1xuICAgIGlmICh3YWxsZXQuaXNDb25uZWN0ZWQpIHtcbiAgICAgIGF3YWl0IGNvbm5lY3RXYWxsZXQocm9sZSlcbiAgICB9XG4gIH1cblxuICBjb25zdCBleGVjdXRlVHJhbnNhY3Rpb24gPSBhc3luYyAocGFyYW1zOiBhbnkpOiBQcm9taXNlPGFueT4gPT4ge1xuICAgIGlmICghcGFzc2tleVNlcnZpY2UgfHwgIXdhbGxldC5pc0Nvbm5lY3RlZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdXYWxsZXQgbm90IGNvbm5lY3RlZCcpXG4gICAgfVxuXG4gICAgdHJ5IHtcbiAgICAgIHNldFdhbGxldChwcmV2ID0+ICh7IC4uLnByZXYsIGxvYWRpbmc6IHRydWUsIGVycm9yOiBudWxsIH0pKVxuICAgICAgXG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBwYXNza2V5U2VydmljZS5leGVjdXRlVHJhbnNhY3Rpb24ocGFyYW1zKVxuICAgICAgXG4gICAgICBzZXRXYWxsZXQocHJldiA9PiAoeyAuLi5wcmV2LCBsb2FkaW5nOiBmYWxzZSB9KSlcbiAgICAgIHJldHVybiByZXN1bHRcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc3QgZXJyb3JNZXNzYWdlID0gZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yLm1lc3NhZ2UgOiAnVHJhbnNhY3Rpb24gZmFpbGVkJ1xuICAgICAgc2V0V2FsbGV0KHByZXYgPT4gKHsgLi4ucHJldiwgZXJyb3I6IGVycm9yTWVzc2FnZSwgbG9hZGluZzogZmFsc2UgfSkpXG4gICAgICB0aHJvdyBlcnJvclxuICAgIH1cbiAgfVxuXG4gIGNvbnN0IGdldEFjY291bnRJbmZvID0gYXN5bmMgKCk6IFByb21pc2U8YW55PiA9PiB7XG4gICAgaWYgKCFwYXNza2V5U2VydmljZSB8fCAhd2FsbGV0LmlzQ29ubmVjdGVkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1dhbGxldCBub3QgY29ubmVjdGVkJylcbiAgICB9XG5cbiAgICByZXR1cm4gYXdhaXQgcGFzc2tleVNlcnZpY2UuZ2V0QWNjb3VudEluZm8oKVxuICB9XG5cbiAgLy8gUmVzdG9yZSB3YWxsZXQgc3RhdGUgb24gbW91bnRcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBjb25zdCBzYXZlZFN0YXRlID0gbG9jYWxTdG9yYWdlLmdldEl0ZW0oJ3Bhc3NrZXlXYWxsZXRTdGF0ZScpXG4gICAgaWYgKHNhdmVkU3RhdGUpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHBhcnNlZCA9IEpTT04ucGFyc2Uoc2F2ZWRTdGF0ZSlcbiAgICAgICAgaWYgKHBhcnNlZC5pc0Nvbm5lY3RlZCAmJiBwYXJzZWQucm9sZSkge1xuICAgICAgICAgIC8vIERvbid0IGF1dG8tY29ubmVjdCwganVzdCByZXN0b3JlIHRoZSBzdGF0ZVxuICAgICAgICAgIHNldFdhbGxldChwcmV2ID0+ICh7XG4gICAgICAgICAgICAuLi5wcmV2LFxuICAgICAgICAgICAgLi4ucGFyc2VkLFxuICAgICAgICAgICAgbG9hZGluZzogZmFsc2UsXG4gICAgICAgICAgICBlcnJvcjogbnVsbCxcbiAgICAgICAgICB9KSlcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcignRmFpbGVkIHRvIHJlc3RvcmUgd2FsbGV0IHN0YXRlOicsIGVycm9yKVxuICAgICAgICBsb2NhbFN0b3JhZ2UucmVtb3ZlSXRlbSgncGFzc2tleVdhbGxldFN0YXRlJylcbiAgICAgIH1cbiAgICB9XG4gIH0sIFtdKVxuXG4gIC8vIFVwZGF0ZSBjcmVkZW50aWFscyB3aGVuIHZMRUkgaXMgaW5pdGlhbGl6ZWQgYW5kIGNyZWRlbnRpYWxzIGFyZSBhdmFpbGFibGVcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAodmxlaS5pc0luaXRpYWxpemVkICYmIHdhbGxldC5pc0Nvbm5lY3RlZCAmJiB3YWxsZXQucm9sZSkge1xuICAgICAgLy8gQ2hlY2sgaWYgY3JlZGVudGlhbHMgYXJlIGF2YWlsYWJsZSBiZWZvcmUgdHJ5aW5nIHRvIHZlcmlmeVxuICAgICAgY29uc3QgaGFzQ3JlZGVudGlhbHMgPSB3YWxsZXQucm9sZSA9PT0gJ2J1eWVyJyBcbiAgICAgICAgPyAodmxlaS5jcmVkZW50aWFscy5qb2huICYmIHZsZWkuY3JlZGVudGlhbHMudGVjaGNvcnApXG4gICAgICAgIDogKHZsZWkuY3JlZGVudGlhbHMuamFuZSAmJiB2bGVpLmNyZWRlbnRpYWxzLnN1cHBsaWVyY28pXG4gICAgICBcbiAgICAgIGlmIChoYXNDcmVkZW50aWFscykge1xuICAgICAgICB2ZXJpZnlDcmVkZW50aWFscyh3YWxsZXQucm9sZSlcbiAgICAgICAgICAudGhlbihjcmVkZW50aWFscyA9PiB7XG4gICAgICAgICAgICBzZXRXYWxsZXQocHJldiA9PiAoeyAuLi5wcmV2LCBjcmVkZW50aWFscyB9KSlcbiAgICAgICAgICB9KVxuICAgICAgICAgIC5jYXRjaChlcnJvciA9PiB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oJ0ZhaWxlZCB0byB1cGRhdGUgY3JlZGVudGlhbHM6JywgZXJyb3IpXG4gICAgICAgICAgfSlcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIFVzZSBtb2NrIGNyZWRlbnRpYWxzIGlmIHJlYWwgb25lcyBhcmVuJ3QgYXZhaWxhYmxlIHlldFxuICAgICAgICBjb25zdCBtb2NrQ3JlZGVudGlhbHMgPSB7XG4gICAgICAgICAgdmFsaWQ6IHRydWUsXG4gICAgICAgICAgb3JnTEVJOiB3YWxsZXQucm9sZSA9PT0gJ2J1eWVyJyA/ICc1MDY3MDBHRTFHMjkzMjVRWDM2MycgOiAnNTQ5MzAwWE9DVVpENEVNS0dZOTYnLFxuICAgICAgICAgIHBlcnNvbk5hbWU6IHdhbGxldC5yb2xlID09PSAnYnV5ZXInID8gJ0pvaG4gRG9lJyA6ICdKYW5lIFNtaXRoJyxcbiAgICAgICAgICByb2xlOiB3YWxsZXQucm9sZSA9PT0gJ2J1eWVyJyA/ICdQcm9jdXJlbWVudCBNYW5hZ2VyJyA6ICdDb250cmFjdCBTaWduZXInLFxuICAgICAgICAgIHNwZW5kaW5nTGltaXQ6IHdhbGxldC5yb2xlID09PSAnYnV5ZXInID8gMTAwMDAwIDogNTAwMDAwLFxuICAgICAgICAgIG1heENvbnRyYWN0VmFsdWU6IHdhbGxldC5yb2xlID09PSAnYnV5ZXInID8gMTAwMDAwIDogNTAwMDAwLFxuICAgICAgICAgIGRldGFpbHM6IHtcbiAgICAgICAgICAgIG9yZ05hbWU6IHdhbGxldC5yb2xlID09PSAnYnV5ZXInID8gJ1RlY2hDb3JwIEluYy4nIDogJ1N1cHBsaWVyQ28gTExDJyxcbiAgICAgICAgICAgIGxlaTogd2FsbGV0LnJvbGUgPT09ICdidXllcicgPyAnNTA2NzAwR0UxRzI5MzI1UVgzNjMnIDogJzU0OTMwMFhPQ1VaRDRFTUtHWTk2JyxcbiAgICAgICAgICAgIHBlcnNvbk5hbWU6IHdhbGxldC5yb2xlID09PSAnYnV5ZXInID8gJ0pvaG4gRG9lJyA6ICdKYW5lIFNtaXRoJyxcbiAgICAgICAgICAgIHJvbGU6IHdhbGxldC5yb2xlID09PSAnYnV5ZXInID8gJ1Byb2N1cmVtZW50IE1hbmFnZXInIDogJ0NvbnRyYWN0IFNpZ25lcicsXG4gICAgICAgICAgICBzcGVuZGluZ0xpbWl0OiB3YWxsZXQucm9sZSA9PT0gJ2J1eWVyJyA/IDEwMDAwMCA6IDUwMDAwMCxcbiAgICAgICAgICAgIG1heENvbnRyYWN0VmFsdWU6IHdhbGxldC5yb2xlID09PSAnYnV5ZXInID8gMTAwMDAwIDogNTAwMDAwLFxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBzZXRXYWxsZXQocHJldiA9PiAoeyAuLi5wcmV2LCBjcmVkZW50aWFsczogbW9ja0NyZWRlbnRpYWxzIH0pKVxuICAgICAgfVxuICAgIH1cbiAgfSwgW3ZsZWkuaXNJbml0aWFsaXplZCwgd2FsbGV0LmlzQ29ubmVjdGVkLCB3YWxsZXQucm9sZSwgdmxlaS5jcmVkZW50aWFsc10pXG5cbiAgY29uc3QgdmFsdWU6IFBhc3NrZXlXYWxsZXRDb250ZXh0VHlwZSA9IHtcbiAgICB3YWxsZXQsXG4gICAgY29ubmVjdFdhbGxldCxcbiAgICBkaXNjb25uZWN0V2FsbGV0LFxuICAgIHN3aXRjaFJvbGUsXG4gICAgZXhlY3V0ZVRyYW5zYWN0aW9uLFxuICAgIGdldEFjY291bnRJbmZvLFxuICB9XG5cbiAgcmV0dXJuIChcbiAgICA8UGFzc2tleVdhbGxldENvbnRleHQuUHJvdmlkZXIgdmFsdWU9e3ZhbHVlfT5cbiAgICAgIHtjaGlsZHJlbn1cbiAgICA8L1Bhc3NrZXlXYWxsZXRDb250ZXh0LlByb3ZpZGVyPlxuICApXG59XG4iXSwibmFtZXMiOlsiUmVhY3QiLCJjcmVhdGVDb250ZXh0IiwidXNlQ29udGV4dCIsInVzZVN0YXRlIiwidXNlRWZmZWN0IiwidXNlVkxFSSIsImNyZWF0ZVBhc3NrZXlBdXRoZW50aWNhdG9yIiwiZ2V0RGVmYXVsdFBhc3NrZXlDb25maWciLCJQYXNza2V5V2FsbGV0Q29udGV4dCIsInVuZGVmaW5lZCIsInVzZVBhc3NrZXlXYWxsZXQiLCJjb250ZXh0IiwiRXJyb3IiLCJQYXNza2V5V2FsbGV0UHJvdmlkZXIiLCJjaGlsZHJlbiIsInZsZWkiLCJ2ZXJpZnlDcmVkZW50aWFscyIsIndhbGxldCIsInNldFdhbGxldCIsImlzQ29ubmVjdGVkIiwiYWRkcmVzcyIsImNvbnRyYWN0SWQiLCJyb2xlIiwiY3JlZGVudGlhbHMiLCJlcnJvciIsImxvYWRpbmciLCJwYXNza2V5U2VydmljZSIsInNldFBhc3NrZXlTZXJ2aWNlIiwiY29ubmVjdFdhbGxldCIsInByZXYiLCJjb25zb2xlIiwibG9nIiwiY29uZmlnIiwiYXV0aGVudGljYXRvciIsInVzZXJOYW1lIiwid2FsbGV0SW5mbyIsImNyZWF0ZU9yQ29ubmVjdFdhbGxldCIsImlzSW5pdGlhbGl6ZWQiLCJ3YXJuIiwibG9jYWxTdG9yYWdlIiwic2V0SXRlbSIsIkpTT04iLCJzdHJpbmdpZnkiLCJlcnJvck1lc3NhZ2UiLCJtZXNzYWdlIiwiZGlzY29ubmVjdFdhbGxldCIsImRpc2Nvbm5lY3QiLCJyZW1vdmVJdGVtIiwic3dpdGNoUm9sZSIsImV4ZWN1dGVUcmFuc2FjdGlvbiIsInBhcmFtcyIsInJlc3VsdCIsImdldEFjY291bnRJbmZvIiwic2F2ZWRTdGF0ZSIsImdldEl0ZW0iLCJwYXJzZWQiLCJwYXJzZSIsImhhc0NyZWRlbnRpYWxzIiwiam9obiIsInRlY2hjb3JwIiwiamFuZSIsInN1cHBsaWVyY28iLCJ0aGVuIiwiY2F0Y2giLCJtb2NrQ3JlZGVudGlhbHMiLCJ2YWxpZCIsIm9yZ0xFSSIsInBlcnNvbk5hbWUiLCJzcGVuZGluZ0xpbWl0IiwibWF4Q29udHJhY3RWYWx1ZSIsImRldGFpbHMiLCJvcmdOYW1lIiwibGVpIiwidmFsdWUiLCJQcm92aWRlciJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./contexts/PasskeyWalletContext.tsx\n"));

/***/ }),

/***/ "(app-pages-browser)/./lib/passkey-auth.ts":
/*!*****************************!*\
  !*** ./lib/passkey-auth.ts ***!
  \*****************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   PasskeyAuthenticator: function() { return /* binding */ PasskeyAuthenticator; },\n/* harmony export */   createPasskeyAuthenticator: function() { return /* binding */ createPasskeyAuthenticator; },\n/* harmony export */   getDefaultPasskeyConfig: function() { return /* binding */ getDefaultPasskeyConfig; }\n/* harmony export */ });\n/* provided dependency */ var process = __webpack_require__(/*! process */ \"(app-pages-browser)/./node_modules/next/dist/build/polyfills/process.js\");\n// Real Passkey Authentication Implementation\n// Following the complete flow diagram from the documentation\nclass PasskeyAuthenticator {\n    /**\n   * Step 1: Authenticate with Passkey (biometric)\n   * This is the core biometric authentication step from the flow diagram\n   */ async authenticateWithPasskey(userName) {\n        try {\n            console.log(\"\\uD83D\\uDD10 Starting biometric authentication for: \".concat(userName));\n            // Check if WebAuthn is supported\n            if (!window.PublicKeyCredential) {\n                throw new Error(\"WebAuthn/Passkeys not supported in this browser\");\n            }\n            // Check if user has existing credentials\n            const existingCredentials = await this.getExistingCredentials(userName);\n            if (existingCredentials.length > 0) {\n                // Use existing credential for authentication\n                return await this.authenticateWithExistingCredential(existingCredentials[0]);\n            } else {\n                // Create new credential\n                return await this.createNewCredential(userName);\n            }\n        } catch (error) {\n            console.error(\"❌ Biometric authentication failed:\", error);\n            return {\n                success: false,\n                error: error instanceof Error ? error.message : \"Authentication failed\"\n            };\n        }\n    }\n    /**\n   * Create new passkey credential\n   */ async createNewCredential(userName) {\n        try {\n            console.log(\"\\uD83C\\uDD95 Creating new passkey credential for: \".concat(userName));\n            const challenge = new Uint8Array(32);\n            crypto.getRandomValues(challenge);\n            const credential = await navigator.credentials.create({\n                publicKey: {\n                    challenge,\n                    rp: {\n                        name: \"Stellar Procurement dApp\",\n                        id: window.location.hostname\n                    },\n                    user: {\n                        id: new TextEncoder().encode(userName),\n                        name: userName,\n                        displayName: userName\n                    },\n                    pubKeyCredParams: [\n                        {\n                            type: \"public-key\",\n                            alg: -7\n                        },\n                        {\n                            type: \"public-key\",\n                            alg: -257\n                        }\n                    ],\n                    authenticatorSelection: {\n                        authenticatorAttachment: \"platform\",\n                        userVerification: \"required\",\n                        residentKey: \"required\"\n                    },\n                    timeout: 60000,\n                    attestation: \"direct\"\n                }\n            });\n            if (!credential) {\n                throw new Error(\"Failed to create passkey credential\");\n            }\n            console.log(\"✅ New passkey credential created successfully\");\n            return {\n                success: true,\n                credentialId: credential.id,\n                publicKey: this.arrayBufferToBase64(credential.response.publicKey || new ArrayBuffer(0))\n            };\n        } catch (error) {\n            console.error(\"❌ Failed to create passkey credential:\", error);\n            return {\n                success: false,\n                error: error instanceof Error ? error.message : \"Credential creation failed\"\n            };\n        }\n    }\n    /**\n   * Authenticate with existing credential\n   */ async authenticateWithExistingCredential(credentialId) {\n        try {\n            console.log(\"\\uD83D\\uDD11 Authenticating with existing credential: \".concat(credentialId));\n            const challenge = new Uint8Array(32);\n            crypto.getRandomValues(challenge);\n            const assertion = await navigator.credentials.get({\n                publicKey: {\n                    challenge,\n                    allowCredentials: [\n                        {\n                            type: \"public-key\",\n                            id: this.base64ToArrayBuffer(credentialId)\n                        }\n                    ],\n                    userVerification: \"required\",\n                    timeout: 60000\n                }\n            });\n            if (!assertion) {\n                throw new Error(\"Failed to authenticate with passkey\");\n            }\n            console.log(\"✅ Biometric authentication successful\");\n            return {\n                success: true,\n                credentialId: assertion.id,\n                signature: this.arrayBufferToBase64(assertion.response.signature)\n            };\n        } catch (error) {\n            console.error(\"❌ Failed to authenticate with existing credential:\", error);\n            return {\n                success: false,\n                error: error instanceof Error ? error.message : \"Authentication failed\"\n            };\n        }\n    }\n    /**\n   * Get existing credentials for a user\n   */ async getExistingCredentials(userName) {\n        try {\n            // In a real implementation, you would store credential IDs\n            // For now, we'll check localStorage\n            const storedCredentials = localStorage.getItem(\"passkey_credentials_\".concat(userName));\n            return storedCredentials ? JSON.parse(storedCredentials) : [];\n        } catch (error) {\n            console.error(\"❌ Failed to get existing credentials:\", error);\n            return [];\n        }\n    }\n    /**\n   * Store credential ID for future use\n   */ storeCredentialId(userName, credentialId) {\n        try {\n            const existingCredentials = this.getExistingCredentials(userName);\n            if (!existingCredentials.includes(credentialId)) {\n                existingCredentials.push(credentialId);\n                localStorage.setItem(\"passkey_credentials_\".concat(userName), JSON.stringify(existingCredentials));\n            }\n        } catch (error) {\n            console.error(\"❌ Failed to store credential ID:\", error);\n        }\n    }\n    /**\n   * Step 2: Create or connect to Stellar smart wallet\n   * This follows the \"Passkey-Kit signs transaction\" step from the flow\n   */ async createOrConnectWallet(userName, role) {\n        try {\n            console.log(\"\\uD83C\\uDFE6 Creating/connecting smart wallet for \".concat(role, \": \").concat(userName));\n            // First authenticate with passkey\n            const authResult = await this.authenticateWithPasskey(userName);\n            if (!authResult.success) {\n                throw new Error(\"Biometric authentication failed: \".concat(authResult.error));\n            }\n            // Store credential ID for future use\n            if (authResult.credentialId) {\n                this.storeCredentialId(userName, authResult.credentialId);\n            }\n            // Generate Stellar keypair (in real implementation, this would be derived from passkey)\n            const keypair = this.generateStellarKeypair(authResult.credentialId || userName);\n            // Create smart wallet contract (simplified - in real implementation, this would use Passkey-Kit)\n            const contractId = await this.deploySmartWallet(keypair, userName, role);\n            this.walletInfo = {\n                address: keypair.publicKey(),\n                contractId: contractId,\n                isConnected: true\n            };\n            console.log(\"✅ Smart wallet created/connected successfully\");\n            console.log(\"\\uD83D\\uDCCD Address: \".concat(this.walletInfo.address));\n            console.log(\"\\uD83D\\uDCC4 Contract ID: \".concat(this.walletInfo.contractId));\n            return this.walletInfo;\n        } catch (error) {\n            console.error(\"❌ Failed to create/connect wallet:\", error);\n            throw error;\n        }\n    }\n    /**\n   * Step 3: Sign transaction with passkey\n   * This is the \"Passkey-Kit signs transaction\" step from the flow\n   */ async signTransactionWithPasskey(transaction, userName) {\n        try {\n            console.log(\"✍️ Signing transaction with passkey for: \".concat(userName));\n            // Authenticate with passkey first\n            const authResult = await this.authenticateWithPasskey(userName);\n            if (!authResult.success) {\n                throw new Error(\"Biometric authentication failed: \".concat(authResult.error));\n            }\n            // In a real implementation, you would use the passkey signature to sign the transaction\n            // For now, we'll simulate the signing process\n            console.log(\"✅ Transaction signed with passkey successfully\");\n            return transaction;\n        } catch (error) {\n            console.error(\"❌ Failed to sign transaction with passkey:\", error);\n            throw error;\n        }\n    }\n    /**\n   * Generate Stellar keypair (simplified implementation)\n   */ generateStellarKeypair(seed) {\n        // In a real implementation, this would use proper key derivation\n        // For now, we'll create a deterministic keypair\n        const hash = new TextEncoder().encode(seed);\n        const keypair = {\n            publicKey: ()=>\"G\".concat(seed.substring(0, 55)),\n            secret: ()=>\"S\".concat(seed.substring(0, 55))\n        };\n        return keypair;\n    }\n    /**\n   * Deploy smart wallet contract (simplified implementation)\n   */ async deploySmartWallet(keypair, userName, role) {\n        // In a real implementation, this would deploy an actual smart wallet contract\n        // For now, we'll return a mock contract ID\n        const contractId = \"CC\".concat(role.toUpperCase(), \"_\").concat(userName.replace(/\\s+/g, \"_\"), \"_\").concat(Date.now());\n        console.log(\"\\uD83D\\uDCC4 Smart wallet contract deployed: \".concat(contractId));\n        return contractId;\n    }\n    /**\n   * Utility functions\n   */ arrayBufferToBase64(buffer) {\n        const bytes = new Uint8Array(buffer);\n        let binary = \"\";\n        for(let i = 0; i < bytes.byteLength; i++){\n            binary += String.fromCharCode(bytes[i]);\n        }\n        return btoa(binary);\n    }\n    base64ToArrayBuffer(base64) {\n        const binary = atob(base64);\n        const bytes = new Uint8Array(binary.length);\n        for(let i = 0; i < binary.length; i++){\n            bytes[i] = binary.charCodeAt(i);\n        }\n        return bytes.buffer;\n    }\n    /**\n   * Get current wallet info\n   */ getWalletInfo() {\n        return this.walletInfo;\n    }\n    /**\n   * Disconnect wallet\n   */ disconnect() {\n        this.walletInfo = null;\n        console.log(\"\\uD83D\\uDD0C Wallet disconnected\");\n    }\n    constructor(config){\n        this.walletInfo = null;\n        this.config = config;\n    }\n}\n// Factory function to create PasskeyAuthenticator\nfunction createPasskeyAuthenticator(config) {\n    return new PasskeyAuthenticator(config);\n}\n// Default configuration\nfunction getDefaultPasskeyConfig() {\n    return {\n        rpcUrl: process.env.NEXT_PUBLIC_RPC_URL || \"https://soroban-testnet.stellar.org\",\n        networkPassphrase: process.env.NEXT_PUBLIC_NETWORK_PASSPHRASE || \"Test SDF Network ; September 2015\",\n        factoryContractId: process.env.NEXT_PUBLIC_FACTORY_CONTRACT_ID || \"CCWJFJ7YQHZ3QH2GQYQZQZQZQZQZQZQZQZQZQZQZQZQZQZQ\"\n    };\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2xpYi9wYXNza2V5LWF1dGgudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUFBLDZDQUE2QztBQUM3Qyw2REFBNkQ7QUF3QnRELE1BQU1BO0lBUVg7OztHQUdDLEdBQ0QsTUFBTUMsd0JBQXdCQyxRQUFnQixFQUFnQztRQUM1RSxJQUFJO1lBQ0ZDLFFBQVFDLEdBQUcsQ0FBQyx1REFBc0QsT0FBVEY7WUFFekQsaUNBQWlDO1lBQ2pDLElBQUksQ0FBQ0csT0FBT0MsbUJBQW1CLEVBQUU7Z0JBQy9CLE1BQU0sSUFBSUMsTUFBTTtZQUNsQjtZQUVBLHlDQUF5QztZQUN6QyxNQUFNQyxzQkFBc0IsTUFBTSxJQUFJLENBQUNDLHNCQUFzQixDQUFDUDtZQUU5RCxJQUFJTSxvQkFBb0JFLE1BQU0sR0FBRyxHQUFHO2dCQUNsQyw2Q0FBNkM7Z0JBQzdDLE9BQU8sTUFBTSxJQUFJLENBQUNDLGtDQUFrQyxDQUFDSCxtQkFBbUIsQ0FBQyxFQUFFO1lBQzdFLE9BQU87Z0JBQ0wsd0JBQXdCO2dCQUN4QixPQUFPLE1BQU0sSUFBSSxDQUFDSSxtQkFBbUIsQ0FBQ1Y7WUFDeEM7UUFDRixFQUFFLE9BQU9XLE9BQU87WUFDZFYsUUFBUVUsS0FBSyxDQUFDLHNDQUFzQ0E7WUFDcEQsT0FBTztnQkFDTEMsU0FBUztnQkFDVEQsT0FBT0EsaUJBQWlCTixRQUFRTSxNQUFNRSxPQUFPLEdBQUc7WUFDbEQ7UUFDRjtJQUNGO0lBRUE7O0dBRUMsR0FDRCxNQUFjSCxvQkFBb0JWLFFBQWdCLEVBQWdDO1FBQ2hGLElBQUk7WUFDRkMsUUFBUUMsR0FBRyxDQUFDLHFEQUFvRCxPQUFURjtZQUV2RCxNQUFNYyxZQUFZLElBQUlDLFdBQVc7WUFDakNDLE9BQU9DLGVBQWUsQ0FBQ0g7WUFFdkIsTUFBTUksYUFBYSxNQUFNQyxVQUFVQyxXQUFXLENBQUNDLE1BQU0sQ0FBQztnQkFDcERDLFdBQVc7b0JBQ1RSO29CQUNBUyxJQUFJO3dCQUNGQyxNQUFNO3dCQUNOQyxJQUFJdEIsT0FBT3VCLFFBQVEsQ0FBQ0MsUUFBUTtvQkFDOUI7b0JBQ0FDLE1BQU07d0JBQ0pILElBQUksSUFBSUksY0FBY0MsTUFBTSxDQUFDOUI7d0JBQzdCd0IsTUFBTXhCO3dCQUNOK0IsYUFBYS9CO29CQUNmO29CQUNBZ0Msa0JBQWtCO3dCQUNoQjs0QkFBRUMsTUFBTTs0QkFBY0MsS0FBSyxDQUFDO3dCQUFFO3dCQUM5Qjs0QkFBRUQsTUFBTTs0QkFBY0MsS0FBSyxDQUFDO3dCQUFJO3FCQUNqQztvQkFDREMsd0JBQXdCO3dCQUN0QkMseUJBQXlCO3dCQUN6QkMsa0JBQWtCO3dCQUNsQkMsYUFBYTtvQkFDZjtvQkFDQUMsU0FBUztvQkFDVEMsYUFBYTtnQkFDZjtZQUNGO1lBRUEsSUFBSSxDQUFDdEIsWUFBWTtnQkFDZixNQUFNLElBQUliLE1BQU07WUFDbEI7WUFFQUosUUFBUUMsR0FBRyxDQUFFO1lBRWIsT0FBTztnQkFDTFUsU0FBUztnQkFDVDZCLGNBQWN2QixXQUFXTyxFQUFFO2dCQUMzQkgsV0FBVyxJQUFJLENBQUNvQixtQkFBbUIsQ0FBQ3hCLFdBQVd5QixRQUFRLENBQUNyQixTQUFTLElBQUksSUFBSXNCLFlBQVk7WUFDdkY7UUFDRixFQUFFLE9BQU9qQyxPQUFPO1lBQ2RWLFFBQVFVLEtBQUssQ0FBQywwQ0FBMENBO1lBQ3hELE9BQU87Z0JBQ0xDLFNBQVM7Z0JBQ1RELE9BQU9BLGlCQUFpQk4sUUFBUU0sTUFBTUUsT0FBTyxHQUFHO1lBQ2xEO1FBQ0Y7SUFDRjtJQUVBOztHQUVDLEdBQ0QsTUFBY0osbUNBQW1DZ0MsWUFBb0IsRUFBZ0M7UUFDbkcsSUFBSTtZQUNGeEMsUUFBUUMsR0FBRyxDQUFDLHlEQUE0RCxPQUFidUM7WUFFM0QsTUFBTTNCLFlBQVksSUFBSUMsV0FBVztZQUNqQ0MsT0FBT0MsZUFBZSxDQUFDSDtZQUV2QixNQUFNK0IsWUFBWSxNQUFNMUIsVUFBVUMsV0FBVyxDQUFDMEIsR0FBRyxDQUFDO2dCQUNoRHhCLFdBQVc7b0JBQ1RSO29CQUNBaUMsa0JBQWtCO3dCQUFDOzRCQUNqQmQsTUFBTTs0QkFDTlIsSUFBSSxJQUFJLENBQUN1QixtQkFBbUIsQ0FBQ1A7d0JBQy9CO3FCQUFFO29CQUNGSixrQkFBa0I7b0JBQ2xCRSxTQUFTO2dCQUNYO1lBQ0Y7WUFFQSxJQUFJLENBQUNNLFdBQVc7Z0JBQ2QsTUFBTSxJQUFJeEMsTUFBTTtZQUNsQjtZQUVBSixRQUFRQyxHQUFHLENBQUU7WUFFYixPQUFPO2dCQUNMVSxTQUFTO2dCQUNUNkIsY0FBY0ksVUFBVXBCLEVBQUU7Z0JBQzFCd0IsV0FBVyxJQUFJLENBQUNQLG1CQUFtQixDQUFDRyxVQUFVRixRQUFRLENBQUNNLFNBQVM7WUFDbEU7UUFDRixFQUFFLE9BQU90QyxPQUFPO1lBQ2RWLFFBQVFVLEtBQUssQ0FBQyxzREFBc0RBO1lBQ3BFLE9BQU87Z0JBQ0xDLFNBQVM7Z0JBQ1RELE9BQU9BLGlCQUFpQk4sUUFBUU0sTUFBTUUsT0FBTyxHQUFHO1lBQ2xEO1FBQ0Y7SUFDRjtJQUVBOztHQUVDLEdBQ0QsTUFBY04sdUJBQXVCUCxRQUFnQixFQUFxQjtRQUN4RSxJQUFJO1lBQ0YsMkRBQTJEO1lBQzNELG9DQUFvQztZQUNwQyxNQUFNa0Qsb0JBQW9CQyxhQUFhQyxPQUFPLENBQUMsdUJBQWdDLE9BQVRwRDtZQUN0RSxPQUFPa0Qsb0JBQW9CRyxLQUFLQyxLQUFLLENBQUNKLHFCQUFxQixFQUFFO1FBQy9ELEVBQUUsT0FBT3ZDLE9BQU87WUFDZFYsUUFBUVUsS0FBSyxDQUFDLHlDQUF5Q0E7WUFDdkQsT0FBTyxFQUFFO1FBQ1g7SUFDRjtJQUVBOztHQUVDLEdBQ0Qsa0JBQTBCWCxRQUFnQixFQUFFeUMsWUFBb0IsRUFBUTtRQUN0RSxJQUFJO1lBQ0YsTUFBTW5DLHNCQUFzQixJQUFJLENBQUNDLHNCQUFzQixDQUFDUDtZQUN4RCxJQUFJLENBQUNNLG9CQUFvQmtELFFBQVEsQ0FBQ2YsZUFBZTtnQkFDL0NuQyxvQkFBb0JtRCxJQUFJLENBQUNoQjtnQkFDekJVLGFBQWFPLE9BQU8sQ0FBQyx1QkFBZ0MsT0FBVDFELFdBQVlxRCxLQUFLTSxTQUFTLENBQUNyRDtZQUN6RTtRQUNGLEVBQUUsT0FBT0ssT0FBTztZQUNkVixRQUFRVSxLQUFLLENBQUMsb0NBQW9DQTtRQUNwRDtJQUNGO0lBRUE7OztHQUdDLEdBQ0QsTUFBTWlELHNCQUFzQjVELFFBQWdCLEVBQUU2RCxJQUF3QixFQUF1QjtRQUMzRixJQUFJO1lBQ0Y1RCxRQUFRQyxHQUFHLENBQUMscURBQW9ERixPQUFUNkQsTUFBSyxNQUFhLE9BQVQ3RDtZQUVoRSxrQ0FBa0M7WUFDbEMsTUFBTThELGFBQWEsTUFBTSxJQUFJLENBQUMvRCx1QkFBdUIsQ0FBQ0M7WUFFdEQsSUFBSSxDQUFDOEQsV0FBV2xELE9BQU8sRUFBRTtnQkFDdkIsTUFBTSxJQUFJUCxNQUFNLG9DQUFxRCxPQUFqQnlELFdBQVduRCxLQUFLO1lBQ3RFO1lBRUEscUNBQXFDO1lBQ3JDLElBQUltRCxXQUFXckIsWUFBWSxFQUFFO2dCQUMzQixJQUFJLENBQUNjLGlCQUFpQixDQUFDdkQsVUFBVThELFdBQVdyQixZQUFZO1lBQzFEO1lBRUEsd0ZBQXdGO1lBQ3hGLE1BQU1zQixVQUFVLElBQUksQ0FBQ0Msc0JBQXNCLENBQUNGLFdBQVdyQixZQUFZLElBQUl6QztZQUV2RSxpR0FBaUc7WUFDakcsTUFBTWlFLGFBQWEsTUFBTSxJQUFJLENBQUNDLGlCQUFpQixDQUFDSCxTQUFTL0QsVUFBVTZEO1lBRW5FLElBQUksQ0FBQ00sVUFBVSxHQUFHO2dCQUNoQkMsU0FBU0wsUUFBUXpDLFNBQVM7Z0JBQzFCMkMsWUFBWUE7Z0JBQ1pJLGFBQWE7WUFDZjtZQUVBcEUsUUFBUUMsR0FBRyxDQUFFO1lBQ2JELFFBQVFDLEdBQUcsQ0FBQyx5QkFBdUMsT0FBeEIsSUFBSSxDQUFDaUUsVUFBVSxDQUFDQyxPQUFPO1lBQ2xEbkUsUUFBUUMsR0FBRyxDQUFDLDZCQUE4QyxPQUEzQixJQUFJLENBQUNpRSxVQUFVLENBQUNGLFVBQVU7WUFFekQsT0FBTyxJQUFJLENBQUNFLFVBQVU7UUFDeEIsRUFBRSxPQUFPeEQsT0FBTztZQUNkVixRQUFRVSxLQUFLLENBQUMsc0NBQXNDQTtZQUNwRCxNQUFNQTtRQUNSO0lBQ0Y7SUFFQTs7O0dBR0MsR0FDRCxNQUFNMkQsMkJBQTJCQyxXQUF3QixFQUFFdkUsUUFBZ0IsRUFBd0I7UUFDakcsSUFBSTtZQUNGQyxRQUFRQyxHQUFHLENBQUMsNENBQXFELE9BQVRGO1lBRXhELGtDQUFrQztZQUNsQyxNQUFNOEQsYUFBYSxNQUFNLElBQUksQ0FBQy9ELHVCQUF1QixDQUFDQztZQUV0RCxJQUFJLENBQUM4RCxXQUFXbEQsT0FBTyxFQUFFO2dCQUN2QixNQUFNLElBQUlQLE1BQU0sb0NBQXFELE9BQWpCeUQsV0FBV25ELEtBQUs7WUFDdEU7WUFFQSx3RkFBd0Y7WUFDeEYsOENBQThDO1lBQzlDVixRQUFRQyxHQUFHLENBQUU7WUFFYixPQUFPcUU7UUFDVCxFQUFFLE9BQU81RCxPQUFPO1lBQ2RWLFFBQVFVLEtBQUssQ0FBQyw4Q0FBOENBO1lBQzVELE1BQU1BO1FBQ1I7SUFDRjtJQUVBOztHQUVDLEdBQ0QsdUJBQStCNkQsSUFBWSxFQUFPO1FBQ2hELGlFQUFpRTtRQUNqRSxnREFBZ0Q7UUFDaEQsTUFBTUMsT0FBTyxJQUFJNUMsY0FBY0MsTUFBTSxDQUFDMEM7UUFDdEMsTUFBTVQsVUFBVTtZQUNkekMsV0FBVyxJQUFNLElBQTBCLE9BQXRCa0QsS0FBS0UsU0FBUyxDQUFDLEdBQUc7WUFDdkNDLFFBQVEsSUFBTSxJQUEwQixPQUF0QkgsS0FBS0UsU0FBUyxDQUFDLEdBQUc7UUFDdEM7UUFDQSxPQUFPWDtJQUNUO0lBRUE7O0dBRUMsR0FDRCxNQUFjRyxrQkFBa0JILE9BQVksRUFBRS9ELFFBQWdCLEVBQUU2RCxJQUFZLEVBQW1CO1FBQzdGLDhFQUE4RTtRQUM5RSwyQ0FBMkM7UUFDM0MsTUFBTUksYUFBYSxLQUEyQmpFLE9BQXRCNkQsS0FBS2UsV0FBVyxJQUFHLEtBQW9DQyxPQUFqQzdFLFNBQVM4RSxPQUFPLENBQUMsUUFBUSxNQUFLLEtBQWMsT0FBWEQsS0FBS0UsR0FBRztRQUN2RjlFLFFBQVFDLEdBQUcsQ0FBQyxnREFBaUQsT0FBWCtEO1FBQ2xELE9BQU9BO0lBQ1Q7SUFFQTs7R0FFQyxHQUNELG9CQUE0QmUsTUFBbUIsRUFBVTtRQUN2RCxNQUFNQyxRQUFRLElBQUlsRSxXQUFXaUU7UUFDN0IsSUFBSUUsU0FBUztRQUNiLElBQUssSUFBSUMsSUFBSSxHQUFHQSxJQUFJRixNQUFNRyxVQUFVLEVBQUVELElBQUs7WUFDekNELFVBQVVHLE9BQU9DLFlBQVksQ0FBQ0wsS0FBSyxDQUFDRSxFQUFFO1FBQ3hDO1FBQ0EsT0FBT0ksS0FBS0w7SUFDZDtJQUVRbEMsb0JBQW9Cd0MsTUFBYyxFQUFlO1FBQ3ZELE1BQU1OLFNBQVNPLEtBQUtEO1FBQ3BCLE1BQU1QLFFBQVEsSUFBSWxFLFdBQVdtRSxPQUFPMUUsTUFBTTtRQUMxQyxJQUFLLElBQUkyRSxJQUFJLEdBQUdBLElBQUlELE9BQU8xRSxNQUFNLEVBQUUyRSxJQUFLO1lBQ3RDRixLQUFLLENBQUNFLEVBQUUsR0FBR0QsT0FBT1EsVUFBVSxDQUFDUDtRQUMvQjtRQUNBLE9BQU9GLE1BQU1ELE1BQU07SUFDckI7SUFFQTs7R0FFQyxHQUNEVyxnQkFBbUM7UUFDakMsT0FBTyxJQUFJLENBQUN4QixVQUFVO0lBQ3hCO0lBRUE7O0dBRUMsR0FDRHlCLGFBQW1CO1FBQ2pCLElBQUksQ0FBQ3pCLFVBQVUsR0FBRztRQUNsQmxFLFFBQVFDLEdBQUcsQ0FBQztJQUNkO0lBcFNBMkYsWUFBWUMsTUFBeUIsQ0FBRTthQUYvQjNCLGFBQWdDO1FBR3RDLElBQUksQ0FBQzJCLE1BQU0sR0FBR0E7SUFDaEI7QUFtU0Y7QUFFQSxrREFBa0Q7QUFDM0MsU0FBU0MsMkJBQTJCRCxNQUF5QjtJQUNsRSxPQUFPLElBQUloRyxxQkFBcUJnRztBQUNsQztBQUVBLHdCQUF3QjtBQUNqQixTQUFTRTtJQUNkLE9BQU87UUFDTEMsUUFBUUMsT0FBT0EsQ0FBQ0MsR0FBRyxDQUFDQyxtQkFBbUIsSUFBSTtRQUMzQ0MsbUJBQW1CSCxPQUFPQSxDQUFDQyxHQUFHLENBQUNHLDhCQUE4QixJQUFJO1FBQ2pFQyxtQkFBbUJMLE9BQU9BLENBQUNDLEdBQUcsQ0FBQ0ssK0JBQStCLElBQUk7SUFDcEU7QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9saWIvcGFzc2tleS1hdXRoLnRzPzdmM2EiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gUmVhbCBQYXNza2V5IEF1dGhlbnRpY2F0aW9uIEltcGxlbWVudGF0aW9uXG4vLyBGb2xsb3dpbmcgdGhlIGNvbXBsZXRlIGZsb3cgZGlhZ3JhbSBmcm9tIHRoZSBkb2N1bWVudGF0aW9uXG5cbmltcG9ydCB7IENvbnRyYWN0LCBTb3JvYmFuUnBjLCBOZXR3b3JrcywgVHJhbnNhY3Rpb24sIEJBU0VfRkVFIH0gZnJvbSAnQHN0ZWxsYXIvc3RlbGxhci1zZGsnXG5cbmV4cG9ydCBpbnRlcmZhY2UgUGFzc2tleUF1dGhDb25maWcge1xuICBycGNVcmw6IHN0cmluZ1xuICBuZXR3b3JrUGFzc3BocmFzZTogc3RyaW5nXG4gIGZhY3RvcnlDb250cmFjdElkOiBzdHJpbmdcbn1cblxuZXhwb3J0IGludGVyZmFjZSBCaW9tZXRyaWNBdXRoUmVzdWx0IHtcbiAgc3VjY2VzczogYm9vbGVhblxuICBjcmVkZW50aWFsSWQ/OiBzdHJpbmdcbiAgcHVibGljS2V5Pzogc3RyaW5nXG4gIHNpZ25hdHVyZT86IHN0cmluZ1xuICBlcnJvcj86IHN0cmluZ1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFdhbGxldEluZm8ge1xuICBhZGRyZXNzOiBzdHJpbmdcbiAgY29udHJhY3RJZDogc3RyaW5nXG4gIGlzQ29ubmVjdGVkOiBib29sZWFuXG59XG5cbmV4cG9ydCBjbGFzcyBQYXNza2V5QXV0aGVudGljYXRvciB7XG4gIHByaXZhdGUgY29uZmlnOiBQYXNza2V5QXV0aENvbmZpZ1xuICBwcml2YXRlIHdhbGxldEluZm86IFdhbGxldEluZm8gfCBudWxsID0gbnVsbFxuXG4gIGNvbnN0cnVjdG9yKGNvbmZpZzogUGFzc2tleUF1dGhDb25maWcpIHtcbiAgICB0aGlzLmNvbmZpZyA9IGNvbmZpZ1xuICB9XG5cbiAgLyoqXG4gICAqIFN0ZXAgMTogQXV0aGVudGljYXRlIHdpdGggUGFzc2tleSAoYmlvbWV0cmljKVxuICAgKiBUaGlzIGlzIHRoZSBjb3JlIGJpb21ldHJpYyBhdXRoZW50aWNhdGlvbiBzdGVwIGZyb20gdGhlIGZsb3cgZGlhZ3JhbVxuICAgKi9cbiAgYXN5bmMgYXV0aGVudGljYXRlV2l0aFBhc3NrZXkodXNlck5hbWU6IHN0cmluZyk6IFByb21pc2U8QmlvbWV0cmljQXV0aFJlc3VsdD4ge1xuICAgIHRyeSB7XG4gICAgICBjb25zb2xlLmxvZyhg8J+UkCBTdGFydGluZyBiaW9tZXRyaWMgYXV0aGVudGljYXRpb24gZm9yOiAke3VzZXJOYW1lfWApXG4gICAgICBcbiAgICAgIC8vIENoZWNrIGlmIFdlYkF1dGhuIGlzIHN1cHBvcnRlZFxuICAgICAgaWYgKCF3aW5kb3cuUHVibGljS2V5Q3JlZGVudGlhbCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1dlYkF1dGhuL1Bhc3NrZXlzIG5vdCBzdXBwb3J0ZWQgaW4gdGhpcyBicm93c2VyJylcbiAgICAgIH1cblxuICAgICAgLy8gQ2hlY2sgaWYgdXNlciBoYXMgZXhpc3RpbmcgY3JlZGVudGlhbHNcbiAgICAgIGNvbnN0IGV4aXN0aW5nQ3JlZGVudGlhbHMgPSBhd2FpdCB0aGlzLmdldEV4aXN0aW5nQ3JlZGVudGlhbHModXNlck5hbWUpXG4gICAgICBcbiAgICAgIGlmIChleGlzdGluZ0NyZWRlbnRpYWxzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgLy8gVXNlIGV4aXN0aW5nIGNyZWRlbnRpYWwgZm9yIGF1dGhlbnRpY2F0aW9uXG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLmF1dGhlbnRpY2F0ZVdpdGhFeGlzdGluZ0NyZWRlbnRpYWwoZXhpc3RpbmdDcmVkZW50aWFsc1swXSlcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIENyZWF0ZSBuZXcgY3JlZGVudGlhbFxuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5jcmVhdGVOZXdDcmVkZW50aWFsKHVzZXJOYW1lKVxuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCfinYwgQmlvbWV0cmljIGF1dGhlbnRpY2F0aW9uIGZhaWxlZDonLCBlcnJvcilcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHN1Y2Nlc3M6IGZhbHNlLFxuICAgICAgICBlcnJvcjogZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yLm1lc3NhZ2UgOiAnQXV0aGVudGljYXRpb24gZmFpbGVkJ1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgbmV3IHBhc3NrZXkgY3JlZGVudGlhbFxuICAgKi9cbiAgcHJpdmF0ZSBhc3luYyBjcmVhdGVOZXdDcmVkZW50aWFsKHVzZXJOYW1lOiBzdHJpbmcpOiBQcm9taXNlPEJpb21ldHJpY0F1dGhSZXN1bHQ+IHtcbiAgICB0cnkge1xuICAgICAgY29uc29sZS5sb2coYPCfhpUgQ3JlYXRpbmcgbmV3IHBhc3NrZXkgY3JlZGVudGlhbCBmb3I6ICR7dXNlck5hbWV9YClcbiAgICAgIFxuICAgICAgY29uc3QgY2hhbGxlbmdlID0gbmV3IFVpbnQ4QXJyYXkoMzIpXG4gICAgICBjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzKGNoYWxsZW5nZSlcblxuICAgICAgY29uc3QgY3JlZGVudGlhbCA9IGF3YWl0IG5hdmlnYXRvci5jcmVkZW50aWFscy5jcmVhdGUoe1xuICAgICAgICBwdWJsaWNLZXk6IHtcbiAgICAgICAgICBjaGFsbGVuZ2UsXG4gICAgICAgICAgcnA6IHtcbiAgICAgICAgICAgIG5hbWU6IFwiU3RlbGxhciBQcm9jdXJlbWVudCBkQXBwXCIsXG4gICAgICAgICAgICBpZDogd2luZG93LmxvY2F0aW9uLmhvc3RuYW1lLFxuICAgICAgICAgIH0sXG4gICAgICAgICAgdXNlcjoge1xuICAgICAgICAgICAgaWQ6IG5ldyBUZXh0RW5jb2RlcigpLmVuY29kZSh1c2VyTmFtZSksXG4gICAgICAgICAgICBuYW1lOiB1c2VyTmFtZSxcbiAgICAgICAgICAgIGRpc3BsYXlOYW1lOiB1c2VyTmFtZSxcbiAgICAgICAgICB9LFxuICAgICAgICAgIHB1YktleUNyZWRQYXJhbXM6IFtcbiAgICAgICAgICAgIHsgdHlwZTogXCJwdWJsaWMta2V5XCIsIGFsZzogLTcgfSwgLy8gRVMyNTZcbiAgICAgICAgICAgIHsgdHlwZTogXCJwdWJsaWMta2V5XCIsIGFsZzogLTI1NyB9LCAvLyBSUzI1NlxuICAgICAgICAgIF0sXG4gICAgICAgICAgYXV0aGVudGljYXRvclNlbGVjdGlvbjoge1xuICAgICAgICAgICAgYXV0aGVudGljYXRvckF0dGFjaG1lbnQ6IFwicGxhdGZvcm1cIiwgLy8gQnVpbHQtaW4gYXV0aGVudGljYXRvcnNcbiAgICAgICAgICAgIHVzZXJWZXJpZmljYXRpb246IFwicmVxdWlyZWRcIixcbiAgICAgICAgICAgIHJlc2lkZW50S2V5OiBcInJlcXVpcmVkXCIsXG4gICAgICAgICAgfSxcbiAgICAgICAgICB0aW1lb3V0OiA2MDAwMCxcbiAgICAgICAgICBhdHRlc3RhdGlvbjogXCJkaXJlY3RcIixcbiAgICAgICAgfSxcbiAgICAgIH0pIGFzIFB1YmxpY0tleUNyZWRlbnRpYWxcblxuICAgICAgaWYgKCFjcmVkZW50aWFsKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignRmFpbGVkIHRvIGNyZWF0ZSBwYXNza2V5IGNyZWRlbnRpYWwnKVxuICAgICAgfVxuXG4gICAgICBjb25zb2xlLmxvZyhg4pyFIE5ldyBwYXNza2V5IGNyZWRlbnRpYWwgY3JlYXRlZCBzdWNjZXNzZnVsbHlgKVxuICAgICAgXG4gICAgICByZXR1cm4ge1xuICAgICAgICBzdWNjZXNzOiB0cnVlLFxuICAgICAgICBjcmVkZW50aWFsSWQ6IGNyZWRlbnRpYWwuaWQsXG4gICAgICAgIHB1YmxpY0tleTogdGhpcy5hcnJheUJ1ZmZlclRvQmFzZTY0KGNyZWRlbnRpYWwucmVzcG9uc2UucHVibGljS2V5IHx8IG5ldyBBcnJheUJ1ZmZlcigwKSlcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcign4p2MIEZhaWxlZCB0byBjcmVhdGUgcGFzc2tleSBjcmVkZW50aWFsOicsIGVycm9yKVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgc3VjY2VzczogZmFsc2UsXG4gICAgICAgIGVycm9yOiBlcnJvciBpbnN0YW5jZW9mIEVycm9yID8gZXJyb3IubWVzc2FnZSA6ICdDcmVkZW50aWFsIGNyZWF0aW9uIGZhaWxlZCdcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQXV0aGVudGljYXRlIHdpdGggZXhpc3RpbmcgY3JlZGVudGlhbFxuICAgKi9cbiAgcHJpdmF0ZSBhc3luYyBhdXRoZW50aWNhdGVXaXRoRXhpc3RpbmdDcmVkZW50aWFsKGNyZWRlbnRpYWxJZDogc3RyaW5nKTogUHJvbWlzZTxCaW9tZXRyaWNBdXRoUmVzdWx0PiB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnNvbGUubG9nKGDwn5SRIEF1dGhlbnRpY2F0aW5nIHdpdGggZXhpc3RpbmcgY3JlZGVudGlhbDogJHtjcmVkZW50aWFsSWR9YClcbiAgICAgIFxuICAgICAgY29uc3QgY2hhbGxlbmdlID0gbmV3IFVpbnQ4QXJyYXkoMzIpXG4gICAgICBjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzKGNoYWxsZW5nZSlcblxuICAgICAgY29uc3QgYXNzZXJ0aW9uID0gYXdhaXQgbmF2aWdhdG9yLmNyZWRlbnRpYWxzLmdldCh7XG4gICAgICAgIHB1YmxpY0tleToge1xuICAgICAgICAgIGNoYWxsZW5nZSxcbiAgICAgICAgICBhbGxvd0NyZWRlbnRpYWxzOiBbe1xuICAgICAgICAgICAgdHlwZTogJ3B1YmxpYy1rZXknLFxuICAgICAgICAgICAgaWQ6IHRoaXMuYmFzZTY0VG9BcnJheUJ1ZmZlcihjcmVkZW50aWFsSWQpLFxuICAgICAgICAgIH1dLFxuICAgICAgICAgIHVzZXJWZXJpZmljYXRpb246IFwicmVxdWlyZWRcIixcbiAgICAgICAgICB0aW1lb3V0OiA2MDAwMCxcbiAgICAgICAgfSxcbiAgICAgIH0pIGFzIFB1YmxpY0tleUNyZWRlbnRpYWxcblxuICAgICAgaWYgKCFhc3NlcnRpb24pIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdGYWlsZWQgdG8gYXV0aGVudGljYXRlIHdpdGggcGFzc2tleScpXG4gICAgICB9XG5cbiAgICAgIGNvbnNvbGUubG9nKGDinIUgQmlvbWV0cmljIGF1dGhlbnRpY2F0aW9uIHN1Y2Nlc3NmdWxgKVxuICAgICAgXG4gICAgICByZXR1cm4ge1xuICAgICAgICBzdWNjZXNzOiB0cnVlLFxuICAgICAgICBjcmVkZW50aWFsSWQ6IGFzc2VydGlvbi5pZCxcbiAgICAgICAgc2lnbmF0dXJlOiB0aGlzLmFycmF5QnVmZmVyVG9CYXNlNjQoYXNzZXJ0aW9uLnJlc3BvbnNlLnNpZ25hdHVyZSlcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcign4p2MIEZhaWxlZCB0byBhdXRoZW50aWNhdGUgd2l0aCBleGlzdGluZyBjcmVkZW50aWFsOicsIGVycm9yKVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgc3VjY2VzczogZmFsc2UsXG4gICAgICAgIGVycm9yOiBlcnJvciBpbnN0YW5jZW9mIEVycm9yID8gZXJyb3IubWVzc2FnZSA6ICdBdXRoZW50aWNhdGlvbiBmYWlsZWQnXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEdldCBleGlzdGluZyBjcmVkZW50aWFscyBmb3IgYSB1c2VyXG4gICAqL1xuICBwcml2YXRlIGFzeW5jIGdldEV4aXN0aW5nQ3JlZGVudGlhbHModXNlck5hbWU6IHN0cmluZyk6IFByb21pc2U8c3RyaW5nW10+IHtcbiAgICB0cnkge1xuICAgICAgLy8gSW4gYSByZWFsIGltcGxlbWVudGF0aW9uLCB5b3Ugd291bGQgc3RvcmUgY3JlZGVudGlhbCBJRHNcbiAgICAgIC8vIEZvciBub3csIHdlJ2xsIGNoZWNrIGxvY2FsU3RvcmFnZVxuICAgICAgY29uc3Qgc3RvcmVkQ3JlZGVudGlhbHMgPSBsb2NhbFN0b3JhZ2UuZ2V0SXRlbShgcGFzc2tleV9jcmVkZW50aWFsc18ke3VzZXJOYW1lfWApXG4gICAgICByZXR1cm4gc3RvcmVkQ3JlZGVudGlhbHMgPyBKU09OLnBhcnNlKHN0b3JlZENyZWRlbnRpYWxzKSA6IFtdXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ+KdjCBGYWlsZWQgdG8gZ2V0IGV4aXN0aW5nIGNyZWRlbnRpYWxzOicsIGVycm9yKVxuICAgICAgcmV0dXJuIFtdXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFN0b3JlIGNyZWRlbnRpYWwgSUQgZm9yIGZ1dHVyZSB1c2VcbiAgICovXG4gIHByaXZhdGUgc3RvcmVDcmVkZW50aWFsSWQodXNlck5hbWU6IHN0cmluZywgY3JlZGVudGlhbElkOiBzdHJpbmcpOiB2b2lkIHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgZXhpc3RpbmdDcmVkZW50aWFscyA9IHRoaXMuZ2V0RXhpc3RpbmdDcmVkZW50aWFscyh1c2VyTmFtZSlcbiAgICAgIGlmICghZXhpc3RpbmdDcmVkZW50aWFscy5pbmNsdWRlcyhjcmVkZW50aWFsSWQpKSB7XG4gICAgICAgIGV4aXN0aW5nQ3JlZGVudGlhbHMucHVzaChjcmVkZW50aWFsSWQpXG4gICAgICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKGBwYXNza2V5X2NyZWRlbnRpYWxzXyR7dXNlck5hbWV9YCwgSlNPTi5zdHJpbmdpZnkoZXhpc3RpbmdDcmVkZW50aWFscykpXG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ+KdjCBGYWlsZWQgdG8gc3RvcmUgY3JlZGVudGlhbCBJRDonLCBlcnJvcilcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogU3RlcCAyOiBDcmVhdGUgb3IgY29ubmVjdCB0byBTdGVsbGFyIHNtYXJ0IHdhbGxldFxuICAgKiBUaGlzIGZvbGxvd3MgdGhlIFwiUGFzc2tleS1LaXQgc2lnbnMgdHJhbnNhY3Rpb25cIiBzdGVwIGZyb20gdGhlIGZsb3dcbiAgICovXG4gIGFzeW5jIGNyZWF0ZU9yQ29ubmVjdFdhbGxldCh1c2VyTmFtZTogc3RyaW5nLCByb2xlOiAnYnV5ZXInIHwgJ3NlbGxlcicpOiBQcm9taXNlPFdhbGxldEluZm8+IHtcbiAgICB0cnkge1xuICAgICAgY29uc29sZS5sb2coYPCfj6YgQ3JlYXRpbmcvY29ubmVjdGluZyBzbWFydCB3YWxsZXQgZm9yICR7cm9sZX06ICR7dXNlck5hbWV9YClcbiAgICAgIFxuICAgICAgLy8gRmlyc3QgYXV0aGVudGljYXRlIHdpdGggcGFzc2tleVxuICAgICAgY29uc3QgYXV0aFJlc3VsdCA9IGF3YWl0IHRoaXMuYXV0aGVudGljYXRlV2l0aFBhc3NrZXkodXNlck5hbWUpXG4gICAgICBcbiAgICAgIGlmICghYXV0aFJlc3VsdC5zdWNjZXNzKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgQmlvbWV0cmljIGF1dGhlbnRpY2F0aW9uIGZhaWxlZDogJHthdXRoUmVzdWx0LmVycm9yfWApXG4gICAgICB9XG5cbiAgICAgIC8vIFN0b3JlIGNyZWRlbnRpYWwgSUQgZm9yIGZ1dHVyZSB1c2VcbiAgICAgIGlmIChhdXRoUmVzdWx0LmNyZWRlbnRpYWxJZCkge1xuICAgICAgICB0aGlzLnN0b3JlQ3JlZGVudGlhbElkKHVzZXJOYW1lLCBhdXRoUmVzdWx0LmNyZWRlbnRpYWxJZClcbiAgICAgIH1cblxuICAgICAgLy8gR2VuZXJhdGUgU3RlbGxhciBrZXlwYWlyIChpbiByZWFsIGltcGxlbWVudGF0aW9uLCB0aGlzIHdvdWxkIGJlIGRlcml2ZWQgZnJvbSBwYXNza2V5KVxuICAgICAgY29uc3Qga2V5cGFpciA9IHRoaXMuZ2VuZXJhdGVTdGVsbGFyS2V5cGFpcihhdXRoUmVzdWx0LmNyZWRlbnRpYWxJZCB8fCB1c2VyTmFtZSlcbiAgICAgIFxuICAgICAgLy8gQ3JlYXRlIHNtYXJ0IHdhbGxldCBjb250cmFjdCAoc2ltcGxpZmllZCAtIGluIHJlYWwgaW1wbGVtZW50YXRpb24sIHRoaXMgd291bGQgdXNlIFBhc3NrZXktS2l0KVxuICAgICAgY29uc3QgY29udHJhY3RJZCA9IGF3YWl0IHRoaXMuZGVwbG95U21hcnRXYWxsZXQoa2V5cGFpciwgdXNlck5hbWUsIHJvbGUpXG4gICAgICBcbiAgICAgIHRoaXMud2FsbGV0SW5mbyA9IHtcbiAgICAgICAgYWRkcmVzczoga2V5cGFpci5wdWJsaWNLZXkoKSxcbiAgICAgICAgY29udHJhY3RJZDogY29udHJhY3RJZCxcbiAgICAgICAgaXNDb25uZWN0ZWQ6IHRydWVcbiAgICAgIH1cblxuICAgICAgY29uc29sZS5sb2coYOKchSBTbWFydCB3YWxsZXQgY3JlYXRlZC9jb25uZWN0ZWQgc3VjY2Vzc2Z1bGx5YClcbiAgICAgIGNvbnNvbGUubG9nKGDwn5ONIEFkZHJlc3M6ICR7dGhpcy53YWxsZXRJbmZvLmFkZHJlc3N9YClcbiAgICAgIGNvbnNvbGUubG9nKGDwn5OEIENvbnRyYWN0IElEOiAke3RoaXMud2FsbGV0SW5mby5jb250cmFjdElkfWApXG4gICAgICBcbiAgICAgIHJldHVybiB0aGlzLndhbGxldEluZm9cbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcign4p2MIEZhaWxlZCB0byBjcmVhdGUvY29ubmVjdCB3YWxsZXQ6JywgZXJyb3IpXG4gICAgICB0aHJvdyBlcnJvclxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBTdGVwIDM6IFNpZ24gdHJhbnNhY3Rpb24gd2l0aCBwYXNza2V5XG4gICAqIFRoaXMgaXMgdGhlIFwiUGFzc2tleS1LaXQgc2lnbnMgdHJhbnNhY3Rpb25cIiBzdGVwIGZyb20gdGhlIGZsb3dcbiAgICovXG4gIGFzeW5jIHNpZ25UcmFuc2FjdGlvbldpdGhQYXNza2V5KHRyYW5zYWN0aW9uOiBUcmFuc2FjdGlvbiwgdXNlck5hbWU6IHN0cmluZyk6IFByb21pc2U8VHJhbnNhY3Rpb24+IHtcbiAgICB0cnkge1xuICAgICAgY29uc29sZS5sb2coYOKcje+4jyBTaWduaW5nIHRyYW5zYWN0aW9uIHdpdGggcGFzc2tleSBmb3I6ICR7dXNlck5hbWV9YClcbiAgICAgIFxuICAgICAgLy8gQXV0aGVudGljYXRlIHdpdGggcGFzc2tleSBmaXJzdFxuICAgICAgY29uc3QgYXV0aFJlc3VsdCA9IGF3YWl0IHRoaXMuYXV0aGVudGljYXRlV2l0aFBhc3NrZXkodXNlck5hbWUpXG4gICAgICBcbiAgICAgIGlmICghYXV0aFJlc3VsdC5zdWNjZXNzKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgQmlvbWV0cmljIGF1dGhlbnRpY2F0aW9uIGZhaWxlZDogJHthdXRoUmVzdWx0LmVycm9yfWApXG4gICAgICB9XG5cbiAgICAgIC8vIEluIGEgcmVhbCBpbXBsZW1lbnRhdGlvbiwgeW91IHdvdWxkIHVzZSB0aGUgcGFzc2tleSBzaWduYXR1cmUgdG8gc2lnbiB0aGUgdHJhbnNhY3Rpb25cbiAgICAgIC8vIEZvciBub3csIHdlJ2xsIHNpbXVsYXRlIHRoZSBzaWduaW5nIHByb2Nlc3NcbiAgICAgIGNvbnNvbGUubG9nKGDinIUgVHJhbnNhY3Rpb24gc2lnbmVkIHdpdGggcGFzc2tleSBzdWNjZXNzZnVsbHlgKVxuICAgICAgXG4gICAgICByZXR1cm4gdHJhbnNhY3Rpb25cbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcign4p2MIEZhaWxlZCB0byBzaWduIHRyYW5zYWN0aW9uIHdpdGggcGFzc2tleTonLCBlcnJvcilcbiAgICAgIHRocm93IGVycm9yXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEdlbmVyYXRlIFN0ZWxsYXIga2V5cGFpciAoc2ltcGxpZmllZCBpbXBsZW1lbnRhdGlvbilcbiAgICovXG4gIHByaXZhdGUgZ2VuZXJhdGVTdGVsbGFyS2V5cGFpcihzZWVkOiBzdHJpbmcpOiBhbnkge1xuICAgIC8vIEluIGEgcmVhbCBpbXBsZW1lbnRhdGlvbiwgdGhpcyB3b3VsZCB1c2UgcHJvcGVyIGtleSBkZXJpdmF0aW9uXG4gICAgLy8gRm9yIG5vdywgd2UnbGwgY3JlYXRlIGEgZGV0ZXJtaW5pc3RpYyBrZXlwYWlyXG4gICAgY29uc3QgaGFzaCA9IG5ldyBUZXh0RW5jb2RlcigpLmVuY29kZShzZWVkKVxuICAgIGNvbnN0IGtleXBhaXIgPSB7XG4gICAgICBwdWJsaWNLZXk6ICgpID0+IGBHJHtzZWVkLnN1YnN0cmluZygwLCA1NSl9YCxcbiAgICAgIHNlY3JldDogKCkgPT4gYFMke3NlZWQuc3Vic3RyaW5nKDAsIDU1KX1gXG4gICAgfVxuICAgIHJldHVybiBrZXlwYWlyXG4gIH1cblxuICAvKipcbiAgICogRGVwbG95IHNtYXJ0IHdhbGxldCBjb250cmFjdCAoc2ltcGxpZmllZCBpbXBsZW1lbnRhdGlvbilcbiAgICovXG4gIHByaXZhdGUgYXN5bmMgZGVwbG95U21hcnRXYWxsZXQoa2V5cGFpcjogYW55LCB1c2VyTmFtZTogc3RyaW5nLCByb2xlOiBzdHJpbmcpOiBQcm9taXNlPHN0cmluZz4ge1xuICAgIC8vIEluIGEgcmVhbCBpbXBsZW1lbnRhdGlvbiwgdGhpcyB3b3VsZCBkZXBsb3kgYW4gYWN0dWFsIHNtYXJ0IHdhbGxldCBjb250cmFjdFxuICAgIC8vIEZvciBub3csIHdlJ2xsIHJldHVybiBhIG1vY2sgY29udHJhY3QgSURcbiAgICBjb25zdCBjb250cmFjdElkID0gYENDJHtyb2xlLnRvVXBwZXJDYXNlKCl9XyR7dXNlck5hbWUucmVwbGFjZSgvXFxzKy9nLCAnXycpfV8ke0RhdGUubm93KCl9YFxuICAgIGNvbnNvbGUubG9nKGDwn5OEIFNtYXJ0IHdhbGxldCBjb250cmFjdCBkZXBsb3llZDogJHtjb250cmFjdElkfWApXG4gICAgcmV0dXJuIGNvbnRyYWN0SWRcbiAgfVxuXG4gIC8qKlxuICAgKiBVdGlsaXR5IGZ1bmN0aW9uc1xuICAgKi9cbiAgcHJpdmF0ZSBhcnJheUJ1ZmZlclRvQmFzZTY0KGJ1ZmZlcjogQXJyYXlCdWZmZXIpOiBzdHJpbmcge1xuICAgIGNvbnN0IGJ5dGVzID0gbmV3IFVpbnQ4QXJyYXkoYnVmZmVyKVxuICAgIGxldCBiaW5hcnkgPSAnJ1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYnl0ZXMuYnl0ZUxlbmd0aDsgaSsrKSB7XG4gICAgICBiaW5hcnkgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShieXRlc1tpXSlcbiAgICB9XG4gICAgcmV0dXJuIGJ0b2EoYmluYXJ5KVxuICB9XG5cbiAgcHJpdmF0ZSBiYXNlNjRUb0FycmF5QnVmZmVyKGJhc2U2NDogc3RyaW5nKTogQXJyYXlCdWZmZXIge1xuICAgIGNvbnN0IGJpbmFyeSA9IGF0b2IoYmFzZTY0KVxuICAgIGNvbnN0IGJ5dGVzID0gbmV3IFVpbnQ4QXJyYXkoYmluYXJ5Lmxlbmd0aClcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGJpbmFyeS5sZW5ndGg7IGkrKykge1xuICAgICAgYnl0ZXNbaV0gPSBiaW5hcnkuY2hhckNvZGVBdChpKVxuICAgIH1cbiAgICByZXR1cm4gYnl0ZXMuYnVmZmVyXG4gIH1cblxuICAvKipcbiAgICogR2V0IGN1cnJlbnQgd2FsbGV0IGluZm9cbiAgICovXG4gIGdldFdhbGxldEluZm8oKTogV2FsbGV0SW5mbyB8IG51bGwge1xuICAgIHJldHVybiB0aGlzLndhbGxldEluZm9cbiAgfVxuXG4gIC8qKlxuICAgKiBEaXNjb25uZWN0IHdhbGxldFxuICAgKi9cbiAgZGlzY29ubmVjdCgpOiB2b2lkIHtcbiAgICB0aGlzLndhbGxldEluZm8gPSBudWxsXG4gICAgY29uc29sZS5sb2coJ/CflIwgV2FsbGV0IGRpc2Nvbm5lY3RlZCcpXG4gIH1cbn1cblxuLy8gRmFjdG9yeSBmdW5jdGlvbiB0byBjcmVhdGUgUGFzc2tleUF1dGhlbnRpY2F0b3JcbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVQYXNza2V5QXV0aGVudGljYXRvcihjb25maWc6IFBhc3NrZXlBdXRoQ29uZmlnKTogUGFzc2tleUF1dGhlbnRpY2F0b3Ige1xuICByZXR1cm4gbmV3IFBhc3NrZXlBdXRoZW50aWNhdG9yKGNvbmZpZylcbn1cblxuLy8gRGVmYXVsdCBjb25maWd1cmF0aW9uXG5leHBvcnQgZnVuY3Rpb24gZ2V0RGVmYXVsdFBhc3NrZXlDb25maWcoKTogUGFzc2tleUF1dGhDb25maWcge1xuICByZXR1cm4ge1xuICAgIHJwY1VybDogcHJvY2Vzcy5lbnYuTkVYVF9QVUJMSUNfUlBDX1VSTCB8fCAnaHR0cHM6Ly9zb3JvYmFuLXRlc3RuZXQuc3RlbGxhci5vcmcnLFxuICAgIG5ldHdvcmtQYXNzcGhyYXNlOiBwcm9jZXNzLmVudi5ORVhUX1BVQkxJQ19ORVRXT1JLX1BBU1NQSFJBU0UgfHwgJ1Rlc3QgU0RGIE5ldHdvcmsgOyBTZXB0ZW1iZXIgMjAxNScsXG4gICAgZmFjdG9yeUNvbnRyYWN0SWQ6IHByb2Nlc3MuZW52Lk5FWFRfUFVCTElDX0ZBQ1RPUllfQ09OVFJBQ1RfSUQgfHwgJ0NDV0pGSjdZUUhaM1FIMkdRWVFaUVpRWlFaUVpRWlFaUVpRWlFaUVpRWlFaUVpRJ1xuICB9XG59XG4iXSwibmFtZXMiOlsiUGFzc2tleUF1dGhlbnRpY2F0b3IiLCJhdXRoZW50aWNhdGVXaXRoUGFzc2tleSIsInVzZXJOYW1lIiwiY29uc29sZSIsImxvZyIsIndpbmRvdyIsIlB1YmxpY0tleUNyZWRlbnRpYWwiLCJFcnJvciIsImV4aXN0aW5nQ3JlZGVudGlhbHMiLCJnZXRFeGlzdGluZ0NyZWRlbnRpYWxzIiwibGVuZ3RoIiwiYXV0aGVudGljYXRlV2l0aEV4aXN0aW5nQ3JlZGVudGlhbCIsImNyZWF0ZU5ld0NyZWRlbnRpYWwiLCJlcnJvciIsInN1Y2Nlc3MiLCJtZXNzYWdlIiwiY2hhbGxlbmdlIiwiVWludDhBcnJheSIsImNyeXB0byIsImdldFJhbmRvbVZhbHVlcyIsImNyZWRlbnRpYWwiLCJuYXZpZ2F0b3IiLCJjcmVkZW50aWFscyIsImNyZWF0ZSIsInB1YmxpY0tleSIsInJwIiwibmFtZSIsImlkIiwibG9jYXRpb24iLCJob3N0bmFtZSIsInVzZXIiLCJUZXh0RW5jb2RlciIsImVuY29kZSIsImRpc3BsYXlOYW1lIiwicHViS2V5Q3JlZFBhcmFtcyIsInR5cGUiLCJhbGciLCJhdXRoZW50aWNhdG9yU2VsZWN0aW9uIiwiYXV0aGVudGljYXRvckF0dGFjaG1lbnQiLCJ1c2VyVmVyaWZpY2F0aW9uIiwicmVzaWRlbnRLZXkiLCJ0aW1lb3V0IiwiYXR0ZXN0YXRpb24iLCJjcmVkZW50aWFsSWQiLCJhcnJheUJ1ZmZlclRvQmFzZTY0IiwicmVzcG9uc2UiLCJBcnJheUJ1ZmZlciIsImFzc2VydGlvbiIsImdldCIsImFsbG93Q3JlZGVudGlhbHMiLCJiYXNlNjRUb0FycmF5QnVmZmVyIiwic2lnbmF0dXJlIiwic3RvcmVkQ3JlZGVudGlhbHMiLCJsb2NhbFN0b3JhZ2UiLCJnZXRJdGVtIiwiSlNPTiIsInBhcnNlIiwic3RvcmVDcmVkZW50aWFsSWQiLCJpbmNsdWRlcyIsInB1c2giLCJzZXRJdGVtIiwic3RyaW5naWZ5IiwiY3JlYXRlT3JDb25uZWN0V2FsbGV0Iiwicm9sZSIsImF1dGhSZXN1bHQiLCJrZXlwYWlyIiwiZ2VuZXJhdGVTdGVsbGFyS2V5cGFpciIsImNvbnRyYWN0SWQiLCJkZXBsb3lTbWFydFdhbGxldCIsIndhbGxldEluZm8iLCJhZGRyZXNzIiwiaXNDb25uZWN0ZWQiLCJzaWduVHJhbnNhY3Rpb25XaXRoUGFzc2tleSIsInRyYW5zYWN0aW9uIiwic2VlZCIsImhhc2giLCJzdWJzdHJpbmciLCJzZWNyZXQiLCJ0b1VwcGVyQ2FzZSIsIkRhdGUiLCJyZXBsYWNlIiwibm93IiwiYnVmZmVyIiwiYnl0ZXMiLCJiaW5hcnkiLCJpIiwiYnl0ZUxlbmd0aCIsIlN0cmluZyIsImZyb21DaGFyQ29kZSIsImJ0b2EiLCJiYXNlNjQiLCJhdG9iIiwiY2hhckNvZGVBdCIsImdldFdhbGxldEluZm8iLCJkaXNjb25uZWN0IiwiY29uc3RydWN0b3IiLCJjb25maWciLCJjcmVhdGVQYXNza2V5QXV0aGVudGljYXRvciIsImdldERlZmF1bHRQYXNza2V5Q29uZmlnIiwicnBjVXJsIiwicHJvY2VzcyIsImVudiIsIk5FWFRfUFVCTElDX1JQQ19VUkwiLCJuZXR3b3JrUGFzc3BocmFzZSIsIk5FWFRfUFVCTElDX05FVFdPUktfUEFTU1BIUkFTRSIsImZhY3RvcnlDb250cmFjdElkIiwiTkVYVF9QVUJMSUNfRkFDVE9SWV9DT05UUkFDVF9JRCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./lib/passkey-auth.ts\n"));

/***/ })

});