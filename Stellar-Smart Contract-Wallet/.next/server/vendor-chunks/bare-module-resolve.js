/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/bare-module-resolve";
exports.ids = ["vendor-chunks/bare-module-resolve"];
exports.modules = {

/***/ "(ssr)/./node_modules/bare-module-resolve/index.js":
/*!***************************************************!*\
  !*** ./node_modules/bare-module-resolve/index.js ***!
  \***************************************************/
/***/ ((module, exports, __webpack_require__) => {

eval("const { satisfies } = __webpack_require__(/*! bare-semver */ \"(ssr)/./node_modules/bare-semver/index.js\")\nconst errors = __webpack_require__(/*! ./lib/errors */ \"(ssr)/./node_modules/bare-module-resolve/lib/errors.js\")\n\nmodule.exports = exports = function resolve(\n  specifier,\n  parentURL,\n  opts,\n  readPackage\n) {\n  if (typeof opts === 'function') {\n    readPackage = opts\n    opts = {}\n  } else if (typeof readPackage !== 'function') {\n    readPackage = defaultReadPackage\n  }\n\n  return {\n    *[Symbol.iterator]() {\n      const generator = exports.module(specifier, parentURL, opts)\n\n      let next = generator.next()\n\n      while (next.done !== true) {\n        const value = next.value\n\n        if (value.package) {\n          next = generator.next(readPackage(value.package))\n        } else {\n          next = generator.next(yield value.resolution)\n        }\n      }\n\n      return next.value\n    },\n\n    async *[Symbol.asyncIterator]() {\n      const generator = exports.module(specifier, parentURL, opts)\n\n      let next = generator.next()\n\n      while (next.done !== true) {\n        const value = next.value\n\n        if (value.package) {\n          next = generator.next(await readPackage(value.package))\n        } else {\n          next = generator.next(yield value.resolution)\n        }\n      }\n\n      return next.value\n    }\n  }\n}\n\nfunction defaultReadPackage() {\n  return null\n}\n\n// No resolution candidate was yielded\nconst UNRESOLVED = 0x0\n// At least 1 resolution candidate was yielded\nconst YIELDED = 0x1\n// At least 1 resolution candidate was yielded and resolved\nconst RESOLVED = YIELDED | 0x2\n\nexports.constants = {\n  UNRESOLVED,\n  YIELDED,\n  RESOLVED\n}\n\nexports.module = function* (specifier, parentURL, opts = {}) {\n  const { resolutions = null, imports = null } = opts\n\n  if (exports.startsWithWindowsDriveLetter(specifier)) {\n    specifier = '/' + specifier\n  }\n\n  let status\n\n  if (resolutions) {\n    status = yield* exports.preresolved(specifier, resolutions, parentURL, opts)\n\n    if (status) return status\n  }\n\n  status = yield* exports.url(specifier, parentURL, opts)\n\n  if (status) return status\n\n  status = yield* exports.packageImports(specifier, parentURL, opts)\n\n  if (status) return status\n\n  if (\n    specifier === '.' ||\n    specifier === '..' ||\n    specifier[0] === '/' ||\n    specifier[0] === '\\\\' ||\n    specifier.startsWith('./') ||\n    specifier.startsWith('.\\\\') ||\n    specifier.startsWith('../') ||\n    specifier.startsWith('..\\\\')\n  ) {\n    if (imports) {\n      status = yield* exports.packageImportsExports(\n        specifier,\n        imports,\n        parentURL,\n        true,\n        opts\n      )\n\n      if (status) return status\n    }\n\n    status = yield* exports.deferred(specifier, opts)\n\n    if (status) return status\n\n    status = yield* exports.file(specifier, parentURL, false, opts)\n\n    if (status === RESOLVED) return status\n\n    return yield* exports.directory(specifier, parentURL, opts)\n  }\n\n  return yield* exports.package(specifier, parentURL, opts)\n}\n\nexports.url = function* (url, parentURL, opts = {}) {\n  const { imports = null, deferredProtocol = 'deferred:' } = opts\n\n  let resolution\n  try {\n    resolution = new URL(url)\n  } catch {\n    return UNRESOLVED\n  }\n\n  if (imports) {\n    const status = yield* exports.packageImportsExports(\n      resolution.href,\n      imports,\n      parentURL,\n      true,\n      opts\n    )\n\n    if (status) return status\n  }\n\n  if (resolution.protocol === deferredProtocol) {\n    const specifier = resolution.pathname\n\n    return yield* exports.module(specifier, parentURL, opts)\n  }\n\n  if (resolution.protocol === 'node:') {\n    const specifier = resolution.pathname\n\n    if (\n      specifier === '.' ||\n      specifier === '..' ||\n      specifier[0] === '/' ||\n      specifier.startsWith('./') ||\n      specifier.startsWith('../')\n    ) {\n      throw errors.INVALID_MODULE_SPECIFIER(\n        `Module specifier '${url}' is not a valid package name`\n      )\n    }\n\n    return yield* exports.package(specifier, parentURL, opts)\n  }\n\n  const resolved = yield { resolution }\n\n  return resolved ? RESOLVED : YIELDED\n}\n\nexports.preresolved = function* (specifier, resolutions, parentURL, opts = {}) {\n  const imports = resolutions[parentURL.href]\n\n  if (typeof imports === 'object' && imports !== null) {\n    return yield* exports.packageImportsExports(\n      specifier,\n      imports,\n      parentURL,\n      true,\n      opts\n    )\n  }\n\n  return UNRESOLVED\n}\n\nexports.deferred = function* (specifier, opts = {}) {\n  const { deferredProtocol = 'deferred:', defer = [] } = opts\n\n  if (defer.includes(specifier)) {\n    const resolved = yield { resolution: new URL(deferredProtocol + specifier) }\n\n    return resolved ? RESOLVED : YIELDED\n  }\n\n  return UNRESOLVED\n}\n\nexports[\"package\"] = function* (packageSpecifier, parentURL, opts = {}) {\n  const { builtins = [] } = opts\n\n  if (packageSpecifier === '') {\n    throw errors.INVALID_MODULE_SPECIFIER(\n      `Module specifier '${packageSpecifier}' is not a valid package name`\n    )\n  }\n\n  let packageName\n\n  if (packageSpecifier[0] !== '@') {\n    packageName = packageSpecifier.split('/', 1).join()\n  } else {\n    if (!packageSpecifier.includes('/')) {\n      throw errors.INVALID_MODULE_SPECIFIER(\n        `Module specifier '${packageSpecifier}' is not a valid package name`\n      )\n    }\n\n    packageName = packageSpecifier.split('/', 2).join('/')\n  }\n\n  if (\n    packageName[0] === '.' ||\n    packageName.includes('\\\\') ||\n    packageName.includes('%')\n  ) {\n    throw errors.INVALID_MODULE_SPECIFIER(\n      `Module specifier '${packageSpecifier}' is not a valid package name`\n    )\n  }\n\n  let status\n\n  status = yield* exports.builtinTarget(packageSpecifier, null, builtins, opts)\n\n  if (status) return status\n\n  status = yield* exports.deferred(packageSpecifier, opts)\n\n  if (status) return status\n\n  let packageSubpath = '.' + packageSpecifier.substring(packageName.length)\n\n  status = yield* exports.packageSelf(\n    packageName,\n    packageSubpath,\n    parentURL,\n    opts\n  )\n\n  if (status) return status\n\n  parentURL = new URL(parentURL.href)\n\n  do {\n    const packageURL = new URL('node_modules/' + packageName + '/', parentURL)\n\n    parentURL.pathname = parentURL.pathname.substring(\n      0,\n      parentURL.pathname.lastIndexOf('/')\n    )\n\n    const info = yield { package: new URL('package.json', packageURL) }\n\n    if (info) {\n      if (info.engines) exports.validateEngines(packageURL, info.engines, opts)\n\n      if (info.exports) {\n        return yield* exports.packageExports(\n          packageURL,\n          packageSubpath,\n          info.exports,\n          opts\n        )\n      }\n\n      if (packageSubpath === '.') {\n        if (typeof info.main === 'string' && info.main !== '') {\n          packageSubpath = info.main\n        } else {\n          return yield* exports.file('index', packageURL, true, opts)\n        }\n      }\n\n      status = yield* exports.file(packageSubpath, packageURL, false, opts)\n\n      if (status === RESOLVED) return status\n\n      return yield* exports.directory(packageSubpath, packageURL, opts)\n    }\n  } while (parentURL.pathname !== '' && parentURL.pathname !== '/')\n\n  return UNRESOLVED\n}\n\nexports.packageSelf = function* (\n  packageName,\n  packageSubpath,\n  parentURL,\n  opts = {}\n) {\n  for (const packageURL of exports.lookupPackageScope(parentURL, opts)) {\n    const info = yield { package: packageURL }\n\n    if (info) {\n      if (info.name !== packageName) return false\n\n      if (info.exports) {\n        return yield* exports.packageExports(\n          packageURL,\n          packageSubpath,\n          info.exports,\n          opts\n        )\n      }\n\n      if (packageSubpath === '.') {\n        if (typeof info.main === 'string' && info.main !== '') {\n          packageSubpath = info.main\n        } else {\n          return yield* exports.file('index', packageURL, true, opts)\n        }\n      }\n\n      const status = yield* exports.file(\n        packageSubpath,\n        packageURL,\n        false,\n        opts\n      )\n\n      if (status === RESOLVED) return status\n\n      return yield* exports.directory(packageSubpath, packageURL, opts)\n    }\n  }\n\n  return UNRESOLVED\n}\n\nexports.packageExports = function* (\n  packageURL,\n  subpath,\n  packageExports,\n  opts = {}\n) {\n  if (subpath === '.') {\n    let mainExport\n\n    if (typeof packageExports === 'string' || Array.isArray(packageExports)) {\n      mainExport = packageExports\n    } else if (typeof packageExports === 'object' && packageExports !== null) {\n      const keys = Object.keys(packageExports)\n\n      if (keys.some((key) => key.startsWith('.'))) {\n        if ('.' in packageExports) mainExport = packageExports['.']\n      } else {\n        mainExport = packageExports\n      }\n    }\n\n    if (mainExport) {\n      const status = yield* exports.packageTarget(\n        packageURL,\n        mainExport,\n        null,\n        false,\n        opts\n      )\n\n      if (status) return status\n    }\n  } else if (typeof packageExports === 'object' && packageExports !== null) {\n    const keys = Object.keys(packageExports)\n\n    if (keys.every((key) => key.startsWith('.'))) {\n      const status = yield* exports.packageImportsExports(\n        subpath,\n        packageExports,\n        packageURL,\n        false,\n        opts\n      )\n\n      if (status) return status\n    }\n  }\n\n  packageURL = new URL('package.json', packageURL)\n\n  throw errors.PACKAGE_PATH_NOT_EXPORTED(\n    `Package subpath '${subpath}' is not defined by \"exports\" in '${packageURL}'`\n  )\n}\n\nexports.packageImports = function* (specifier, parentURL, opts = {}) {\n  const { imports = null } = opts\n\n  if (specifier === '#' || specifier.startsWith('#/')) {\n    throw errors.INVALID_MODULE_SPECIFIER(\n      `Module specifier '${specifier}' is not a valid internal imports specifier`\n    )\n  }\n\n  for (const packageURL of exports.lookupPackageScope(parentURL, opts)) {\n    const info = yield { package: packageURL }\n\n    if (info) {\n      if (info.imports) {\n        const status = yield* exports.packageImportsExports(\n          specifier,\n          info.imports,\n          packageURL,\n          true,\n          opts\n        )\n\n        if (status) return status\n      }\n\n      if (specifier.startsWith('#')) {\n        throw errors.PACKAGE_IMPORT_NOT_DEFINED(\n          `Package import specifier '${specifier}' is not defined by \"imports\" in '${packageURL}'`\n        )\n      }\n\n      break\n    }\n  }\n\n  if (imports) {\n    const status = yield* exports.packageImportsExports(\n      specifier,\n      imports,\n      parentURL,\n      true,\n      opts\n    )\n\n    if (status) return status\n  }\n\n  return UNRESOLVED\n}\n\nexports.packageImportsExports = function* (\n  matchKey,\n  matchObject,\n  packageURL,\n  isImports,\n  opts = {}\n) {\n  if (matchKey in matchObject && !matchKey.includes('*')) {\n    const target = matchObject[matchKey]\n\n    return yield* exports.packageTarget(\n      packageURL,\n      target,\n      null,\n      isImports,\n      opts\n    )\n  }\n\n  const expansionKeys = Object.keys(matchObject)\n    .filter((key) => key.includes('*'))\n    .sort(exports.patternKeyCompare)\n\n  for (const expansionKey of expansionKeys) {\n    const patternIndex = expansionKey.indexOf('*')\n    const patternBase = expansionKey.substring(0, patternIndex)\n\n    if (matchKey.startsWith(patternBase) && matchKey !== patternBase) {\n      const patternTrailer = expansionKey.substring(patternIndex + 1)\n\n      if (\n        patternTrailer === '' ||\n        (matchKey.endsWith(patternTrailer) &&\n          matchKey.length >= expansionKey.length)\n      ) {\n        const target = matchObject[expansionKey]\n\n        const patternMatch = matchKey.substring(\n          patternBase.length,\n          matchKey.length - patternTrailer.length\n        )\n\n        return yield* exports.packageTarget(\n          packageURL,\n          target,\n          patternMatch,\n          isImports,\n          opts\n        )\n      }\n    }\n  }\n\n  return UNRESOLVED\n}\n\nexports.validateEngines = function validateEngines(\n  packageURL,\n  packageEngines,\n  opts = {}\n) {\n  const { engines = {} } = opts\n\n  for (const [engine, range] of Object.entries(packageEngines)) {\n    if (engine in engines) {\n      const version = engines[engine]\n\n      if (!satisfies(version, range)) {\n        packageURL = new URL('package.json', packageURL)\n\n        throw errors.UNSUPPORTED_ENGINE(\n          `Package not compatible with engine '${engine}' ${version}, requires range '${range}' defined by \"engines\" in '${packageURL}'`\n        )\n      }\n    }\n  }\n}\n\nexports.patternKeyCompare = function patternKeyCompare(keyA, keyB) {\n  const patternIndexA = keyA.indexOf('*')\n  const patternIndexB = keyB.indexOf('*')\n  const baseLengthA = patternIndexA === -1 ? keyA.length : patternIndexA + 1\n  const baseLengthB = patternIndexB === -1 ? keyB.length : patternIndexB + 1\n  if (baseLengthA > baseLengthB) return -1\n  if (baseLengthB > baseLengthA) return 1\n  if (patternIndexA === -1) return 1\n  if (patternIndexB === -1) return -1\n  if (keyA.length > keyB.length) return -1\n  if (keyB.length > keyA.length) return 1\n  return 0\n}\n\nexports.packageTarget = function* (\n  packageURL,\n  target,\n  patternMatch,\n  isImports,\n  opts = {}\n) {\n  const { conditions = [], matchedConditions = [] } = opts\n\n  if (typeof target === 'string') {\n    if (!target.startsWith('./') && !isImports) {\n      packageURL = new URL('package.json', packageURL)\n\n      throw errors.INVALID_PACKAGE_TARGET(\n        `Invalid target '${target}' defined by \"exports\" in '${packageURL}'`\n      )\n    }\n\n    if (patternMatch !== null) {\n      target = target.replaceAll('*', patternMatch)\n    }\n\n    const status = yield* exports.url(target, packageURL, opts)\n\n    if (status) return status\n\n    if (\n      target === '.' ||\n      target === '..' ||\n      target[0] === '/' ||\n      target.startsWith('./') ||\n      target.startsWith('../')\n    ) {\n      const resolved = yield { resolution: new URL(target, packageURL) }\n\n      return resolved ? RESOLVED : YIELDED\n    }\n\n    return yield* exports.package(target, packageURL, opts)\n  }\n\n  if (Array.isArray(target)) {\n    for (const targetValue of target) {\n      const status = yield* exports.packageTarget(\n        packageURL,\n        targetValue,\n        patternMatch,\n        isImports,\n        opts\n      )\n\n      if (status) return status\n    }\n  } else if (typeof target === 'object' && target !== null) {\n    let status = UNRESOLVED\n\n    for (const [condition, targetValue, subset] of exports.conditionMatches(\n      target,\n      conditions,\n      opts\n    )) {\n      matchedConditions.push(condition)\n\n      status |= yield* exports.packageTarget(\n        packageURL,\n        targetValue,\n        patternMatch,\n        isImports,\n        { ...opts, conditions: subset }\n      )\n\n      matchedConditions.pop()\n    }\n\n    if (status) return status\n  }\n\n  return UNRESOLVED\n}\n\nexports.builtinTarget = function* (\n  packageSpecifier,\n  packageVersion,\n  target,\n  opts = {}\n) {\n  const {\n    builtinProtocol = 'builtin:',\n    conditions = [],\n    matchedConditions = []\n  } = opts\n\n  if (typeof target === 'string') {\n    const targetParts = target.split('@')\n\n    let targetName\n    let targetVersion\n\n    if (target[0] !== '@') {\n      targetName = targetParts[0]\n      targetVersion = targetParts[1] || null\n    } else {\n      targetName = targetParts.slice(0, 2).join('@')\n      targetVersion = targetParts[2] || null\n    }\n\n    if (packageSpecifier === targetName) {\n      if (packageVersion === null && targetVersion === null) {\n        const resolved = yield {\n          resolution: new URL(builtinProtocol + packageSpecifier)\n        }\n\n        return resolved ? RESOLVED : YIELDED\n      }\n\n      let version = null\n\n      if (packageVersion === null) {\n        version = targetVersion\n      } else if (targetVersion === null || packageVersion === targetVersion) {\n        version = packageVersion\n      }\n\n      if (version !== null) {\n        const resolved = yield {\n          resolution: new URL(\n            builtinProtocol + packageSpecifier + '@' + version\n          )\n        }\n\n        return resolved ? RESOLVED : YIELDED\n      }\n    }\n  } else if (Array.isArray(target)) {\n    for (const targetValue of target) {\n      const status = yield* exports.builtinTarget(\n        packageSpecifier,\n        packageVersion,\n        targetValue,\n        opts\n      )\n\n      if (status) return status\n    }\n  } else if (typeof target === 'object' && target !== null) {\n    let status = UNRESOLVED\n\n    for (const [condition, targetValue, subset] of exports.conditionMatches(\n      target,\n      conditions,\n      opts\n    )) {\n      matchedConditions.push(condition)\n\n      status |= yield* exports.builtinTarget(\n        packageSpecifier,\n        packageVersion,\n        targetValue,\n        { ...opts, conditions: subset }\n      )\n\n      matchedConditions.pop()\n    }\n\n    if (status) return status\n  }\n\n  return UNRESOLVED\n}\n\nexports.conditionMatches = function* conditionMatches(\n  target,\n  conditions,\n  opts = {}\n) {\n  if (conditions.every((condition) => typeof condition === 'string')) {\n    const keys = Object.keys(target)\n\n    for (const condition of keys) {\n      if (condition === 'default' || conditions.includes(condition)) {\n        yield [condition, target[condition], conditions]\n\n        return true\n      }\n    }\n\n    return false\n  }\n\n  let yielded = false\n\n  for (const subset of conditions) {\n    if (yield* conditionMatches(target, subset, opts)) {\n      yielded = true\n    }\n  }\n\n  return yielded\n}\n\nexports.lookupPackageScope = function* lookupPackageScope(url, opts = {}) {\n  const { resolutions = null } = opts\n\n  if (resolutions) {\n    for (const { resolution } of exports.preresolved(\n      '#package',\n      resolutions,\n      url,\n      opts\n    )) {\n      if (resolution) return yield resolution\n    }\n  }\n\n  const scopeURL = new URL(url.href)\n\n  do {\n    if (scopeURL.pathname.endsWith('/node_modules')) break\n\n    yield new URL('package.json', scopeURL)\n\n    scopeURL.pathname = scopeURL.pathname.substring(\n      0,\n      scopeURL.pathname.lastIndexOf('/')\n    )\n\n    if (\n      scopeURL.pathname.length === 3 &&\n      exports.isWindowsDriveLetter(scopeURL.pathname.substring(1))\n    ) {\n      break\n    }\n  } while (scopeURL.pathname !== '' && scopeURL.pathname !== '/')\n}\n\nexports.file = function* (filename, parentURL, isIndex, opts = {}) {\n  if (\n    filename === '.' ||\n    filename === '..' ||\n    filename[filename.length - 1] === '/' ||\n    filename[filename.length - 1] === '\\\\'\n  ) {\n    return UNRESOLVED\n  }\n\n  if (parentURL.protocol === 'file:' && /%2f|%5c/i.test(filename)) {\n    throw errors.INVALID_MODULE_SPECIFIER(\n      `Module specifier '${filename}' is invalid`\n    )\n  }\n\n  const { extensions = [] } = opts\n\n  let status = UNRESOLVED\n\n  if (!isIndex) {\n    if (yield { resolution: new URL(filename, parentURL) }) {\n      return RESOLVED\n    }\n\n    status = YIELDED\n  }\n\n  for (const ext of extensions) {\n    if (yield { resolution: new URL(filename + ext, parentURL) }) {\n      return RESOLVED\n    }\n\n    status = YIELDED\n  }\n\n  return status\n}\n\nexports.directory = function* (dirname, parentURL, opts = {}) {\n  let directoryURL\n\n  if (\n    dirname[dirname.length - 1] === '/' ||\n    dirname[dirname.length - 1] === '\\\\'\n  ) {\n    directoryURL = new URL(dirname, parentURL)\n  } else {\n    directoryURL = new URL(dirname + '/', parentURL)\n  }\n\n  const info = yield { package: new URL('package.json', directoryURL) }\n\n  if (info) {\n    if (info.exports) {\n      return yield* exports.packageExports(\n        directoryURL,\n        '.',\n        info.exports,\n        opts\n      )\n    }\n\n    if (typeof info.main === 'string' && info.main !== '') {\n      const status = yield* exports.file(info.main, directoryURL, false, opts)\n\n      if (status === RESOLVED) return status\n\n      return yield* exports.directory(info.main, directoryURL, opts)\n    }\n  }\n\n  return yield* exports.file('index', directoryURL, true, opts)\n}\n\n// https://infra.spec.whatwg.org/#ascii-upper-alpha\nfunction isASCIIUpperAlpha(c) {\n  return c >= 0x41 && c <= 0x5a\n}\n\n// https://infra.spec.whatwg.org/#ascii-lower-alpha\nfunction isASCIILowerAlpha(c) {\n  return c >= 0x61 && c <= 0x7a\n}\n\n// https://infra.spec.whatwg.org/#ascii-alpha\nfunction isASCIIAlpha(c) {\n  return isASCIIUpperAlpha(c) || isASCIILowerAlpha(c)\n}\n\n// https://url.spec.whatwg.org/#windows-drive-letter\nexports.isWindowsDriveLetter = function isWindowsDriveLetter(input) {\n  return (\n    input.length >= 2 &&\n    isASCIIAlpha(input.charCodeAt(0)) &&\n    (input.charCodeAt(1) === 0x3a || input.charCodeAt(1) === 0x7c)\n  )\n}\n\n// https://url.spec.whatwg.org/#start-with-a-windows-drive-letter\nexports.startsWithWindowsDriveLetter = function startsWithWindowsDriveLetter(\n  input\n) {\n  return (\n    input.length >= 2 &&\n    exports.isWindowsDriveLetter(input) &&\n    (input.length === 2 ||\n      input.charCodeAt(2) === 0x2f ||\n      input.charCodeAt(2) === 0x5c ||\n      input.charCodeAt(2) === 0x3f ||\n      input.charCodeAt(2) === 0x23)\n  )\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvYmFyZS1tb2R1bGUtcmVzb2x2ZS9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBQSxRQUFRLFlBQVksRUFBRSxtQkFBTyxDQUFDLDhEQUFhO0FBQzNDLGVBQWUsbUJBQU8sQ0FBQyw0RUFBYzs7QUFFckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxjQUFjLDZDQUE2QztBQUMzRCxVQUFVLHFDQUFxQzs7QUFFL0M7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsV0FBVyx1Q0FBdUM7QUFDbEQsVUFBVSxpREFBaUQ7O0FBRTNEO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtB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O0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxvQ0FBb0M7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vc3RlbGxhci1wcm9jdXJlbWVudC1kYXBwLy4vbm9kZV9tb2R1bGVzL2JhcmUtbW9kdWxlLXJlc29sdmUvaW5kZXguanM/ZjM1ZSJdLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCB7IHNhdGlzZmllcyB9ID0gcmVxdWlyZSgnYmFyZS1zZW12ZXInKVxuY29uc3QgZXJyb3JzID0gcmVxdWlyZSgnLi9saWIvZXJyb3JzJylcblxubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzID0gZnVuY3Rpb24gcmVzb2x2ZShcbiAgc3BlY2lmaWVyLFxuICBwYXJlbnRVUkwsXG4gIG9wdHMsXG4gIHJlYWRQYWNrYWdlXG4pIHtcbiAgaWYgKHR5cGVvZiBvcHRzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmVhZFBhY2thZ2UgPSBvcHRzXG4gICAgb3B0cyA9IHt9XG4gIH0gZWxzZSBpZiAodHlwZW9mIHJlYWRQYWNrYWdlICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgcmVhZFBhY2thZ2UgPSBkZWZhdWx0UmVhZFBhY2thZ2VcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgKltTeW1ib2wuaXRlcmF0b3JdKCkge1xuICAgICAgY29uc3QgZ2VuZXJhdG9yID0gZXhwb3J0cy5tb2R1bGUoc3BlY2lmaWVyLCBwYXJlbnRVUkwsIG9wdHMpXG5cbiAgICAgIGxldCBuZXh0ID0gZ2VuZXJhdG9yLm5leHQoKVxuXG4gICAgICB3aGlsZSAobmV4dC5kb25lICE9PSB0cnVlKSB7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gbmV4dC52YWx1ZVxuXG4gICAgICAgIGlmICh2YWx1ZS5wYWNrYWdlKSB7XG4gICAgICAgICAgbmV4dCA9IGdlbmVyYXRvci5uZXh0KHJlYWRQYWNrYWdlKHZhbHVlLnBhY2thZ2UpKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG5leHQgPSBnZW5lcmF0b3IubmV4dCh5aWVsZCB2YWx1ZS5yZXNvbHV0aW9uKVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBuZXh0LnZhbHVlXG4gICAgfSxcblxuICAgIGFzeW5jICpbU3ltYm9sLmFzeW5jSXRlcmF0b3JdKCkge1xuICAgICAgY29uc3QgZ2VuZXJhdG9yID0gZXhwb3J0cy5tb2R1bGUoc3BlY2lmaWVyLCBwYXJlbnRVUkwsIG9wdHMpXG5cbiAgICAgIGxldCBuZXh0ID0gZ2VuZXJhdG9yLm5leHQoKVxuXG4gICAgICB3aGlsZSAobmV4dC5kb25lICE9PSB0cnVlKSB7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gbmV4dC52YWx1ZVxuXG4gICAgICAgIGlmICh2YWx1ZS5wYWNrYWdlKSB7XG4gICAgICAgICAgbmV4dCA9IGdlbmVyYXRvci5uZXh0KGF3YWl0IHJlYWRQYWNrYWdlKHZhbHVlLnBhY2thZ2UpKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG5leHQgPSBnZW5lcmF0b3IubmV4dCh5aWVsZCB2YWx1ZS5yZXNvbHV0aW9uKVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBuZXh0LnZhbHVlXG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGRlZmF1bHRSZWFkUGFja2FnZSgpIHtcbiAgcmV0dXJuIG51bGxcbn1cblxuLy8gTm8gcmVzb2x1dGlvbiBjYW5kaWRhdGUgd2FzIHlpZWxkZWRcbmNvbnN0IFVOUkVTT0xWRUQgPSAweDBcbi8vIEF0IGxlYXN0IDEgcmVzb2x1dGlvbiBjYW5kaWRhdGUgd2FzIHlpZWxkZWRcbmNvbnN0IFlJRUxERUQgPSAweDFcbi8vIEF0IGxlYXN0IDEgcmVzb2x1dGlvbiBjYW5kaWRhdGUgd2FzIHlpZWxkZWQgYW5kIHJlc29sdmVkXG5jb25zdCBSRVNPTFZFRCA9IFlJRUxERUQgfCAweDJcblxuZXhwb3J0cy5jb25zdGFudHMgPSB7XG4gIFVOUkVTT0xWRUQsXG4gIFlJRUxERUQsXG4gIFJFU09MVkVEXG59XG5cbmV4cG9ydHMubW9kdWxlID0gZnVuY3Rpb24qIChzcGVjaWZpZXIsIHBhcmVudFVSTCwgb3B0cyA9IHt9KSB7XG4gIGNvbnN0IHsgcmVzb2x1dGlvbnMgPSBudWxsLCBpbXBvcnRzID0gbnVsbCB9ID0gb3B0c1xuXG4gIGlmIChleHBvcnRzLnN0YXJ0c1dpdGhXaW5kb3dzRHJpdmVMZXR0ZXIoc3BlY2lmaWVyKSkge1xuICAgIHNwZWNpZmllciA9ICcvJyArIHNwZWNpZmllclxuICB9XG5cbiAgbGV0IHN0YXR1c1xuXG4gIGlmIChyZXNvbHV0aW9ucykge1xuICAgIHN0YXR1cyA9IHlpZWxkKiBleHBvcnRzLnByZXJlc29sdmVkKHNwZWNpZmllciwgcmVzb2x1dGlvbnMsIHBhcmVudFVSTCwgb3B0cylcblxuICAgIGlmIChzdGF0dXMpIHJldHVybiBzdGF0dXNcbiAgfVxuXG4gIHN0YXR1cyA9IHlpZWxkKiBleHBvcnRzLnVybChzcGVjaWZpZXIsIHBhcmVudFVSTCwgb3B0cylcblxuICBpZiAoc3RhdHVzKSByZXR1cm4gc3RhdHVzXG5cbiAgc3RhdHVzID0geWllbGQqIGV4cG9ydHMucGFja2FnZUltcG9ydHMoc3BlY2lmaWVyLCBwYXJlbnRVUkwsIG9wdHMpXG5cbiAgaWYgKHN0YXR1cykgcmV0dXJuIHN0YXR1c1xuXG4gIGlmIChcbiAgICBzcGVjaWZpZXIgPT09ICcuJyB8fFxuICAgIHNwZWNpZmllciA9PT0gJy4uJyB8fFxuICAgIHNwZWNpZmllclswXSA9PT0gJy8nIHx8XG4gICAgc3BlY2lmaWVyWzBdID09PSAnXFxcXCcgfHxcbiAgICBzcGVjaWZpZXIuc3RhcnRzV2l0aCgnLi8nKSB8fFxuICAgIHNwZWNpZmllci5zdGFydHNXaXRoKCcuXFxcXCcpIHx8XG4gICAgc3BlY2lmaWVyLnN0YXJ0c1dpdGgoJy4uLycpIHx8XG4gICAgc3BlY2lmaWVyLnN0YXJ0c1dpdGgoJy4uXFxcXCcpXG4gICkge1xuICAgIGlmIChpbXBvcnRzKSB7XG4gICAgICBzdGF0dXMgPSB5aWVsZCogZXhwb3J0cy5wYWNrYWdlSW1wb3J0c0V4cG9ydHMoXG4gICAgICAgIHNwZWNpZmllcixcbiAgICAgICAgaW1wb3J0cyxcbiAgICAgICAgcGFyZW50VVJMLFxuICAgICAgICB0cnVlLFxuICAgICAgICBvcHRzXG4gICAgICApXG5cbiAgICAgIGlmIChzdGF0dXMpIHJldHVybiBzdGF0dXNcbiAgICB9XG5cbiAgICBzdGF0dXMgPSB5aWVsZCogZXhwb3J0cy5kZWZlcnJlZChzcGVjaWZpZXIsIG9wdHMpXG5cbiAgICBpZiAoc3RhdHVzKSByZXR1cm4gc3RhdHVzXG5cbiAgICBzdGF0dXMgPSB5aWVsZCogZXhwb3J0cy5maWxlKHNwZWNpZmllciwgcGFyZW50VVJMLCBmYWxzZSwgb3B0cylcblxuICAgIGlmIChzdGF0dXMgPT09IFJFU09MVkVEKSByZXR1cm4gc3RhdHVzXG5cbiAgICByZXR1cm4geWllbGQqIGV4cG9ydHMuZGlyZWN0b3J5KHNwZWNpZmllciwgcGFyZW50VVJMLCBvcHRzKVxuICB9XG5cbiAgcmV0dXJuIHlpZWxkKiBleHBvcnRzLnBhY2thZ2Uoc3BlY2lmaWVyLCBwYXJlbnRVUkwsIG9wdHMpXG59XG5cbmV4cG9ydHMudXJsID0gZnVuY3Rpb24qICh1cmwsIHBhcmVudFVSTCwgb3B0cyA9IHt9KSB7XG4gIGNvbnN0IHsgaW1wb3J0cyA9IG51bGwsIGRlZmVycmVkUHJvdG9jb2wgPSAnZGVmZXJyZWQ6JyB9ID0gb3B0c1xuXG4gIGxldCByZXNvbHV0aW9uXG4gIHRyeSB7XG4gICAgcmVzb2x1dGlvbiA9IG5ldyBVUkwodXJsKVxuICB9IGNhdGNoIHtcbiAgICByZXR1cm4gVU5SRVNPTFZFRFxuICB9XG5cbiAgaWYgKGltcG9ydHMpIHtcbiAgICBjb25zdCBzdGF0dXMgPSB5aWVsZCogZXhwb3J0cy5wYWNrYWdlSW1wb3J0c0V4cG9ydHMoXG4gICAgICByZXNvbHV0aW9uLmhyZWYsXG4gICAgICBpbXBvcnRzLFxuICAgICAgcGFyZW50VVJMLFxuICAgICAgdHJ1ZSxcbiAgICAgIG9wdHNcbiAgICApXG5cbiAgICBpZiAoc3RhdHVzKSByZXR1cm4gc3RhdHVzXG4gIH1cblxuICBpZiAocmVzb2x1dGlvbi5wcm90b2NvbCA9PT0gZGVmZXJyZWRQcm90b2NvbCkge1xuICAgIGNvbnN0IHNwZWNpZmllciA9IHJlc29sdXRpb24ucGF0aG5hbWVcblxuICAgIHJldHVybiB5aWVsZCogZXhwb3J0cy5tb2R1bGUoc3BlY2lmaWVyLCBwYXJlbnRVUkwsIG9wdHMpXG4gIH1cblxuICBpZiAocmVzb2x1dGlvbi5wcm90b2NvbCA9PT0gJ25vZGU6Jykge1xuICAgIGNvbnN0IHNwZWNpZmllciA9IHJlc29sdXRpb24ucGF0aG5hbWVcblxuICAgIGlmIChcbiAgICAgIHNwZWNpZmllciA9PT0gJy4nIHx8XG4gICAgICBzcGVjaWZpZXIgPT09ICcuLicgfHxcbiAgICAgIHNwZWNpZmllclswXSA9PT0gJy8nIHx8XG4gICAgICBzcGVjaWZpZXIuc3RhcnRzV2l0aCgnLi8nKSB8fFxuICAgICAgc3BlY2lmaWVyLnN0YXJ0c1dpdGgoJy4uLycpXG4gICAgKSB7XG4gICAgICB0aHJvdyBlcnJvcnMuSU5WQUxJRF9NT0RVTEVfU1BFQ0lGSUVSKFxuICAgICAgICBgTW9kdWxlIHNwZWNpZmllciAnJHt1cmx9JyBpcyBub3QgYSB2YWxpZCBwYWNrYWdlIG5hbWVgXG4gICAgICApXG4gICAgfVxuXG4gICAgcmV0dXJuIHlpZWxkKiBleHBvcnRzLnBhY2thZ2Uoc3BlY2lmaWVyLCBwYXJlbnRVUkwsIG9wdHMpXG4gIH1cblxuICBjb25zdCByZXNvbHZlZCA9IHlpZWxkIHsgcmVzb2x1dGlvbiB9XG5cbiAgcmV0dXJuIHJlc29sdmVkID8gUkVTT0xWRUQgOiBZSUVMREVEXG59XG5cbmV4cG9ydHMucHJlcmVzb2x2ZWQgPSBmdW5jdGlvbiogKHNwZWNpZmllciwgcmVzb2x1dGlvbnMsIHBhcmVudFVSTCwgb3B0cyA9IHt9KSB7XG4gIGNvbnN0IGltcG9ydHMgPSByZXNvbHV0aW9uc1twYXJlbnRVUkwuaHJlZl1cblxuICBpZiAodHlwZW9mIGltcG9ydHMgPT09ICdvYmplY3QnICYmIGltcG9ydHMgIT09IG51bGwpIHtcbiAgICByZXR1cm4geWllbGQqIGV4cG9ydHMucGFja2FnZUltcG9ydHNFeHBvcnRzKFxuICAgICAgc3BlY2lmaWVyLFxuICAgICAgaW1wb3J0cyxcbiAgICAgIHBhcmVudFVSTCxcbiAgICAgIHRydWUsXG4gICAgICBvcHRzXG4gICAgKVxuICB9XG5cbiAgcmV0dXJuIFVOUkVTT0xWRURcbn1cblxuZXhwb3J0cy5kZWZlcnJlZCA9IGZ1bmN0aW9uKiAoc3BlY2lmaWVyLCBvcHRzID0ge30pIHtcbiAgY29uc3QgeyBkZWZlcnJlZFByb3RvY29sID0gJ2RlZmVycmVkOicsIGRlZmVyID0gW10gfSA9IG9wdHNcblxuICBpZiAoZGVmZXIuaW5jbHVkZXMoc3BlY2lmaWVyKSkge1xuICAgIGNvbnN0IHJlc29sdmVkID0geWllbGQgeyByZXNvbHV0aW9uOiBuZXcgVVJMKGRlZmVycmVkUHJvdG9jb2wgKyBzcGVjaWZpZXIpIH1cblxuICAgIHJldHVybiByZXNvbHZlZCA/IFJFU09MVkVEIDogWUlFTERFRFxuICB9XG5cbiAgcmV0dXJuIFVOUkVTT0xWRURcbn1cblxuZXhwb3J0cy5wYWNrYWdlID0gZnVuY3Rpb24qIChwYWNrYWdlU3BlY2lmaWVyLCBwYXJlbnRVUkwsIG9wdHMgPSB7fSkge1xuICBjb25zdCB7IGJ1aWx0aW5zID0gW10gfSA9IG9wdHNcblxuICBpZiAocGFja2FnZVNwZWNpZmllciA9PT0gJycpIHtcbiAgICB0aHJvdyBlcnJvcnMuSU5WQUxJRF9NT0RVTEVfU1BFQ0lGSUVSKFxuICAgICAgYE1vZHVsZSBzcGVjaWZpZXIgJyR7cGFja2FnZVNwZWNpZmllcn0nIGlzIG5vdCBhIHZhbGlkIHBhY2thZ2UgbmFtZWBcbiAgICApXG4gIH1cblxuICBsZXQgcGFja2FnZU5hbWVcblxuICBpZiAocGFja2FnZVNwZWNpZmllclswXSAhPT0gJ0AnKSB7XG4gICAgcGFja2FnZU5hbWUgPSBwYWNrYWdlU3BlY2lmaWVyLnNwbGl0KCcvJywgMSkuam9pbigpXG4gIH0gZWxzZSB7XG4gICAgaWYgKCFwYWNrYWdlU3BlY2lmaWVyLmluY2x1ZGVzKCcvJykpIHtcbiAgICAgIHRocm93IGVycm9ycy5JTlZBTElEX01PRFVMRV9TUEVDSUZJRVIoXG4gICAgICAgIGBNb2R1bGUgc3BlY2lmaWVyICcke3BhY2thZ2VTcGVjaWZpZXJ9JyBpcyBub3QgYSB2YWxpZCBwYWNrYWdlIG5hbWVgXG4gICAgICApXG4gICAgfVxuXG4gICAgcGFja2FnZU5hbWUgPSBwYWNrYWdlU3BlY2lmaWVyLnNwbGl0KCcvJywgMikuam9pbignLycpXG4gIH1cblxuICBpZiAoXG4gICAgcGFja2FnZU5hbWVbMF0gPT09ICcuJyB8fFxuICAgIHBhY2thZ2VOYW1lLmluY2x1ZGVzKCdcXFxcJykgfHxcbiAgICBwYWNrYWdlTmFtZS5pbmNsdWRlcygnJScpXG4gICkge1xuICAgIHRocm93IGVycm9ycy5JTlZBTElEX01PRFVMRV9TUEVDSUZJRVIoXG4gICAgICBgTW9kdWxlIHNwZWNpZmllciAnJHtwYWNrYWdlU3BlY2lmaWVyfScgaXMgbm90IGEgdmFsaWQgcGFja2FnZSBuYW1lYFxuICAgIClcbiAgfVxuXG4gIGxldCBzdGF0dXNcblxuICBzdGF0dXMgPSB5aWVsZCogZXhwb3J0cy5idWlsdGluVGFyZ2V0KHBhY2thZ2VTcGVjaWZpZXIsIG51bGwsIGJ1aWx0aW5zLCBvcHRzKVxuXG4gIGlmIChzdGF0dXMpIHJldHVybiBzdGF0dXNcblxuICBzdGF0dXMgPSB5aWVsZCogZXhwb3J0cy5kZWZlcnJlZChwYWNrYWdlU3BlY2lmaWVyLCBvcHRzKVxuXG4gIGlmIChzdGF0dXMpIHJldHVybiBzdGF0dXNcblxuICBsZXQgcGFja2FnZVN1YnBhdGggPSAnLicgKyBwYWNrYWdlU3BlY2lmaWVyLnN1YnN0cmluZyhwYWNrYWdlTmFtZS5sZW5ndGgpXG5cbiAgc3RhdHVzID0geWllbGQqIGV4cG9ydHMucGFja2FnZVNlbGYoXG4gICAgcGFja2FnZU5hbWUsXG4gICAgcGFja2FnZVN1YnBhdGgsXG4gICAgcGFyZW50VVJMLFxuICAgIG9wdHNcbiAgKVxuXG4gIGlmIChzdGF0dXMpIHJldHVybiBzdGF0dXNcblxuICBwYXJlbnRVUkwgPSBuZXcgVVJMKHBhcmVudFVSTC5ocmVmKVxuXG4gIGRvIHtcbiAgICBjb25zdCBwYWNrYWdlVVJMID0gbmV3IFVSTCgnbm9kZV9tb2R1bGVzLycgKyBwYWNrYWdlTmFtZSArICcvJywgcGFyZW50VVJMKVxuXG4gICAgcGFyZW50VVJMLnBhdGhuYW1lID0gcGFyZW50VVJMLnBhdGhuYW1lLnN1YnN0cmluZyhcbiAgICAgIDAsXG4gICAgICBwYXJlbnRVUkwucGF0aG5hbWUubGFzdEluZGV4T2YoJy8nKVxuICAgIClcblxuICAgIGNvbnN0IGluZm8gPSB5aWVsZCB7IHBhY2thZ2U6IG5ldyBVUkwoJ3BhY2thZ2UuanNvbicsIHBhY2thZ2VVUkwpIH1cblxuICAgIGlmIChpbmZvKSB7XG4gICAgICBpZiAoaW5mby5lbmdpbmVzKSBleHBvcnRzLnZhbGlkYXRlRW5naW5lcyhwYWNrYWdlVVJMLCBpbmZvLmVuZ2luZXMsIG9wdHMpXG5cbiAgICAgIGlmIChpbmZvLmV4cG9ydHMpIHtcbiAgICAgICAgcmV0dXJuIHlpZWxkKiBleHBvcnRzLnBhY2thZ2VFeHBvcnRzKFxuICAgICAgICAgIHBhY2thZ2VVUkwsXG4gICAgICAgICAgcGFja2FnZVN1YnBhdGgsXG4gICAgICAgICAgaW5mby5leHBvcnRzLFxuICAgICAgICAgIG9wdHNcbiAgICAgICAgKVxuICAgICAgfVxuXG4gICAgICBpZiAocGFja2FnZVN1YnBhdGggPT09ICcuJykge1xuICAgICAgICBpZiAodHlwZW9mIGluZm8ubWFpbiA9PT0gJ3N0cmluZycgJiYgaW5mby5tYWluICE9PSAnJykge1xuICAgICAgICAgIHBhY2thZ2VTdWJwYXRoID0gaW5mby5tYWluXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIHlpZWxkKiBleHBvcnRzLmZpbGUoJ2luZGV4JywgcGFja2FnZVVSTCwgdHJ1ZSwgb3B0cylcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBzdGF0dXMgPSB5aWVsZCogZXhwb3J0cy5maWxlKHBhY2thZ2VTdWJwYXRoLCBwYWNrYWdlVVJMLCBmYWxzZSwgb3B0cylcblxuICAgICAgaWYgKHN0YXR1cyA9PT0gUkVTT0xWRUQpIHJldHVybiBzdGF0dXNcblxuICAgICAgcmV0dXJuIHlpZWxkKiBleHBvcnRzLmRpcmVjdG9yeShwYWNrYWdlU3VicGF0aCwgcGFja2FnZVVSTCwgb3B0cylcbiAgICB9XG4gIH0gd2hpbGUgKHBhcmVudFVSTC5wYXRobmFtZSAhPT0gJycgJiYgcGFyZW50VVJMLnBhdGhuYW1lICE9PSAnLycpXG5cbiAgcmV0dXJuIFVOUkVTT0xWRURcbn1cblxuZXhwb3J0cy5wYWNrYWdlU2VsZiA9IGZ1bmN0aW9uKiAoXG4gIHBhY2thZ2VOYW1lLFxuICBwYWNrYWdlU3VicGF0aCxcbiAgcGFyZW50VVJMLFxuICBvcHRzID0ge31cbikge1xuICBmb3IgKGNvbnN0IHBhY2thZ2VVUkwgb2YgZXhwb3J0cy5sb29rdXBQYWNrYWdlU2NvcGUocGFyZW50VVJMLCBvcHRzKSkge1xuICAgIGNvbnN0IGluZm8gPSB5aWVsZCB7IHBhY2thZ2U6IHBhY2thZ2VVUkwgfVxuXG4gICAgaWYgKGluZm8pIHtcbiAgICAgIGlmIChpbmZvLm5hbWUgIT09IHBhY2thZ2VOYW1lKSByZXR1cm4gZmFsc2VcblxuICAgICAgaWYgKGluZm8uZXhwb3J0cykge1xuICAgICAgICByZXR1cm4geWllbGQqIGV4cG9ydHMucGFja2FnZUV4cG9ydHMoXG4gICAgICAgICAgcGFja2FnZVVSTCxcbiAgICAgICAgICBwYWNrYWdlU3VicGF0aCxcbiAgICAgICAgICBpbmZvLmV4cG9ydHMsXG4gICAgICAgICAgb3B0c1xuICAgICAgICApXG4gICAgICB9XG5cbiAgICAgIGlmIChwYWNrYWdlU3VicGF0aCA9PT0gJy4nKSB7XG4gICAgICAgIGlmICh0eXBlb2YgaW5mby5tYWluID09PSAnc3RyaW5nJyAmJiBpbmZvLm1haW4gIT09ICcnKSB7XG4gICAgICAgICAgcGFja2FnZVN1YnBhdGggPSBpbmZvLm1haW5cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4geWllbGQqIGV4cG9ydHMuZmlsZSgnaW5kZXgnLCBwYWNrYWdlVVJMLCB0cnVlLCBvcHRzKVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHN0YXR1cyA9IHlpZWxkKiBleHBvcnRzLmZpbGUoXG4gICAgICAgIHBhY2thZ2VTdWJwYXRoLFxuICAgICAgICBwYWNrYWdlVVJMLFxuICAgICAgICBmYWxzZSxcbiAgICAgICAgb3B0c1xuICAgICAgKVxuXG4gICAgICBpZiAoc3RhdHVzID09PSBSRVNPTFZFRCkgcmV0dXJuIHN0YXR1c1xuXG4gICAgICByZXR1cm4geWllbGQqIGV4cG9ydHMuZGlyZWN0b3J5KHBhY2thZ2VTdWJwYXRoLCBwYWNrYWdlVVJMLCBvcHRzKVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBVTlJFU09MVkVEXG59XG5cbmV4cG9ydHMucGFja2FnZUV4cG9ydHMgPSBmdW5jdGlvbiogKFxuICBwYWNrYWdlVVJMLFxuICBzdWJwYXRoLFxuICBwYWNrYWdlRXhwb3J0cyxcbiAgb3B0cyA9IHt9XG4pIHtcbiAgaWYgKHN1YnBhdGggPT09ICcuJykge1xuICAgIGxldCBtYWluRXhwb3J0XG5cbiAgICBpZiAodHlwZW9mIHBhY2thZ2VFeHBvcnRzID09PSAnc3RyaW5nJyB8fCBBcnJheS5pc0FycmF5KHBhY2thZ2VFeHBvcnRzKSkge1xuICAgICAgbWFpbkV4cG9ydCA9IHBhY2thZ2VFeHBvcnRzXG4gICAgfSBlbHNlIGlmICh0eXBlb2YgcGFja2FnZUV4cG9ydHMgPT09ICdvYmplY3QnICYmIHBhY2thZ2VFeHBvcnRzICE9PSBudWxsKSB7XG4gICAgICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMocGFja2FnZUV4cG9ydHMpXG5cbiAgICAgIGlmIChrZXlzLnNvbWUoKGtleSkgPT4ga2V5LnN0YXJ0c1dpdGgoJy4nKSkpIHtcbiAgICAgICAgaWYgKCcuJyBpbiBwYWNrYWdlRXhwb3J0cykgbWFpbkV4cG9ydCA9IHBhY2thZ2VFeHBvcnRzWycuJ11cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG1haW5FeHBvcnQgPSBwYWNrYWdlRXhwb3J0c1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChtYWluRXhwb3J0KSB7XG4gICAgICBjb25zdCBzdGF0dXMgPSB5aWVsZCogZXhwb3J0cy5wYWNrYWdlVGFyZ2V0KFxuICAgICAgICBwYWNrYWdlVVJMLFxuICAgICAgICBtYWluRXhwb3J0LFxuICAgICAgICBudWxsLFxuICAgICAgICBmYWxzZSxcbiAgICAgICAgb3B0c1xuICAgICAgKVxuXG4gICAgICBpZiAoc3RhdHVzKSByZXR1cm4gc3RhdHVzXG4gICAgfVxuICB9IGVsc2UgaWYgKHR5cGVvZiBwYWNrYWdlRXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgcGFja2FnZUV4cG9ydHMgIT09IG51bGwpIHtcbiAgICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMocGFja2FnZUV4cG9ydHMpXG5cbiAgICBpZiAoa2V5cy5ldmVyeSgoa2V5KSA9PiBrZXkuc3RhcnRzV2l0aCgnLicpKSkge1xuICAgICAgY29uc3Qgc3RhdHVzID0geWllbGQqIGV4cG9ydHMucGFja2FnZUltcG9ydHNFeHBvcnRzKFxuICAgICAgICBzdWJwYXRoLFxuICAgICAgICBwYWNrYWdlRXhwb3J0cyxcbiAgICAgICAgcGFja2FnZVVSTCxcbiAgICAgICAgZmFsc2UsXG4gICAgICAgIG9wdHNcbiAgICAgIClcblxuICAgICAgaWYgKHN0YXR1cykgcmV0dXJuIHN0YXR1c1xuICAgIH1cbiAgfVxuXG4gIHBhY2thZ2VVUkwgPSBuZXcgVVJMKCdwYWNrYWdlLmpzb24nLCBwYWNrYWdlVVJMKVxuXG4gIHRocm93IGVycm9ycy5QQUNLQUdFX1BBVEhfTk9UX0VYUE9SVEVEKFxuICAgIGBQYWNrYWdlIHN1YnBhdGggJyR7c3VicGF0aH0nIGlzIG5vdCBkZWZpbmVkIGJ5IFwiZXhwb3J0c1wiIGluICcke3BhY2thZ2VVUkx9J2BcbiAgKVxufVxuXG5leHBvcnRzLnBhY2thZ2VJbXBvcnRzID0gZnVuY3Rpb24qIChzcGVjaWZpZXIsIHBhcmVudFVSTCwgb3B0cyA9IHt9KSB7XG4gIGNvbnN0IHsgaW1wb3J0cyA9IG51bGwgfSA9IG9wdHNcblxuICBpZiAoc3BlY2lmaWVyID09PSAnIycgfHwgc3BlY2lmaWVyLnN0YXJ0c1dpdGgoJyMvJykpIHtcbiAgICB0aHJvdyBlcnJvcnMuSU5WQUxJRF9NT0RVTEVfU1BFQ0lGSUVSKFxuICAgICAgYE1vZHVsZSBzcGVjaWZpZXIgJyR7c3BlY2lmaWVyfScgaXMgbm90IGEgdmFsaWQgaW50ZXJuYWwgaW1wb3J0cyBzcGVjaWZpZXJgXG4gICAgKVxuICB9XG5cbiAgZm9yIChjb25zdCBwYWNrYWdlVVJMIG9mIGV4cG9ydHMubG9va3VwUGFja2FnZVNjb3BlKHBhcmVudFVSTCwgb3B0cykpIHtcbiAgICBjb25zdCBpbmZvID0geWllbGQgeyBwYWNrYWdlOiBwYWNrYWdlVVJMIH1cblxuICAgIGlmIChpbmZvKSB7XG4gICAgICBpZiAoaW5mby5pbXBvcnRzKSB7XG4gICAgICAgIGNvbnN0IHN0YXR1cyA9IHlpZWxkKiBleHBvcnRzLnBhY2thZ2VJbXBvcnRzRXhwb3J0cyhcbiAgICAgICAgICBzcGVjaWZpZXIsXG4gICAgICAgICAgaW5mby5pbXBvcnRzLFxuICAgICAgICAgIHBhY2thZ2VVUkwsXG4gICAgICAgICAgdHJ1ZSxcbiAgICAgICAgICBvcHRzXG4gICAgICAgIClcblxuICAgICAgICBpZiAoc3RhdHVzKSByZXR1cm4gc3RhdHVzXG4gICAgICB9XG5cbiAgICAgIGlmIChzcGVjaWZpZXIuc3RhcnRzV2l0aCgnIycpKSB7XG4gICAgICAgIHRocm93IGVycm9ycy5QQUNLQUdFX0lNUE9SVF9OT1RfREVGSU5FRChcbiAgICAgICAgICBgUGFja2FnZSBpbXBvcnQgc3BlY2lmaWVyICcke3NwZWNpZmllcn0nIGlzIG5vdCBkZWZpbmVkIGJ5IFwiaW1wb3J0c1wiIGluICcke3BhY2thZ2VVUkx9J2BcbiAgICAgICAgKVxuICAgICAgfVxuXG4gICAgICBicmVha1xuICAgIH1cbiAgfVxuXG4gIGlmIChpbXBvcnRzKSB7XG4gICAgY29uc3Qgc3RhdHVzID0geWllbGQqIGV4cG9ydHMucGFja2FnZUltcG9ydHNFeHBvcnRzKFxuICAgICAgc3BlY2lmaWVyLFxuICAgICAgaW1wb3J0cyxcbiAgICAgIHBhcmVudFVSTCxcbiAgICAgIHRydWUsXG4gICAgICBvcHRzXG4gICAgKVxuXG4gICAgaWYgKHN0YXR1cykgcmV0dXJuIHN0YXR1c1xuICB9XG5cbiAgcmV0dXJuIFVOUkVTT0xWRURcbn1cblxuZXhwb3J0cy5wYWNrYWdlSW1wb3J0c0V4cG9ydHMgPSBmdW5jdGlvbiogKFxuICBtYXRjaEtleSxcbiAgbWF0Y2hPYmplY3QsXG4gIHBhY2thZ2VVUkwsXG4gIGlzSW1wb3J0cyxcbiAgb3B0cyA9IHt9XG4pIHtcbiAgaWYgKG1hdGNoS2V5IGluIG1hdGNoT2JqZWN0ICYmICFtYXRjaEtleS5pbmNsdWRlcygnKicpKSB7XG4gICAgY29uc3QgdGFyZ2V0ID0gbWF0Y2hPYmplY3RbbWF0Y2hLZXldXG5cbiAgICByZXR1cm4geWllbGQqIGV4cG9ydHMucGFja2FnZVRhcmdldChcbiAgICAgIHBhY2thZ2VVUkwsXG4gICAgICB0YXJnZXQsXG4gICAgICBudWxsLFxuICAgICAgaXNJbXBvcnRzLFxuICAgICAgb3B0c1xuICAgIClcbiAgfVxuXG4gIGNvbnN0IGV4cGFuc2lvbktleXMgPSBPYmplY3Qua2V5cyhtYXRjaE9iamVjdClcbiAgICAuZmlsdGVyKChrZXkpID0+IGtleS5pbmNsdWRlcygnKicpKVxuICAgIC5zb3J0KGV4cG9ydHMucGF0dGVybktleUNvbXBhcmUpXG5cbiAgZm9yIChjb25zdCBleHBhbnNpb25LZXkgb2YgZXhwYW5zaW9uS2V5cykge1xuICAgIGNvbnN0IHBhdHRlcm5JbmRleCA9IGV4cGFuc2lvbktleS5pbmRleE9mKCcqJylcbiAgICBjb25zdCBwYXR0ZXJuQmFzZSA9IGV4cGFuc2lvbktleS5zdWJzdHJpbmcoMCwgcGF0dGVybkluZGV4KVxuXG4gICAgaWYgKG1hdGNoS2V5LnN0YXJ0c1dpdGgocGF0dGVybkJhc2UpICYmIG1hdGNoS2V5ICE9PSBwYXR0ZXJuQmFzZSkge1xuICAgICAgY29uc3QgcGF0dGVyblRyYWlsZXIgPSBleHBhbnNpb25LZXkuc3Vic3RyaW5nKHBhdHRlcm5JbmRleCArIDEpXG5cbiAgICAgIGlmIChcbiAgICAgICAgcGF0dGVyblRyYWlsZXIgPT09ICcnIHx8XG4gICAgICAgIChtYXRjaEtleS5lbmRzV2l0aChwYXR0ZXJuVHJhaWxlcikgJiZcbiAgICAgICAgICBtYXRjaEtleS5sZW5ndGggPj0gZXhwYW5zaW9uS2V5Lmxlbmd0aClcbiAgICAgICkge1xuICAgICAgICBjb25zdCB0YXJnZXQgPSBtYXRjaE9iamVjdFtleHBhbnNpb25LZXldXG5cbiAgICAgICAgY29uc3QgcGF0dGVybk1hdGNoID0gbWF0Y2hLZXkuc3Vic3RyaW5nKFxuICAgICAgICAgIHBhdHRlcm5CYXNlLmxlbmd0aCxcbiAgICAgICAgICBtYXRjaEtleS5sZW5ndGggLSBwYXR0ZXJuVHJhaWxlci5sZW5ndGhcbiAgICAgICAgKVxuXG4gICAgICAgIHJldHVybiB5aWVsZCogZXhwb3J0cy5wYWNrYWdlVGFyZ2V0KFxuICAgICAgICAgIHBhY2thZ2VVUkwsXG4gICAgICAgICAgdGFyZ2V0LFxuICAgICAgICAgIHBhdHRlcm5NYXRjaCxcbiAgICAgICAgICBpc0ltcG9ydHMsXG4gICAgICAgICAgb3B0c1xuICAgICAgICApXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIFVOUkVTT0xWRURcbn1cblxuZXhwb3J0cy52YWxpZGF0ZUVuZ2luZXMgPSBmdW5jdGlvbiB2YWxpZGF0ZUVuZ2luZXMoXG4gIHBhY2thZ2VVUkwsXG4gIHBhY2thZ2VFbmdpbmVzLFxuICBvcHRzID0ge31cbikge1xuICBjb25zdCB7IGVuZ2luZXMgPSB7fSB9ID0gb3B0c1xuXG4gIGZvciAoY29uc3QgW2VuZ2luZSwgcmFuZ2VdIG9mIE9iamVjdC5lbnRyaWVzKHBhY2thZ2VFbmdpbmVzKSkge1xuICAgIGlmIChlbmdpbmUgaW4gZW5naW5lcykge1xuICAgICAgY29uc3QgdmVyc2lvbiA9IGVuZ2luZXNbZW5naW5lXVxuXG4gICAgICBpZiAoIXNhdGlzZmllcyh2ZXJzaW9uLCByYW5nZSkpIHtcbiAgICAgICAgcGFja2FnZVVSTCA9IG5ldyBVUkwoJ3BhY2thZ2UuanNvbicsIHBhY2thZ2VVUkwpXG5cbiAgICAgICAgdGhyb3cgZXJyb3JzLlVOU1VQUE9SVEVEX0VOR0lORShcbiAgICAgICAgICBgUGFja2FnZSBub3QgY29tcGF0aWJsZSB3aXRoIGVuZ2luZSAnJHtlbmdpbmV9JyAke3ZlcnNpb259LCByZXF1aXJlcyByYW5nZSAnJHtyYW5nZX0nIGRlZmluZWQgYnkgXCJlbmdpbmVzXCIgaW4gJyR7cGFja2FnZVVSTH0nYFxuICAgICAgICApXG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmV4cG9ydHMucGF0dGVybktleUNvbXBhcmUgPSBmdW5jdGlvbiBwYXR0ZXJuS2V5Q29tcGFyZShrZXlBLCBrZXlCKSB7XG4gIGNvbnN0IHBhdHRlcm5JbmRleEEgPSBrZXlBLmluZGV4T2YoJyonKVxuICBjb25zdCBwYXR0ZXJuSW5kZXhCID0ga2V5Qi5pbmRleE9mKCcqJylcbiAgY29uc3QgYmFzZUxlbmd0aEEgPSBwYXR0ZXJuSW5kZXhBID09PSAtMSA/IGtleUEubGVuZ3RoIDogcGF0dGVybkluZGV4QSArIDFcbiAgY29uc3QgYmFzZUxlbmd0aEIgPSBwYXR0ZXJuSW5kZXhCID09PSAtMSA/IGtleUIubGVuZ3RoIDogcGF0dGVybkluZGV4QiArIDFcbiAgaWYgKGJhc2VMZW5ndGhBID4gYmFzZUxlbmd0aEIpIHJldHVybiAtMVxuICBpZiAoYmFzZUxlbmd0aEIgPiBiYXNlTGVuZ3RoQSkgcmV0dXJuIDFcbiAgaWYgKHBhdHRlcm5JbmRleEEgPT09IC0xKSByZXR1cm4gMVxuICBpZiAocGF0dGVybkluZGV4QiA9PT0gLTEpIHJldHVybiAtMVxuICBpZiAoa2V5QS5sZW5ndGggPiBrZXlCLmxlbmd0aCkgcmV0dXJuIC0xXG4gIGlmIChrZXlCLmxlbmd0aCA+IGtleUEubGVuZ3RoKSByZXR1cm4gMVxuICByZXR1cm4gMFxufVxuXG5leHBvcnRzLnBhY2thZ2VUYXJnZXQgPSBmdW5jdGlvbiogKFxuICBwYWNrYWdlVVJMLFxuICB0YXJnZXQsXG4gIHBhdHRlcm5NYXRjaCxcbiAgaXNJbXBvcnRzLFxuICBvcHRzID0ge31cbikge1xuICBjb25zdCB7IGNvbmRpdGlvbnMgPSBbXSwgbWF0Y2hlZENvbmRpdGlvbnMgPSBbXSB9ID0gb3B0c1xuXG4gIGlmICh0eXBlb2YgdGFyZ2V0ID09PSAnc3RyaW5nJykge1xuICAgIGlmICghdGFyZ2V0LnN0YXJ0c1dpdGgoJy4vJykgJiYgIWlzSW1wb3J0cykge1xuICAgICAgcGFja2FnZVVSTCA9IG5ldyBVUkwoJ3BhY2thZ2UuanNvbicsIHBhY2thZ2VVUkwpXG5cbiAgICAgIHRocm93IGVycm9ycy5JTlZBTElEX1BBQ0tBR0VfVEFSR0VUKFxuICAgICAgICBgSW52YWxpZCB0YXJnZXQgJyR7dGFyZ2V0fScgZGVmaW5lZCBieSBcImV4cG9ydHNcIiBpbiAnJHtwYWNrYWdlVVJMfSdgXG4gICAgICApXG4gICAgfVxuXG4gICAgaWYgKHBhdHRlcm5NYXRjaCAhPT0gbnVsbCkge1xuICAgICAgdGFyZ2V0ID0gdGFyZ2V0LnJlcGxhY2VBbGwoJyonLCBwYXR0ZXJuTWF0Y2gpXG4gICAgfVxuXG4gICAgY29uc3Qgc3RhdHVzID0geWllbGQqIGV4cG9ydHMudXJsKHRhcmdldCwgcGFja2FnZVVSTCwgb3B0cylcblxuICAgIGlmIChzdGF0dXMpIHJldHVybiBzdGF0dXNcblxuICAgIGlmIChcbiAgICAgIHRhcmdldCA9PT0gJy4nIHx8XG4gICAgICB0YXJnZXQgPT09ICcuLicgfHxcbiAgICAgIHRhcmdldFswXSA9PT0gJy8nIHx8XG4gICAgICB0YXJnZXQuc3RhcnRzV2l0aCgnLi8nKSB8fFxuICAgICAgdGFyZ2V0LnN0YXJ0c1dpdGgoJy4uLycpXG4gICAgKSB7XG4gICAgICBjb25zdCByZXNvbHZlZCA9IHlpZWxkIHsgcmVzb2x1dGlvbjogbmV3IFVSTCh0YXJnZXQsIHBhY2thZ2VVUkwpIH1cblxuICAgICAgcmV0dXJuIHJlc29sdmVkID8gUkVTT0xWRUQgOiBZSUVMREVEXG4gICAgfVxuXG4gICAgcmV0dXJuIHlpZWxkKiBleHBvcnRzLnBhY2thZ2UodGFyZ2V0LCBwYWNrYWdlVVJMLCBvcHRzKVxuICB9XG5cbiAgaWYgKEFycmF5LmlzQXJyYXkodGFyZ2V0KSkge1xuICAgIGZvciAoY29uc3QgdGFyZ2V0VmFsdWUgb2YgdGFyZ2V0KSB7XG4gICAgICBjb25zdCBzdGF0dXMgPSB5aWVsZCogZXhwb3J0cy5wYWNrYWdlVGFyZ2V0KFxuICAgICAgICBwYWNrYWdlVVJMLFxuICAgICAgICB0YXJnZXRWYWx1ZSxcbiAgICAgICAgcGF0dGVybk1hdGNoLFxuICAgICAgICBpc0ltcG9ydHMsXG4gICAgICAgIG9wdHNcbiAgICAgIClcblxuICAgICAgaWYgKHN0YXR1cykgcmV0dXJuIHN0YXR1c1xuICAgIH1cbiAgfSBlbHNlIGlmICh0eXBlb2YgdGFyZ2V0ID09PSAnb2JqZWN0JyAmJiB0YXJnZXQgIT09IG51bGwpIHtcbiAgICBsZXQgc3RhdHVzID0gVU5SRVNPTFZFRFxuXG4gICAgZm9yIChjb25zdCBbY29uZGl0aW9uLCB0YXJnZXRWYWx1ZSwgc3Vic2V0XSBvZiBleHBvcnRzLmNvbmRpdGlvbk1hdGNoZXMoXG4gICAgICB0YXJnZXQsXG4gICAgICBjb25kaXRpb25zLFxuICAgICAgb3B0c1xuICAgICkpIHtcbiAgICAgIG1hdGNoZWRDb25kaXRpb25zLnB1c2goY29uZGl0aW9uKVxuXG4gICAgICBzdGF0dXMgfD0geWllbGQqIGV4cG9ydHMucGFja2FnZVRhcmdldChcbiAgICAgICAgcGFja2FnZVVSTCxcbiAgICAgICAgdGFyZ2V0VmFsdWUsXG4gICAgICAgIHBhdHRlcm5NYXRjaCxcbiAgICAgICAgaXNJbXBvcnRzLFxuICAgICAgICB7IC4uLm9wdHMsIGNvbmRpdGlvbnM6IHN1YnNldCB9XG4gICAgICApXG5cbiAgICAgIG1hdGNoZWRDb25kaXRpb25zLnBvcCgpXG4gICAgfVxuXG4gICAgaWYgKHN0YXR1cykgcmV0dXJuIHN0YXR1c1xuICB9XG5cbiAgcmV0dXJuIFVOUkVTT0xWRURcbn1cblxuZXhwb3J0cy5idWlsdGluVGFyZ2V0ID0gZnVuY3Rpb24qIChcbiAgcGFja2FnZVNwZWNpZmllcixcbiAgcGFja2FnZVZlcnNpb24sXG4gIHRhcmdldCxcbiAgb3B0cyA9IHt9XG4pIHtcbiAgY29uc3Qge1xuICAgIGJ1aWx0aW5Qcm90b2NvbCA9ICdidWlsdGluOicsXG4gICAgY29uZGl0aW9ucyA9IFtdLFxuICAgIG1hdGNoZWRDb25kaXRpb25zID0gW11cbiAgfSA9IG9wdHNcblxuICBpZiAodHlwZW9mIHRhcmdldCA9PT0gJ3N0cmluZycpIHtcbiAgICBjb25zdCB0YXJnZXRQYXJ0cyA9IHRhcmdldC5zcGxpdCgnQCcpXG5cbiAgICBsZXQgdGFyZ2V0TmFtZVxuICAgIGxldCB0YXJnZXRWZXJzaW9uXG5cbiAgICBpZiAodGFyZ2V0WzBdICE9PSAnQCcpIHtcbiAgICAgIHRhcmdldE5hbWUgPSB0YXJnZXRQYXJ0c1swXVxuICAgICAgdGFyZ2V0VmVyc2lvbiA9IHRhcmdldFBhcnRzWzFdIHx8IG51bGxcbiAgICB9IGVsc2Uge1xuICAgICAgdGFyZ2V0TmFtZSA9IHRhcmdldFBhcnRzLnNsaWNlKDAsIDIpLmpvaW4oJ0AnKVxuICAgICAgdGFyZ2V0VmVyc2lvbiA9IHRhcmdldFBhcnRzWzJdIHx8IG51bGxcbiAgICB9XG5cbiAgICBpZiAocGFja2FnZVNwZWNpZmllciA9PT0gdGFyZ2V0TmFtZSkge1xuICAgICAgaWYgKHBhY2thZ2VWZXJzaW9uID09PSBudWxsICYmIHRhcmdldFZlcnNpb24gPT09IG51bGwpIHtcbiAgICAgICAgY29uc3QgcmVzb2x2ZWQgPSB5aWVsZCB7XG4gICAgICAgICAgcmVzb2x1dGlvbjogbmV3IFVSTChidWlsdGluUHJvdG9jb2wgKyBwYWNrYWdlU3BlY2lmaWVyKVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlc29sdmVkID8gUkVTT0xWRUQgOiBZSUVMREVEXG4gICAgICB9XG5cbiAgICAgIGxldCB2ZXJzaW9uID0gbnVsbFxuXG4gICAgICBpZiAocGFja2FnZVZlcnNpb24gPT09IG51bGwpIHtcbiAgICAgICAgdmVyc2lvbiA9IHRhcmdldFZlcnNpb25cbiAgICAgIH0gZWxzZSBpZiAodGFyZ2V0VmVyc2lvbiA9PT0gbnVsbCB8fCBwYWNrYWdlVmVyc2lvbiA9PT0gdGFyZ2V0VmVyc2lvbikge1xuICAgICAgICB2ZXJzaW9uID0gcGFja2FnZVZlcnNpb25cbiAgICAgIH1cblxuICAgICAgaWYgKHZlcnNpb24gIT09IG51bGwpIHtcbiAgICAgICAgY29uc3QgcmVzb2x2ZWQgPSB5aWVsZCB7XG4gICAgICAgICAgcmVzb2x1dGlvbjogbmV3IFVSTChcbiAgICAgICAgICAgIGJ1aWx0aW5Qcm90b2NvbCArIHBhY2thZ2VTcGVjaWZpZXIgKyAnQCcgKyB2ZXJzaW9uXG4gICAgICAgICAgKVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlc29sdmVkID8gUkVTT0xWRUQgOiBZSUVMREVEXG4gICAgICB9XG4gICAgfVxuICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkodGFyZ2V0KSkge1xuICAgIGZvciAoY29uc3QgdGFyZ2V0VmFsdWUgb2YgdGFyZ2V0KSB7XG4gICAgICBjb25zdCBzdGF0dXMgPSB5aWVsZCogZXhwb3J0cy5idWlsdGluVGFyZ2V0KFxuICAgICAgICBwYWNrYWdlU3BlY2lmaWVyLFxuICAgICAgICBwYWNrYWdlVmVyc2lvbixcbiAgICAgICAgdGFyZ2V0VmFsdWUsXG4gICAgICAgIG9wdHNcbiAgICAgIClcblxuICAgICAgaWYgKHN0YXR1cykgcmV0dXJuIHN0YXR1c1xuICAgIH1cbiAgfSBlbHNlIGlmICh0eXBlb2YgdGFyZ2V0ID09PSAnb2JqZWN0JyAmJiB0YXJnZXQgIT09IG51bGwpIHtcbiAgICBsZXQgc3RhdHVzID0gVU5SRVNPTFZFRFxuXG4gICAgZm9yIChjb25zdCBbY29uZGl0aW9uLCB0YXJnZXRWYWx1ZSwgc3Vic2V0XSBvZiBleHBvcnRzLmNvbmRpdGlvbk1hdGNoZXMoXG4gICAgICB0YXJnZXQsXG4gICAgICBjb25kaXRpb25zLFxuICAgICAgb3B0c1xuICAgICkpIHtcbiAgICAgIG1hdGNoZWRDb25kaXRpb25zLnB1c2goY29uZGl0aW9uKVxuXG4gICAgICBzdGF0dXMgfD0geWllbGQqIGV4cG9ydHMuYnVpbHRpblRhcmdldChcbiAgICAgICAgcGFja2FnZVNwZWNpZmllcixcbiAgICAgICAgcGFja2FnZVZlcnNpb24sXG4gICAgICAgIHRhcmdldFZhbHVlLFxuICAgICAgICB7IC4uLm9wdHMsIGNvbmRpdGlvbnM6IHN1YnNldCB9XG4gICAgICApXG5cbiAgICAgIG1hdGNoZWRDb25kaXRpb25zLnBvcCgpXG4gICAgfVxuXG4gICAgaWYgKHN0YXR1cykgcmV0dXJuIHN0YXR1c1xuICB9XG5cbiAgcmV0dXJuIFVOUkVTT0xWRURcbn1cblxuZXhwb3J0cy5jb25kaXRpb25NYXRjaGVzID0gZnVuY3Rpb24qIGNvbmRpdGlvbk1hdGNoZXMoXG4gIHRhcmdldCxcbiAgY29uZGl0aW9ucyxcbiAgb3B0cyA9IHt9XG4pIHtcbiAgaWYgKGNvbmRpdGlvbnMuZXZlcnkoKGNvbmRpdGlvbikgPT4gdHlwZW9mIGNvbmRpdGlvbiA9PT0gJ3N0cmluZycpKSB7XG4gICAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKHRhcmdldClcblxuICAgIGZvciAoY29uc3QgY29uZGl0aW9uIG9mIGtleXMpIHtcbiAgICAgIGlmIChjb25kaXRpb24gPT09ICdkZWZhdWx0JyB8fCBjb25kaXRpb25zLmluY2x1ZGVzKGNvbmRpdGlvbikpIHtcbiAgICAgICAgeWllbGQgW2NvbmRpdGlvbiwgdGFyZ2V0W2NvbmRpdGlvbl0sIGNvbmRpdGlvbnNdXG5cbiAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuXG4gIGxldCB5aWVsZGVkID0gZmFsc2VcblxuICBmb3IgKGNvbnN0IHN1YnNldCBvZiBjb25kaXRpb25zKSB7XG4gICAgaWYgKHlpZWxkKiBjb25kaXRpb25NYXRjaGVzKHRhcmdldCwgc3Vic2V0LCBvcHRzKSkge1xuICAgICAgeWllbGRlZCA9IHRydWVcbiAgICB9XG4gIH1cblxuICByZXR1cm4geWllbGRlZFxufVxuXG5leHBvcnRzLmxvb2t1cFBhY2thZ2VTY29wZSA9IGZ1bmN0aW9uKiBsb29rdXBQYWNrYWdlU2NvcGUodXJsLCBvcHRzID0ge30pIHtcbiAgY29uc3QgeyByZXNvbHV0aW9ucyA9IG51bGwgfSA9IG9wdHNcblxuICBpZiAocmVzb2x1dGlvbnMpIHtcbiAgICBmb3IgKGNvbnN0IHsgcmVzb2x1dGlvbiB9IG9mIGV4cG9ydHMucHJlcmVzb2x2ZWQoXG4gICAgICAnI3BhY2thZ2UnLFxuICAgICAgcmVzb2x1dGlvbnMsXG4gICAgICB1cmwsXG4gICAgICBvcHRzXG4gICAgKSkge1xuICAgICAgaWYgKHJlc29sdXRpb24pIHJldHVybiB5aWVsZCByZXNvbHV0aW9uXG4gICAgfVxuICB9XG5cbiAgY29uc3Qgc2NvcGVVUkwgPSBuZXcgVVJMKHVybC5ocmVmKVxuXG4gIGRvIHtcbiAgICBpZiAoc2NvcGVVUkwucGF0aG5hbWUuZW5kc1dpdGgoJy9ub2RlX21vZHVsZXMnKSkgYnJlYWtcblxuICAgIHlpZWxkIG5ldyBVUkwoJ3BhY2thZ2UuanNvbicsIHNjb3BlVVJMKVxuXG4gICAgc2NvcGVVUkwucGF0aG5hbWUgPSBzY29wZVVSTC5wYXRobmFtZS5zdWJzdHJpbmcoXG4gICAgICAwLFxuICAgICAgc2NvcGVVUkwucGF0aG5hbWUubGFzdEluZGV4T2YoJy8nKVxuICAgIClcblxuICAgIGlmIChcbiAgICAgIHNjb3BlVVJMLnBhdGhuYW1lLmxlbmd0aCA9PT0gMyAmJlxuICAgICAgZXhwb3J0cy5pc1dpbmRvd3NEcml2ZUxldHRlcihzY29wZVVSTC5wYXRobmFtZS5zdWJzdHJpbmcoMSkpXG4gICAgKSB7XG4gICAgICBicmVha1xuICAgIH1cbiAgfSB3aGlsZSAoc2NvcGVVUkwucGF0aG5hbWUgIT09ICcnICYmIHNjb3BlVVJMLnBhdGhuYW1lICE9PSAnLycpXG59XG5cbmV4cG9ydHMuZmlsZSA9IGZ1bmN0aW9uKiAoZmlsZW5hbWUsIHBhcmVudFVSTCwgaXNJbmRleCwgb3B0cyA9IHt9KSB7XG4gIGlmIChcbiAgICBmaWxlbmFtZSA9PT0gJy4nIHx8XG4gICAgZmlsZW5hbWUgPT09ICcuLicgfHxcbiAgICBmaWxlbmFtZVtmaWxlbmFtZS5sZW5ndGggLSAxXSA9PT0gJy8nIHx8XG4gICAgZmlsZW5hbWVbZmlsZW5hbWUubGVuZ3RoIC0gMV0gPT09ICdcXFxcJ1xuICApIHtcbiAgICByZXR1cm4gVU5SRVNPTFZFRFxuICB9XG5cbiAgaWYgKHBhcmVudFVSTC5wcm90b2NvbCA9PT0gJ2ZpbGU6JyAmJiAvJTJmfCU1Yy9pLnRlc3QoZmlsZW5hbWUpKSB7XG4gICAgdGhyb3cgZXJyb3JzLklOVkFMSURfTU9EVUxFX1NQRUNJRklFUihcbiAgICAgIGBNb2R1bGUgc3BlY2lmaWVyICcke2ZpbGVuYW1lfScgaXMgaW52YWxpZGBcbiAgICApXG4gIH1cblxuICBjb25zdCB7IGV4dGVuc2lvbnMgPSBbXSB9ID0gb3B0c1xuXG4gIGxldCBzdGF0dXMgPSBVTlJFU09MVkVEXG5cbiAgaWYgKCFpc0luZGV4KSB7XG4gICAgaWYgKHlpZWxkIHsgcmVzb2x1dGlvbjogbmV3IFVSTChmaWxlbmFtZSwgcGFyZW50VVJMKSB9KSB7XG4gICAgICByZXR1cm4gUkVTT0xWRURcbiAgICB9XG5cbiAgICBzdGF0dXMgPSBZSUVMREVEXG4gIH1cblxuICBmb3IgKGNvbnN0IGV4dCBvZiBleHRlbnNpb25zKSB7XG4gICAgaWYgKHlpZWxkIHsgcmVzb2x1dGlvbjogbmV3IFVSTChmaWxlbmFtZSArIGV4dCwgcGFyZW50VVJMKSB9KSB7XG4gICAgICByZXR1cm4gUkVTT0xWRURcbiAgICB9XG5cbiAgICBzdGF0dXMgPSBZSUVMREVEXG4gIH1cblxuICByZXR1cm4gc3RhdHVzXG59XG5cbmV4cG9ydHMuZGlyZWN0b3J5ID0gZnVuY3Rpb24qIChkaXJuYW1lLCBwYXJlbnRVUkwsIG9wdHMgPSB7fSkge1xuICBsZXQgZGlyZWN0b3J5VVJMXG5cbiAgaWYgKFxuICAgIGRpcm5hbWVbZGlybmFtZS5sZW5ndGggLSAxXSA9PT0gJy8nIHx8XG4gICAgZGlybmFtZVtkaXJuYW1lLmxlbmd0aCAtIDFdID09PSAnXFxcXCdcbiAgKSB7XG4gICAgZGlyZWN0b3J5VVJMID0gbmV3IFVSTChkaXJuYW1lLCBwYXJlbnRVUkwpXG4gIH0gZWxzZSB7XG4gICAgZGlyZWN0b3J5VVJMID0gbmV3IFVSTChkaXJuYW1lICsgJy8nLCBwYXJlbnRVUkwpXG4gIH1cblxuICBjb25zdCBpbmZvID0geWllbGQgeyBwYWNrYWdlOiBuZXcgVVJMKCdwYWNrYWdlLmpzb24nLCBkaXJlY3RvcnlVUkwpIH1cblxuICBpZiAoaW5mbykge1xuICAgIGlmIChpbmZvLmV4cG9ydHMpIHtcbiAgICAgIHJldHVybiB5aWVsZCogZXhwb3J0cy5wYWNrYWdlRXhwb3J0cyhcbiAgICAgICAgZGlyZWN0b3J5VVJMLFxuICAgICAgICAnLicsXG4gICAgICAgIGluZm8uZXhwb3J0cyxcbiAgICAgICAgb3B0c1xuICAgICAgKVxuICAgIH1cblxuICAgIGlmICh0eXBlb2YgaW5mby5tYWluID09PSAnc3RyaW5nJyAmJiBpbmZvLm1haW4gIT09ICcnKSB7XG4gICAgICBjb25zdCBzdGF0dXMgPSB5aWVsZCogZXhwb3J0cy5maWxlKGluZm8ubWFpbiwgZGlyZWN0b3J5VVJMLCBmYWxzZSwgb3B0cylcblxuICAgICAgaWYgKHN0YXR1cyA9PT0gUkVTT0xWRUQpIHJldHVybiBzdGF0dXNcblxuICAgICAgcmV0dXJuIHlpZWxkKiBleHBvcnRzLmRpcmVjdG9yeShpbmZvLm1haW4sIGRpcmVjdG9yeVVSTCwgb3B0cylcbiAgICB9XG4gIH1cblxuICByZXR1cm4geWllbGQqIGV4cG9ydHMuZmlsZSgnaW5kZXgnLCBkaXJlY3RvcnlVUkwsIHRydWUsIG9wdHMpXG59XG5cbi8vIGh0dHBzOi8vaW5mcmEuc3BlYy53aGF0d2cub3JnLyNhc2NpaS11cHBlci1hbHBoYVxuZnVuY3Rpb24gaXNBU0NJSVVwcGVyQWxwaGEoYykge1xuICByZXR1cm4gYyA+PSAweDQxICYmIGMgPD0gMHg1YVxufVxuXG4vLyBodHRwczovL2luZnJhLnNwZWMud2hhdHdnLm9yZy8jYXNjaWktbG93ZXItYWxwaGFcbmZ1bmN0aW9uIGlzQVNDSUlMb3dlckFscGhhKGMpIHtcbiAgcmV0dXJuIGMgPj0gMHg2MSAmJiBjIDw9IDB4N2Fcbn1cblxuLy8gaHR0cHM6Ly9pbmZyYS5zcGVjLndoYXR3Zy5vcmcvI2FzY2lpLWFscGhhXG5mdW5jdGlvbiBpc0FTQ0lJQWxwaGEoYykge1xuICByZXR1cm4gaXNBU0NJSVVwcGVyQWxwaGEoYykgfHwgaXNBU0NJSUxvd2VyQWxwaGEoYylcbn1cblxuLy8gaHR0cHM6Ly91cmwuc3BlYy53aGF0d2cub3JnLyN3aW5kb3dzLWRyaXZlLWxldHRlclxuZXhwb3J0cy5pc1dpbmRvd3NEcml2ZUxldHRlciA9IGZ1bmN0aW9uIGlzV2luZG93c0RyaXZlTGV0dGVyKGlucHV0KSB7XG4gIHJldHVybiAoXG4gICAgaW5wdXQubGVuZ3RoID49IDIgJiZcbiAgICBpc0FTQ0lJQWxwaGEoaW5wdXQuY2hhckNvZGVBdCgwKSkgJiZcbiAgICAoaW5wdXQuY2hhckNvZGVBdCgxKSA9PT0gMHgzYSB8fCBpbnB1dC5jaGFyQ29kZUF0KDEpID09PSAweDdjKVxuICApXG59XG5cbi8vIGh0dHBzOi8vdXJsLnNwZWMud2hhdHdnLm9yZy8jc3RhcnQtd2l0aC1hLXdpbmRvd3MtZHJpdmUtbGV0dGVyXG5leHBvcnRzLnN0YXJ0c1dpdGhXaW5kb3dzRHJpdmVMZXR0ZXIgPSBmdW5jdGlvbiBzdGFydHNXaXRoV2luZG93c0RyaXZlTGV0dGVyKFxuICBpbnB1dFxuKSB7XG4gIHJldHVybiAoXG4gICAgaW5wdXQubGVuZ3RoID49IDIgJiZcbiAgICBleHBvcnRzLmlzV2luZG93c0RyaXZlTGV0dGVyKGlucHV0KSAmJlxuICAgIChpbnB1dC5sZW5ndGggPT09IDIgfHxcbiAgICAgIGlucHV0LmNoYXJDb2RlQXQoMikgPT09IDB4MmYgfHxcbiAgICAgIGlucHV0LmNoYXJDb2RlQXQoMikgPT09IDB4NWMgfHxcbiAgICAgIGlucHV0LmNoYXJDb2RlQXQoMikgPT09IDB4M2YgfHxcbiAgICAgIGlucHV0LmNoYXJDb2RlQXQoMikgPT09IDB4MjMpXG4gIClcbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/bare-module-resolve/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/bare-module-resolve/lib/errors.js":
/*!********************************************************!*\
  !*** ./node_modules/bare-module-resolve/lib/errors.js ***!
  \********************************************************/
/***/ ((module) => {

eval("module.exports = class ModuleResolveError extends Error {\n  constructor(msg, code, fn = ModuleResolveError) {\n    super(`${code}: ${msg}`)\n    this.code = code\n\n    if (Error.captureStackTrace) {\n      Error.captureStackTrace(this, fn)\n    }\n  }\n\n  get name() {\n    return 'ModuleResolveError'\n  }\n\n  static INVALID_MODULE_SPECIFIER(msg) {\n    return new ModuleResolveError(\n      msg,\n      'INVALID_MODULE_SPECIFIER',\n      ModuleResolveError.INVALID_MODULE_SPECIFIER\n    )\n  }\n\n  static INVALID_PACKAGE_TARGET(msg) {\n    return new ModuleResolveError(\n      msg,\n      'INVALID_PACKAGE_TARGET',\n      ModuleResolveError.INVALID_PACKAGE_TARGET\n    )\n  }\n\n  static PACKAGE_PATH_NOT_EXPORTED(msg) {\n    return new ModuleResolveError(\n      msg,\n      'PACKAGE_PATH_NOT_EXPORTED',\n      ModuleResolveError.PACKAGE_PATH_NOT_EXPORTED\n    )\n  }\n\n  static PACKAGE_IMPORT_NOT_DEFINED(msg) {\n    return new ModuleResolveError(\n      msg,\n      'PACKAGE_IMPORT_NOT_DEFINED',\n      ModuleResolveError.PACKAGE_IMPORT_NOT_DEFINED\n    )\n  }\n\n  static UNSUPPORTED_ENGINE(msg) {\n    return new ModuleResolveError(\n      msg,\n      'UNSUPPORTED_ENGINE',\n      ModuleResolveError.UNSUPPORTED_ENGINE\n    )\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvYmFyZS1tb2R1bGUtcmVzb2x2ZS9saWIvZXJyb3JzLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQSxhQUFhLEtBQUssSUFBSSxJQUFJO0FBQzFCOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vc3RlbGxhci1wcm9jdXJlbWVudC1kYXBwLy4vbm9kZV9tb2R1bGVzL2JhcmUtbW9kdWxlLXJlc29sdmUvbGliL2Vycm9ycy5qcz9kYmI4Il0sInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZS5leHBvcnRzID0gY2xhc3MgTW9kdWxlUmVzb2x2ZUVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICBjb25zdHJ1Y3Rvcihtc2csIGNvZGUsIGZuID0gTW9kdWxlUmVzb2x2ZUVycm9yKSB7XG4gICAgc3VwZXIoYCR7Y29kZX06ICR7bXNnfWApXG4gICAgdGhpcy5jb2RlID0gY29kZVxuXG4gICAgaWYgKEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKSB7XG4gICAgICBFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSh0aGlzLCBmbilcbiAgICB9XG4gIH1cblxuICBnZXQgbmFtZSgpIHtcbiAgICByZXR1cm4gJ01vZHVsZVJlc29sdmVFcnJvcidcbiAgfVxuXG4gIHN0YXRpYyBJTlZBTElEX01PRFVMRV9TUEVDSUZJRVIobXNnKSB7XG4gICAgcmV0dXJuIG5ldyBNb2R1bGVSZXNvbHZlRXJyb3IoXG4gICAgICBtc2csXG4gICAgICAnSU5WQUxJRF9NT0RVTEVfU1BFQ0lGSUVSJyxcbiAgICAgIE1vZHVsZVJlc29sdmVFcnJvci5JTlZBTElEX01PRFVMRV9TUEVDSUZJRVJcbiAgICApXG4gIH1cblxuICBzdGF0aWMgSU5WQUxJRF9QQUNLQUdFX1RBUkdFVChtc2cpIHtcbiAgICByZXR1cm4gbmV3IE1vZHVsZVJlc29sdmVFcnJvcihcbiAgICAgIG1zZyxcbiAgICAgICdJTlZBTElEX1BBQ0tBR0VfVEFSR0VUJyxcbiAgICAgIE1vZHVsZVJlc29sdmVFcnJvci5JTlZBTElEX1BBQ0tBR0VfVEFSR0VUXG4gICAgKVxuICB9XG5cbiAgc3RhdGljIFBBQ0tBR0VfUEFUSF9OT1RfRVhQT1JURUQobXNnKSB7XG4gICAgcmV0dXJuIG5ldyBNb2R1bGVSZXNvbHZlRXJyb3IoXG4gICAgICBtc2csXG4gICAgICAnUEFDS0FHRV9QQVRIX05PVF9FWFBPUlRFRCcsXG4gICAgICBNb2R1bGVSZXNvbHZlRXJyb3IuUEFDS0FHRV9QQVRIX05PVF9FWFBPUlRFRFxuICAgIClcbiAgfVxuXG4gIHN0YXRpYyBQQUNLQUdFX0lNUE9SVF9OT1RfREVGSU5FRChtc2cpIHtcbiAgICByZXR1cm4gbmV3IE1vZHVsZVJlc29sdmVFcnJvcihcbiAgICAgIG1zZyxcbiAgICAgICdQQUNLQUdFX0lNUE9SVF9OT1RfREVGSU5FRCcsXG4gICAgICBNb2R1bGVSZXNvbHZlRXJyb3IuUEFDS0FHRV9JTVBPUlRfTk9UX0RFRklORURcbiAgICApXG4gIH1cblxuICBzdGF0aWMgVU5TVVBQT1JURURfRU5HSU5FKG1zZykge1xuICAgIHJldHVybiBuZXcgTW9kdWxlUmVzb2x2ZUVycm9yKFxuICAgICAgbXNnLFxuICAgICAgJ1VOU1VQUE9SVEVEX0VOR0lORScsXG4gICAgICBNb2R1bGVSZXNvbHZlRXJyb3IuVU5TVVBQT1JURURfRU5HSU5FXG4gICAgKVxuICB9XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/bare-module-resolve/lib/errors.js\n");

/***/ })

};
;