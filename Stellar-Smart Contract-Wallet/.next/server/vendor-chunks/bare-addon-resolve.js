/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/bare-addon-resolve";
exports.ids = ["vendor-chunks/bare-addon-resolve"];
exports.modules = {

/***/ "(ssr)/./node_modules/bare-addon-resolve/index.js":
/*!**************************************************!*\
  !*** ./node_modules/bare-addon-resolve/index.js ***!
  \**************************************************/
/***/ ((module, exports, __webpack_require__) => {

eval("const resolve = __webpack_require__(/*! bare-module-resolve */ \"(ssr)/./node_modules/bare-module-resolve/index.js\")\nconst { Version } = __webpack_require__(/*! bare-semver */ \"(ssr)/./node_modules/bare-semver/index.js\")\nconst errors = __webpack_require__(/*! ./lib/errors */ \"(ssr)/./node_modules/bare-addon-resolve/lib/errors.js\")\n\nmodule.exports = exports = function resolve(\n  specifier,\n  parentURL,\n  opts,\n  readPackage\n) {\n  if (typeof opts === 'function') {\n    readPackage = opts\n    opts = {}\n  } else if (typeof readPackage !== 'function') {\n    readPackage = defaultReadPackage\n  }\n\n  return {\n    *[Symbol.iterator]() {\n      const generator = exports.addon(specifier, parentURL, opts)\n\n      let next = generator.next()\n\n      while (next.done !== true) {\n        const value = next.value\n\n        if (value.package) {\n          next = generator.next(readPackage(value.package))\n        } else {\n          next = generator.next(yield value.resolution)\n        }\n      }\n\n      return next.value\n    },\n\n    async *[Symbol.asyncIterator]() {\n      const generator = exports.addon(specifier, parentURL, opts)\n\n      let next = generator.next()\n\n      while (next.done !== true) {\n        const value = next.value\n\n        if (value.package) {\n          next = generator.next(await readPackage(value.package))\n        } else {\n          next = generator.next(yield value.resolution)\n        }\n      }\n\n      return next.value\n    }\n  }\n}\n\nfunction defaultReadPackage() {\n  return null\n}\n\nconst { UNRESOLVED, YIELDED, RESOLVED } = resolve.constants\n\nexports.constants = {\n  UNRESOLVED,\n  YIELDED,\n  RESOLVED\n}\n\nexports.addon = function* (specifier, parentURL, opts = {}) {\n  const { resolutions = null } = opts\n\n  if (exports.startsWithWindowsDriveLetter(specifier)) {\n    specifier = '/' + specifier\n  }\n\n  let status\n\n  if (resolutions) {\n    status = yield* resolve.preresolved(specifier, resolutions, parentURL, opts)\n\n    if (status) return status\n  }\n\n  status = yield* exports.url(specifier, parentURL, opts)\n\n  if (status) return status\n\n  let version = null\n\n  const i = specifier.lastIndexOf('@')\n\n  if (i > 0) {\n    version = specifier.substring(i + 1)\n\n    try {\n      Version.parse(version)\n\n      specifier = specifier.substring(0, i)\n    } catch {\n      version = null\n    }\n  }\n\n  if (\n    specifier === '.' ||\n    specifier === '..' ||\n    specifier[0] === '/' ||\n    specifier[0] === '\\\\' ||\n    specifier.startsWith('./') ||\n    specifier.startsWith('.\\\\') ||\n    specifier.startsWith('../') ||\n    specifier.startsWith('..\\\\')\n  ) {\n    return yield* exports.directory(specifier, version, parentURL, opts)\n  }\n\n  return yield* exports.package(specifier, version, parentURL, opts)\n}\n\nexports.url = function* (url, parentURL, opts = {}) {\n  let resolution\n  try {\n    resolution = new URL(url)\n  } catch {\n    return UNRESOLVED\n  }\n\n  const resolved = yield { resolution }\n\n  return resolved ? RESOLVED : YIELDED\n}\n\nexports[\"package\"] = function* (\n  packageSpecifier,\n  packageVersion,\n  parentURL,\n  opts = {}\n) {\n  if (packageSpecifier === '') {\n    throw errors.INVALID_ADDON_SPECIFIER(\n      `Addon specifier '${packageSpecifier}' is not a valid package name`\n    )\n  }\n\n  let packageName\n\n  if (packageSpecifier[0] !== '@') {\n    packageName = packageSpecifier.split('/', 1).join()\n  } else {\n    if (!packageSpecifier.includes('/')) {\n      throw errors.INVALID_ADDON_SPECIFIER(\n        `Addon specifier '${packageSpecifier}' is not a valid package name`\n      )\n    }\n\n    packageName = packageSpecifier.split('/', 2).join('/')\n  }\n\n  if (\n    packageName[0] === '.' ||\n    packageName.includes('\\\\') ||\n    packageName.includes('%')\n  ) {\n    throw errors.INVALID_ADDON_SPECIFIER(\n      `Addon specifier '${packageSpecifier}' is not a valid package name`\n    )\n  }\n\n  const packageSubpath = '.' + packageSpecifier.substring(packageName.length)\n\n  const status = yield* exports.packageSelf(\n    packageName,\n    packageSubpath,\n    packageVersion,\n    parentURL,\n    opts\n  )\n\n  if (status) return status\n\n  parentURL = new URL(parentURL.href)\n\n  do {\n    const packageURL = new URL('node_modules/' + packageName + '/', parentURL)\n\n    parentURL.pathname = parentURL.pathname.substring(\n      0,\n      parentURL.pathname.lastIndexOf('/')\n    )\n\n    const info = yield { package: new URL('package.json', packageURL) }\n\n    if (info) {\n      return yield* exports.directory(\n        packageSubpath,\n        packageVersion,\n        packageURL,\n        opts\n      )\n    }\n  } while (parentURL.pathname !== '' && parentURL.pathname !== '/')\n\n  return UNRESOLVED\n}\n\nexports.packageSelf = function* (\n  packageName,\n  packageSubpath,\n  packageVersion,\n  parentURL,\n  opts = {}\n) {\n  for (const packageURL of resolve.lookupPackageScope(parentURL, opts)) {\n    const info = yield { package: packageURL }\n\n    if (info) {\n      if (info.name === packageName) {\n        return yield* exports.directory(\n          packageSubpath,\n          packageVersion,\n          packageURL,\n          opts\n        )\n      }\n\n      break\n    }\n  }\n\n  return UNRESOLVED\n}\n\nexports.lookupPrebuildsScope = function* lookupPrebuildsScope(url, opts = {}) {\n  const { resolutions = null } = opts\n\n  if (resolutions) {\n    for (const { resolution } of resolve.preresolved(\n      '#prebuilds',\n      resolutions,\n      url,\n      opts\n    )) {\n      if (resolution) return yield resolution\n    }\n  }\n\n  const scopeURL = new URL(url.href)\n\n  do {\n    yield new URL('prebuilds/', scopeURL)\n\n    scopeURL.pathname = scopeURL.pathname.substring(\n      0,\n      scopeURL.pathname.lastIndexOf('/')\n    )\n\n    if (\n      scopeURL.pathname.length === 3 &&\n      exports.isWindowsDriveLetter(scopeURL.pathname.substring(1))\n    ) {\n      break\n    }\n  } while (scopeURL.pathname !== '' && scopeURL.pathname !== '/')\n}\n\nexports.file = function* (filename, parentURL, opts = {}) {\n  if (parentURL.protocol === 'file:' && /%2f|%5c/i.test(filename)) {\n    throw errors.INVALID_ADDON_SPECIFIER(\n      `Addon specifier '${filename}' is invalid`\n    )\n  }\n\n  const { extensions = [] } = opts\n\n  let status = UNRESOLVED\n\n  for (const ext of extensions) {\n    if (yield { resolution: new URL(filename + ext, parentURL) }) {\n      return RESOLVED\n    }\n\n    status = YIELDED\n  }\n\n  return status\n}\n\nexports.directory = function* (dirname, version, parentURL, opts = {}) {\n  const {\n    host = null, // Shorthand for single host resolution\n    hosts = host !== null ? [host] : [],\n    builtins = [],\n    matchedConditions = []\n  } = opts\n\n  let directoryURL\n\n  if (\n    dirname[dirname.length - 1] === '/' ||\n    dirname[dirname.length - 1] === '\\\\'\n  ) {\n    directoryURL = new URL(dirname, parentURL)\n  } else {\n    directoryURL = new URL(dirname + '/', parentURL)\n  }\n\n  const unversioned = version === null\n\n  let name = null\n\n  const info = yield { package: new URL('package.json', directoryURL) }\n\n  if (info) {\n    if (typeof info.name === 'string' && info.name !== '') {\n      if (info.name.includes('__')) {\n        throw errors.INVALID_PACKAGE_NAME(\n          `Package name '${info.name}' is invalid`\n        )\n      }\n\n      name = info.name.replace(/\\//g, '__').replace(/^@/, '')\n    } else {\n      return UNRESOLVED\n    }\n\n    if (typeof info.version === 'string' && info.version !== '') {\n      if (version !== null && info.version !== version) return UNRESOLVED\n\n      version = info.version\n    }\n  } else {\n    return UNRESOLVED\n  }\n\n  let status\n\n  status = yield* resolve.builtinTarget(name, version, builtins, opts)\n\n  if (status) return status\n\n  for (const prebuildsURL of exports.lookupPrebuildsScope(directoryURL, opts)) {\n    status = UNRESOLVED\n\n    for (const host of hosts) {\n      const conditions = host.split('-')\n\n      matchedConditions.push(...conditions)\n\n      if (version !== null) {\n        status |= yield* exports.file(\n          host + '/' + name + '@' + version,\n          prebuildsURL,\n          opts\n        )\n      }\n\n      if (unversioned) {\n        status |= yield* exports.file(host + '/' + name, prebuildsURL, opts)\n      }\n\n      for (const _ of conditions) matchedConditions.pop()\n    }\n\n    if (status === RESOLVED) return status\n  }\n\n  return yield* exports.linked(name, version, opts)\n}\n\nexports.linked = function* (name, version = null, opts = {}) {\n  const {\n    linked = true,\n    host = null, // Shorthand for single host resolution\n    hosts = host !== null ? [host] : [],\n    matchedConditions = []\n  } = opts\n\n  if (linked === false || hosts.length === 0) return UNRESOLVED\n\n  let status = UNRESOLVED\n\n  for (const host of hosts) {\n    const [platform = null] = host.split('-', 1)\n\n    if (platform === null) continue\n\n    matchedConditions.push(platform)\n\n    status |= yield* platformArtefact(name, version, platform, opts)\n\n    matchedConditions.pop()\n  }\n\n  return status\n}\n\nfunction* platformArtefact(name, version = null, platform, opts = {}) {\n  const { linkedProtocol = 'linked:' } = opts\n\n  if (platform === 'darwin' || platform === 'ios') {\n    if (version !== null) {\n      if (\n        yield {\n          resolution: new URL(\n            `${linkedProtocol}${name}.${version}.framework/${name}.${version}`\n          )\n        }\n      ) {\n        return RESOLVED\n      }\n\n      if (platform === 'darwin') {\n        if (\n          yield {\n            resolution: new URL(`${linkedProtocol}lib${name}.${version}.dylib`)\n          }\n        ) {\n          return RESOLVED\n        }\n      }\n    }\n\n    if (\n      yield {\n        resolution: new URL(`${linkedProtocol}${name}.framework/${name}`)\n      }\n    ) {\n      return RESOLVED\n    }\n\n    if (platform === 'darwin') {\n      if (\n        yield {\n          resolution: new URL(`${linkedProtocol}lib${name}.dylib`)\n        }\n      ) {\n        return RESOLVED\n      }\n    }\n\n    return YIELDED\n  }\n\n  if (platform === 'linux' || platform === 'android') {\n    if (version !== null) {\n      if (\n        yield {\n          resolution: new URL(`${linkedProtocol}lib${name}.${version}.so`)\n        }\n      ) {\n        return RESOLVED\n      }\n    }\n\n    if (\n      yield {\n        resolution: new URL(`${linkedProtocol}lib${name}.so`)\n      }\n    ) {\n      return RESOLVED\n    }\n\n    return YIELDED\n  }\n\n  if (platform === 'win32') {\n    if (version !== null) {\n      if (\n        yield {\n          resolution: new URL(`${linkedProtocol}${name}-${version}.dll`)\n        }\n      ) {\n        return RESOLVED\n      }\n    }\n\n    if (\n      yield {\n        resolution: new URL(`${linkedProtocol}${name}.dll`)\n      }\n    ) {\n      return RESOLVED\n    }\n  }\n\n  return UNRESOLVED\n}\n\nexports.isWindowsDriveLetter = resolve.isWindowsDriveLetter\n\nexports.startsWithWindowsDriveLetter = resolve.startsWithWindowsDriveLetter\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvYmFyZS1hZGRvbi1yZXNvbHZlL2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFBLGdCQUFnQixtQkFBTyxDQUFDLDhFQUFxQjtBQUM3QyxRQUFRLFVBQVUsRUFBRSxtQkFBTyxDQUFDLDhEQUFhO0FBQ3pDLGVBQWUsbUJBQU8sQ0FBQywyRUFBYzs7QUFFckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsUUFBUSxnQ0FBZ0M7O0FBRXhDLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxhQUFhLDZDQUE2QztBQUMxRCxVQUFVLHFCQUFxQjs7QUFFL0I7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLFdBQVcsdUNBQXVDO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBLDJCQUEyQjs7QUFFM0I7QUFDQTs7QUFFQSxrQkFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLGlCQUFpQjtBQUMzQztBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLDRCQUE0QixpQkFBaUI7QUFDN0M7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixpQkFBaUI7QUFDM0M7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHlCQUF5Qjs7QUFFekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTs7QUFFQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7O0FBRXpCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSw0QkFBNEIsZ0RBQWdEO0FBQzVFLFVBQVUscUJBQXFCOztBQUUvQjtBQUNBLGlCQUFpQixhQUFhO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7O0FBRUEsWUFBWSw0Q0FBNEM7QUFDeEQ7QUFDQTtBQUNBLDBCQUEwQixTQUFTO0FBQ25DO0FBQ0E7O0FBRUEsVUFBVSxrQkFBa0I7O0FBRTVCOztBQUVBO0FBQ0EsZ0JBQWdCLGdEQUFnRDtBQUNoRTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxpQkFBaUIsb0RBQW9EO0FBQ3JFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSx1QkFBdUI7O0FBRXZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLFVBQVU7QUFDckM7QUFDQTs7QUFFQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsY0FBYyw2Q0FBNkM7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsb0VBQW9FO0FBQ3BFLFVBQVUsNkJBQTZCOztBQUV2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxlQUFlLEVBQUUsS0FBSyxHQUFHLFFBQVEsYUFBYSxLQUFLLEdBQUcsUUFBUTtBQUM3RTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxlQUFlLEtBQUssS0FBSyxHQUFHLFFBQVE7QUFDdkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSwrQkFBK0IsZUFBZSxFQUFFLEtBQUssYUFBYSxLQUFLO0FBQ3ZFO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxlQUFlLEtBQUssS0FBSztBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsZUFBZSxLQUFLLEtBQUssR0FBRyxRQUFRO0FBQ3JFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLCtCQUErQixlQUFlLEtBQUssS0FBSztBQUN4RDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLGVBQWUsRUFBRSxLQUFLLEdBQUcsUUFBUTtBQUNsRTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSwrQkFBK0IsZUFBZSxFQUFFLEtBQUs7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLDRCQUE0Qjs7QUFFNUIsb0NBQW9DIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vc3RlbGxhci1wcm9jdXJlbWVudC1kYXBwLy4vbm9kZV9tb2R1bGVzL2JhcmUtYWRkb24tcmVzb2x2ZS9pbmRleC5qcz8yZDJjIl0sInNvdXJjZXNDb250ZW50IjpbImNvbnN0IHJlc29sdmUgPSByZXF1aXJlKCdiYXJlLW1vZHVsZS1yZXNvbHZlJylcbmNvbnN0IHsgVmVyc2lvbiB9ID0gcmVxdWlyZSgnYmFyZS1zZW12ZXInKVxuY29uc3QgZXJyb3JzID0gcmVxdWlyZSgnLi9saWIvZXJyb3JzJylcblxubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzID0gZnVuY3Rpb24gcmVzb2x2ZShcbiAgc3BlY2lmaWVyLFxuICBwYXJlbnRVUkwsXG4gIG9wdHMsXG4gIHJlYWRQYWNrYWdlXG4pIHtcbiAgaWYgKHR5cGVvZiBvcHRzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmVhZFBhY2thZ2UgPSBvcHRzXG4gICAgb3B0cyA9IHt9XG4gIH0gZWxzZSBpZiAodHlwZW9mIHJlYWRQYWNrYWdlICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgcmVhZFBhY2thZ2UgPSBkZWZhdWx0UmVhZFBhY2thZ2VcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgKltTeW1ib2wuaXRlcmF0b3JdKCkge1xuICAgICAgY29uc3QgZ2VuZXJhdG9yID0gZXhwb3J0cy5hZGRvbihzcGVjaWZpZXIsIHBhcmVudFVSTCwgb3B0cylcblxuICAgICAgbGV0IG5leHQgPSBnZW5lcmF0b3IubmV4dCgpXG5cbiAgICAgIHdoaWxlIChuZXh0LmRvbmUgIT09IHRydWUpIHtcbiAgICAgICAgY29uc3QgdmFsdWUgPSBuZXh0LnZhbHVlXG5cbiAgICAgICAgaWYgKHZhbHVlLnBhY2thZ2UpIHtcbiAgICAgICAgICBuZXh0ID0gZ2VuZXJhdG9yLm5leHQocmVhZFBhY2thZ2UodmFsdWUucGFja2FnZSkpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbmV4dCA9IGdlbmVyYXRvci5uZXh0KHlpZWxkIHZhbHVlLnJlc29sdXRpb24pXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG5leHQudmFsdWVcbiAgICB9LFxuXG4gICAgYXN5bmMgKltTeW1ib2wuYXN5bmNJdGVyYXRvcl0oKSB7XG4gICAgICBjb25zdCBnZW5lcmF0b3IgPSBleHBvcnRzLmFkZG9uKHNwZWNpZmllciwgcGFyZW50VVJMLCBvcHRzKVxuXG4gICAgICBsZXQgbmV4dCA9IGdlbmVyYXRvci5uZXh0KClcblxuICAgICAgd2hpbGUgKG5leHQuZG9uZSAhPT0gdHJ1ZSkge1xuICAgICAgICBjb25zdCB2YWx1ZSA9IG5leHQudmFsdWVcblxuICAgICAgICBpZiAodmFsdWUucGFja2FnZSkge1xuICAgICAgICAgIG5leHQgPSBnZW5lcmF0b3IubmV4dChhd2FpdCByZWFkUGFja2FnZSh2YWx1ZS5wYWNrYWdlKSlcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBuZXh0ID0gZ2VuZXJhdG9yLm5leHQoeWllbGQgdmFsdWUucmVzb2x1dGlvbilcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gbmV4dC52YWx1ZVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBkZWZhdWx0UmVhZFBhY2thZ2UoKSB7XG4gIHJldHVybiBudWxsXG59XG5cbmNvbnN0IHsgVU5SRVNPTFZFRCwgWUlFTERFRCwgUkVTT0xWRUQgfSA9IHJlc29sdmUuY29uc3RhbnRzXG5cbmV4cG9ydHMuY29uc3RhbnRzID0ge1xuICBVTlJFU09MVkVELFxuICBZSUVMREVELFxuICBSRVNPTFZFRFxufVxuXG5leHBvcnRzLmFkZG9uID0gZnVuY3Rpb24qIChzcGVjaWZpZXIsIHBhcmVudFVSTCwgb3B0cyA9IHt9KSB7XG4gIGNvbnN0IHsgcmVzb2x1dGlvbnMgPSBudWxsIH0gPSBvcHRzXG5cbiAgaWYgKGV4cG9ydHMuc3RhcnRzV2l0aFdpbmRvd3NEcml2ZUxldHRlcihzcGVjaWZpZXIpKSB7XG4gICAgc3BlY2lmaWVyID0gJy8nICsgc3BlY2lmaWVyXG4gIH1cblxuICBsZXQgc3RhdHVzXG5cbiAgaWYgKHJlc29sdXRpb25zKSB7XG4gICAgc3RhdHVzID0geWllbGQqIHJlc29sdmUucHJlcmVzb2x2ZWQoc3BlY2lmaWVyLCByZXNvbHV0aW9ucywgcGFyZW50VVJMLCBvcHRzKVxuXG4gICAgaWYgKHN0YXR1cykgcmV0dXJuIHN0YXR1c1xuICB9XG5cbiAgc3RhdHVzID0geWllbGQqIGV4cG9ydHMudXJsKHNwZWNpZmllciwgcGFyZW50VVJMLCBvcHRzKVxuXG4gIGlmIChzdGF0dXMpIHJldHVybiBzdGF0dXNcblxuICBsZXQgdmVyc2lvbiA9IG51bGxcblxuICBjb25zdCBpID0gc3BlY2lmaWVyLmxhc3RJbmRleE9mKCdAJylcblxuICBpZiAoaSA+IDApIHtcbiAgICB2ZXJzaW9uID0gc3BlY2lmaWVyLnN1YnN0cmluZyhpICsgMSlcblxuICAgIHRyeSB7XG4gICAgICBWZXJzaW9uLnBhcnNlKHZlcnNpb24pXG5cbiAgICAgIHNwZWNpZmllciA9IHNwZWNpZmllci5zdWJzdHJpbmcoMCwgaSlcbiAgICB9IGNhdGNoIHtcbiAgICAgIHZlcnNpb24gPSBudWxsXG4gICAgfVxuICB9XG5cbiAgaWYgKFxuICAgIHNwZWNpZmllciA9PT0gJy4nIHx8XG4gICAgc3BlY2lmaWVyID09PSAnLi4nIHx8XG4gICAgc3BlY2lmaWVyWzBdID09PSAnLycgfHxcbiAgICBzcGVjaWZpZXJbMF0gPT09ICdcXFxcJyB8fFxuICAgIHNwZWNpZmllci5zdGFydHNXaXRoKCcuLycpIHx8XG4gICAgc3BlY2lmaWVyLnN0YXJ0c1dpdGgoJy5cXFxcJykgfHxcbiAgICBzcGVjaWZpZXIuc3RhcnRzV2l0aCgnLi4vJykgfHxcbiAgICBzcGVjaWZpZXIuc3RhcnRzV2l0aCgnLi5cXFxcJylcbiAgKSB7XG4gICAgcmV0dXJuIHlpZWxkKiBleHBvcnRzLmRpcmVjdG9yeShzcGVjaWZpZXIsIHZlcnNpb24sIHBhcmVudFVSTCwgb3B0cylcbiAgfVxuXG4gIHJldHVybiB5aWVsZCogZXhwb3J0cy5wYWNrYWdlKHNwZWNpZmllciwgdmVyc2lvbiwgcGFyZW50VVJMLCBvcHRzKVxufVxuXG5leHBvcnRzLnVybCA9IGZ1bmN0aW9uKiAodXJsLCBwYXJlbnRVUkwsIG9wdHMgPSB7fSkge1xuICBsZXQgcmVzb2x1dGlvblxuICB0cnkge1xuICAgIHJlc29sdXRpb24gPSBuZXcgVVJMKHVybClcbiAgfSBjYXRjaCB7XG4gICAgcmV0dXJuIFVOUkVTT0xWRURcbiAgfVxuXG4gIGNvbnN0IHJlc29sdmVkID0geWllbGQgeyByZXNvbHV0aW9uIH1cblxuICByZXR1cm4gcmVzb2x2ZWQgPyBSRVNPTFZFRCA6IFlJRUxERURcbn1cblxuZXhwb3J0cy5wYWNrYWdlID0gZnVuY3Rpb24qIChcbiAgcGFja2FnZVNwZWNpZmllcixcbiAgcGFja2FnZVZlcnNpb24sXG4gIHBhcmVudFVSTCxcbiAgb3B0cyA9IHt9XG4pIHtcbiAgaWYgKHBhY2thZ2VTcGVjaWZpZXIgPT09ICcnKSB7XG4gICAgdGhyb3cgZXJyb3JzLklOVkFMSURfQURET05fU1BFQ0lGSUVSKFxuICAgICAgYEFkZG9uIHNwZWNpZmllciAnJHtwYWNrYWdlU3BlY2lmaWVyfScgaXMgbm90IGEgdmFsaWQgcGFja2FnZSBuYW1lYFxuICAgIClcbiAgfVxuXG4gIGxldCBwYWNrYWdlTmFtZVxuXG4gIGlmIChwYWNrYWdlU3BlY2lmaWVyWzBdICE9PSAnQCcpIHtcbiAgICBwYWNrYWdlTmFtZSA9IHBhY2thZ2VTcGVjaWZpZXIuc3BsaXQoJy8nLCAxKS5qb2luKClcbiAgfSBlbHNlIHtcbiAgICBpZiAoIXBhY2thZ2VTcGVjaWZpZXIuaW5jbHVkZXMoJy8nKSkge1xuICAgICAgdGhyb3cgZXJyb3JzLklOVkFMSURfQURET05fU1BFQ0lGSUVSKFxuICAgICAgICBgQWRkb24gc3BlY2lmaWVyICcke3BhY2thZ2VTcGVjaWZpZXJ9JyBpcyBub3QgYSB2YWxpZCBwYWNrYWdlIG5hbWVgXG4gICAgICApXG4gICAgfVxuXG4gICAgcGFja2FnZU5hbWUgPSBwYWNrYWdlU3BlY2lmaWVyLnNwbGl0KCcvJywgMikuam9pbignLycpXG4gIH1cblxuICBpZiAoXG4gICAgcGFja2FnZU5hbWVbMF0gPT09ICcuJyB8fFxuICAgIHBhY2thZ2VOYW1lLmluY2x1ZGVzKCdcXFxcJykgfHxcbiAgICBwYWNrYWdlTmFtZS5pbmNsdWRlcygnJScpXG4gICkge1xuICAgIHRocm93IGVycm9ycy5JTlZBTElEX0FERE9OX1NQRUNJRklFUihcbiAgICAgIGBBZGRvbiBzcGVjaWZpZXIgJyR7cGFja2FnZVNwZWNpZmllcn0nIGlzIG5vdCBhIHZhbGlkIHBhY2thZ2UgbmFtZWBcbiAgICApXG4gIH1cblxuICBjb25zdCBwYWNrYWdlU3VicGF0aCA9ICcuJyArIHBhY2thZ2VTcGVjaWZpZXIuc3Vic3RyaW5nKHBhY2thZ2VOYW1lLmxlbmd0aClcblxuICBjb25zdCBzdGF0dXMgPSB5aWVsZCogZXhwb3J0cy5wYWNrYWdlU2VsZihcbiAgICBwYWNrYWdlTmFtZSxcbiAgICBwYWNrYWdlU3VicGF0aCxcbiAgICBwYWNrYWdlVmVyc2lvbixcbiAgICBwYXJlbnRVUkwsXG4gICAgb3B0c1xuICApXG5cbiAgaWYgKHN0YXR1cykgcmV0dXJuIHN0YXR1c1xuXG4gIHBhcmVudFVSTCA9IG5ldyBVUkwocGFyZW50VVJMLmhyZWYpXG5cbiAgZG8ge1xuICAgIGNvbnN0IHBhY2thZ2VVUkwgPSBuZXcgVVJMKCdub2RlX21vZHVsZXMvJyArIHBhY2thZ2VOYW1lICsgJy8nLCBwYXJlbnRVUkwpXG5cbiAgICBwYXJlbnRVUkwucGF0aG5hbWUgPSBwYXJlbnRVUkwucGF0aG5hbWUuc3Vic3RyaW5nKFxuICAgICAgMCxcbiAgICAgIHBhcmVudFVSTC5wYXRobmFtZS5sYXN0SW5kZXhPZignLycpXG4gICAgKVxuXG4gICAgY29uc3QgaW5mbyA9IHlpZWxkIHsgcGFja2FnZTogbmV3IFVSTCgncGFja2FnZS5qc29uJywgcGFja2FnZVVSTCkgfVxuXG4gICAgaWYgKGluZm8pIHtcbiAgICAgIHJldHVybiB5aWVsZCogZXhwb3J0cy5kaXJlY3RvcnkoXG4gICAgICAgIHBhY2thZ2VTdWJwYXRoLFxuICAgICAgICBwYWNrYWdlVmVyc2lvbixcbiAgICAgICAgcGFja2FnZVVSTCxcbiAgICAgICAgb3B0c1xuICAgICAgKVxuICAgIH1cbiAgfSB3aGlsZSAocGFyZW50VVJMLnBhdGhuYW1lICE9PSAnJyAmJiBwYXJlbnRVUkwucGF0aG5hbWUgIT09ICcvJylcblxuICByZXR1cm4gVU5SRVNPTFZFRFxufVxuXG5leHBvcnRzLnBhY2thZ2VTZWxmID0gZnVuY3Rpb24qIChcbiAgcGFja2FnZU5hbWUsXG4gIHBhY2thZ2VTdWJwYXRoLFxuICBwYWNrYWdlVmVyc2lvbixcbiAgcGFyZW50VVJMLFxuICBvcHRzID0ge31cbikge1xuICBmb3IgKGNvbnN0IHBhY2thZ2VVUkwgb2YgcmVzb2x2ZS5sb29rdXBQYWNrYWdlU2NvcGUocGFyZW50VVJMLCBvcHRzKSkge1xuICAgIGNvbnN0IGluZm8gPSB5aWVsZCB7IHBhY2thZ2U6IHBhY2thZ2VVUkwgfVxuXG4gICAgaWYgKGluZm8pIHtcbiAgICAgIGlmIChpbmZvLm5hbWUgPT09IHBhY2thZ2VOYW1lKSB7XG4gICAgICAgIHJldHVybiB5aWVsZCogZXhwb3J0cy5kaXJlY3RvcnkoXG4gICAgICAgICAgcGFja2FnZVN1YnBhdGgsXG4gICAgICAgICAgcGFja2FnZVZlcnNpb24sXG4gICAgICAgICAgcGFja2FnZVVSTCxcbiAgICAgICAgICBvcHRzXG4gICAgICAgIClcbiAgICAgIH1cblxuICAgICAgYnJlYWtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gVU5SRVNPTFZFRFxufVxuXG5leHBvcnRzLmxvb2t1cFByZWJ1aWxkc1Njb3BlID0gZnVuY3Rpb24qIGxvb2t1cFByZWJ1aWxkc1Njb3BlKHVybCwgb3B0cyA9IHt9KSB7XG4gIGNvbnN0IHsgcmVzb2x1dGlvbnMgPSBudWxsIH0gPSBvcHRzXG5cbiAgaWYgKHJlc29sdXRpb25zKSB7XG4gICAgZm9yIChjb25zdCB7IHJlc29sdXRpb24gfSBvZiByZXNvbHZlLnByZXJlc29sdmVkKFxuICAgICAgJyNwcmVidWlsZHMnLFxuICAgICAgcmVzb2x1dGlvbnMsXG4gICAgICB1cmwsXG4gICAgICBvcHRzXG4gICAgKSkge1xuICAgICAgaWYgKHJlc29sdXRpb24pIHJldHVybiB5aWVsZCByZXNvbHV0aW9uXG4gICAgfVxuICB9XG5cbiAgY29uc3Qgc2NvcGVVUkwgPSBuZXcgVVJMKHVybC5ocmVmKVxuXG4gIGRvIHtcbiAgICB5aWVsZCBuZXcgVVJMKCdwcmVidWlsZHMvJywgc2NvcGVVUkwpXG5cbiAgICBzY29wZVVSTC5wYXRobmFtZSA9IHNjb3BlVVJMLnBhdGhuYW1lLnN1YnN0cmluZyhcbiAgICAgIDAsXG4gICAgICBzY29wZVVSTC5wYXRobmFtZS5sYXN0SW5kZXhPZignLycpXG4gICAgKVxuXG4gICAgaWYgKFxuICAgICAgc2NvcGVVUkwucGF0aG5hbWUubGVuZ3RoID09PSAzICYmXG4gICAgICBleHBvcnRzLmlzV2luZG93c0RyaXZlTGV0dGVyKHNjb3BlVVJMLnBhdGhuYW1lLnN1YnN0cmluZygxKSlcbiAgICApIHtcbiAgICAgIGJyZWFrXG4gICAgfVxuICB9IHdoaWxlIChzY29wZVVSTC5wYXRobmFtZSAhPT0gJycgJiYgc2NvcGVVUkwucGF0aG5hbWUgIT09ICcvJylcbn1cblxuZXhwb3J0cy5maWxlID0gZnVuY3Rpb24qIChmaWxlbmFtZSwgcGFyZW50VVJMLCBvcHRzID0ge30pIHtcbiAgaWYgKHBhcmVudFVSTC5wcm90b2NvbCA9PT0gJ2ZpbGU6JyAmJiAvJTJmfCU1Yy9pLnRlc3QoZmlsZW5hbWUpKSB7XG4gICAgdGhyb3cgZXJyb3JzLklOVkFMSURfQURET05fU1BFQ0lGSUVSKFxuICAgICAgYEFkZG9uIHNwZWNpZmllciAnJHtmaWxlbmFtZX0nIGlzIGludmFsaWRgXG4gICAgKVxuICB9XG5cbiAgY29uc3QgeyBleHRlbnNpb25zID0gW10gfSA9IG9wdHNcblxuICBsZXQgc3RhdHVzID0gVU5SRVNPTFZFRFxuXG4gIGZvciAoY29uc3QgZXh0IG9mIGV4dGVuc2lvbnMpIHtcbiAgICBpZiAoeWllbGQgeyByZXNvbHV0aW9uOiBuZXcgVVJMKGZpbGVuYW1lICsgZXh0LCBwYXJlbnRVUkwpIH0pIHtcbiAgICAgIHJldHVybiBSRVNPTFZFRFxuICAgIH1cblxuICAgIHN0YXR1cyA9IFlJRUxERURcbiAgfVxuXG4gIHJldHVybiBzdGF0dXNcbn1cblxuZXhwb3J0cy5kaXJlY3RvcnkgPSBmdW5jdGlvbiogKGRpcm5hbWUsIHZlcnNpb24sIHBhcmVudFVSTCwgb3B0cyA9IHt9KSB7XG4gIGNvbnN0IHtcbiAgICBob3N0ID0gbnVsbCwgLy8gU2hvcnRoYW5kIGZvciBzaW5nbGUgaG9zdCByZXNvbHV0aW9uXG4gICAgaG9zdHMgPSBob3N0ICE9PSBudWxsID8gW2hvc3RdIDogW10sXG4gICAgYnVpbHRpbnMgPSBbXSxcbiAgICBtYXRjaGVkQ29uZGl0aW9ucyA9IFtdXG4gIH0gPSBvcHRzXG5cbiAgbGV0IGRpcmVjdG9yeVVSTFxuXG4gIGlmIChcbiAgICBkaXJuYW1lW2Rpcm5hbWUubGVuZ3RoIC0gMV0gPT09ICcvJyB8fFxuICAgIGRpcm5hbWVbZGlybmFtZS5sZW5ndGggLSAxXSA9PT0gJ1xcXFwnXG4gICkge1xuICAgIGRpcmVjdG9yeVVSTCA9IG5ldyBVUkwoZGlybmFtZSwgcGFyZW50VVJMKVxuICB9IGVsc2Uge1xuICAgIGRpcmVjdG9yeVVSTCA9IG5ldyBVUkwoZGlybmFtZSArICcvJywgcGFyZW50VVJMKVxuICB9XG5cbiAgY29uc3QgdW52ZXJzaW9uZWQgPSB2ZXJzaW9uID09PSBudWxsXG5cbiAgbGV0IG5hbWUgPSBudWxsXG5cbiAgY29uc3QgaW5mbyA9IHlpZWxkIHsgcGFja2FnZTogbmV3IFVSTCgncGFja2FnZS5qc29uJywgZGlyZWN0b3J5VVJMKSB9XG5cbiAgaWYgKGluZm8pIHtcbiAgICBpZiAodHlwZW9mIGluZm8ubmFtZSA9PT0gJ3N0cmluZycgJiYgaW5mby5uYW1lICE9PSAnJykge1xuICAgICAgaWYgKGluZm8ubmFtZS5pbmNsdWRlcygnX18nKSkge1xuICAgICAgICB0aHJvdyBlcnJvcnMuSU5WQUxJRF9QQUNLQUdFX05BTUUoXG4gICAgICAgICAgYFBhY2thZ2UgbmFtZSAnJHtpbmZvLm5hbWV9JyBpcyBpbnZhbGlkYFxuICAgICAgICApXG4gICAgICB9XG5cbiAgICAgIG5hbWUgPSBpbmZvLm5hbWUucmVwbGFjZSgvXFwvL2csICdfXycpLnJlcGxhY2UoL15ALywgJycpXG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBVTlJFU09MVkVEXG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBpbmZvLnZlcnNpb24gPT09ICdzdHJpbmcnICYmIGluZm8udmVyc2lvbiAhPT0gJycpIHtcbiAgICAgIGlmICh2ZXJzaW9uICE9PSBudWxsICYmIGluZm8udmVyc2lvbiAhPT0gdmVyc2lvbikgcmV0dXJuIFVOUkVTT0xWRURcblxuICAgICAgdmVyc2lvbiA9IGluZm8udmVyc2lvblxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gVU5SRVNPTFZFRFxuICB9XG5cbiAgbGV0IHN0YXR1c1xuXG4gIHN0YXR1cyA9IHlpZWxkKiByZXNvbHZlLmJ1aWx0aW5UYXJnZXQobmFtZSwgdmVyc2lvbiwgYnVpbHRpbnMsIG9wdHMpXG5cbiAgaWYgKHN0YXR1cykgcmV0dXJuIHN0YXR1c1xuXG4gIGZvciAoY29uc3QgcHJlYnVpbGRzVVJMIG9mIGV4cG9ydHMubG9va3VwUHJlYnVpbGRzU2NvcGUoZGlyZWN0b3J5VVJMLCBvcHRzKSkge1xuICAgIHN0YXR1cyA9IFVOUkVTT0xWRURcblxuICAgIGZvciAoY29uc3QgaG9zdCBvZiBob3N0cykge1xuICAgICAgY29uc3QgY29uZGl0aW9ucyA9IGhvc3Quc3BsaXQoJy0nKVxuXG4gICAgICBtYXRjaGVkQ29uZGl0aW9ucy5wdXNoKC4uLmNvbmRpdGlvbnMpXG5cbiAgICAgIGlmICh2ZXJzaW9uICE9PSBudWxsKSB7XG4gICAgICAgIHN0YXR1cyB8PSB5aWVsZCogZXhwb3J0cy5maWxlKFxuICAgICAgICAgIGhvc3QgKyAnLycgKyBuYW1lICsgJ0AnICsgdmVyc2lvbixcbiAgICAgICAgICBwcmVidWlsZHNVUkwsXG4gICAgICAgICAgb3B0c1xuICAgICAgICApXG4gICAgICB9XG5cbiAgICAgIGlmICh1bnZlcnNpb25lZCkge1xuICAgICAgICBzdGF0dXMgfD0geWllbGQqIGV4cG9ydHMuZmlsZShob3N0ICsgJy8nICsgbmFtZSwgcHJlYnVpbGRzVVJMLCBvcHRzKVxuICAgICAgfVxuXG4gICAgICBmb3IgKGNvbnN0IF8gb2YgY29uZGl0aW9ucykgbWF0Y2hlZENvbmRpdGlvbnMucG9wKClcbiAgICB9XG5cbiAgICBpZiAoc3RhdHVzID09PSBSRVNPTFZFRCkgcmV0dXJuIHN0YXR1c1xuICB9XG5cbiAgcmV0dXJuIHlpZWxkKiBleHBvcnRzLmxpbmtlZChuYW1lLCB2ZXJzaW9uLCBvcHRzKVxufVxuXG5leHBvcnRzLmxpbmtlZCA9IGZ1bmN0aW9uKiAobmFtZSwgdmVyc2lvbiA9IG51bGwsIG9wdHMgPSB7fSkge1xuICBjb25zdCB7XG4gICAgbGlua2VkID0gdHJ1ZSxcbiAgICBob3N0ID0gbnVsbCwgLy8gU2hvcnRoYW5kIGZvciBzaW5nbGUgaG9zdCByZXNvbHV0aW9uXG4gICAgaG9zdHMgPSBob3N0ICE9PSBudWxsID8gW2hvc3RdIDogW10sXG4gICAgbWF0Y2hlZENvbmRpdGlvbnMgPSBbXVxuICB9ID0gb3B0c1xuXG4gIGlmIChsaW5rZWQgPT09IGZhbHNlIHx8IGhvc3RzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIFVOUkVTT0xWRURcblxuICBsZXQgc3RhdHVzID0gVU5SRVNPTFZFRFxuXG4gIGZvciAoY29uc3QgaG9zdCBvZiBob3N0cykge1xuICAgIGNvbnN0IFtwbGF0Zm9ybSA9IG51bGxdID0gaG9zdC5zcGxpdCgnLScsIDEpXG5cbiAgICBpZiAocGxhdGZvcm0gPT09IG51bGwpIGNvbnRpbnVlXG5cbiAgICBtYXRjaGVkQ29uZGl0aW9ucy5wdXNoKHBsYXRmb3JtKVxuXG4gICAgc3RhdHVzIHw9IHlpZWxkKiBwbGF0Zm9ybUFydGVmYWN0KG5hbWUsIHZlcnNpb24sIHBsYXRmb3JtLCBvcHRzKVxuXG4gICAgbWF0Y2hlZENvbmRpdGlvbnMucG9wKClcbiAgfVxuXG4gIHJldHVybiBzdGF0dXNcbn1cblxuZnVuY3Rpb24qIHBsYXRmb3JtQXJ0ZWZhY3QobmFtZSwgdmVyc2lvbiA9IG51bGwsIHBsYXRmb3JtLCBvcHRzID0ge30pIHtcbiAgY29uc3QgeyBsaW5rZWRQcm90b2NvbCA9ICdsaW5rZWQ6JyB9ID0gb3B0c1xuXG4gIGlmIChwbGF0Zm9ybSA9PT0gJ2RhcndpbicgfHwgcGxhdGZvcm0gPT09ICdpb3MnKSB7XG4gICAgaWYgKHZlcnNpb24gIT09IG51bGwpIHtcbiAgICAgIGlmIChcbiAgICAgICAgeWllbGQge1xuICAgICAgICAgIHJlc29sdXRpb246IG5ldyBVUkwoXG4gICAgICAgICAgICBgJHtsaW5rZWRQcm90b2NvbH0ke25hbWV9LiR7dmVyc2lvbn0uZnJhbWV3b3JrLyR7bmFtZX0uJHt2ZXJzaW9ufWBcbiAgICAgICAgICApXG4gICAgICAgIH1cbiAgICAgICkge1xuICAgICAgICByZXR1cm4gUkVTT0xWRURcbiAgICAgIH1cblxuICAgICAgaWYgKHBsYXRmb3JtID09PSAnZGFyd2luJykge1xuICAgICAgICBpZiAoXG4gICAgICAgICAgeWllbGQge1xuICAgICAgICAgICAgcmVzb2x1dGlvbjogbmV3IFVSTChgJHtsaW5rZWRQcm90b2NvbH1saWIke25hbWV9LiR7dmVyc2lvbn0uZHlsaWJgKVxuICAgICAgICAgIH1cbiAgICAgICAgKSB7XG4gICAgICAgICAgcmV0dXJuIFJFU09MVkVEXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoXG4gICAgICB5aWVsZCB7XG4gICAgICAgIHJlc29sdXRpb246IG5ldyBVUkwoYCR7bGlua2VkUHJvdG9jb2x9JHtuYW1lfS5mcmFtZXdvcmsvJHtuYW1lfWApXG4gICAgICB9XG4gICAgKSB7XG4gICAgICByZXR1cm4gUkVTT0xWRURcbiAgICB9XG5cbiAgICBpZiAocGxhdGZvcm0gPT09ICdkYXJ3aW4nKSB7XG4gICAgICBpZiAoXG4gICAgICAgIHlpZWxkIHtcbiAgICAgICAgICByZXNvbHV0aW9uOiBuZXcgVVJMKGAke2xpbmtlZFByb3RvY29sfWxpYiR7bmFtZX0uZHlsaWJgKVxuICAgICAgICB9XG4gICAgICApIHtcbiAgICAgICAgcmV0dXJuIFJFU09MVkVEXG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIFlJRUxERURcbiAgfVxuXG4gIGlmIChwbGF0Zm9ybSA9PT0gJ2xpbnV4JyB8fCBwbGF0Zm9ybSA9PT0gJ2FuZHJvaWQnKSB7XG4gICAgaWYgKHZlcnNpb24gIT09IG51bGwpIHtcbiAgICAgIGlmIChcbiAgICAgICAgeWllbGQge1xuICAgICAgICAgIHJlc29sdXRpb246IG5ldyBVUkwoYCR7bGlua2VkUHJvdG9jb2x9bGliJHtuYW1lfS4ke3ZlcnNpb259LnNvYClcbiAgICAgICAgfVxuICAgICAgKSB7XG4gICAgICAgIHJldHVybiBSRVNPTFZFRFxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChcbiAgICAgIHlpZWxkIHtcbiAgICAgICAgcmVzb2x1dGlvbjogbmV3IFVSTChgJHtsaW5rZWRQcm90b2NvbH1saWIke25hbWV9LnNvYClcbiAgICAgIH1cbiAgICApIHtcbiAgICAgIHJldHVybiBSRVNPTFZFRFxuICAgIH1cblxuICAgIHJldHVybiBZSUVMREVEXG4gIH1cblxuICBpZiAocGxhdGZvcm0gPT09ICd3aW4zMicpIHtcbiAgICBpZiAodmVyc2lvbiAhPT0gbnVsbCkge1xuICAgICAgaWYgKFxuICAgICAgICB5aWVsZCB7XG4gICAgICAgICAgcmVzb2x1dGlvbjogbmV3IFVSTChgJHtsaW5rZWRQcm90b2NvbH0ke25hbWV9LSR7dmVyc2lvbn0uZGxsYClcbiAgICAgICAgfVxuICAgICAgKSB7XG4gICAgICAgIHJldHVybiBSRVNPTFZFRFxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChcbiAgICAgIHlpZWxkIHtcbiAgICAgICAgcmVzb2x1dGlvbjogbmV3IFVSTChgJHtsaW5rZWRQcm90b2NvbH0ke25hbWV9LmRsbGApXG4gICAgICB9XG4gICAgKSB7XG4gICAgICByZXR1cm4gUkVTT0xWRURcbiAgICB9XG4gIH1cblxuICByZXR1cm4gVU5SRVNPTFZFRFxufVxuXG5leHBvcnRzLmlzV2luZG93c0RyaXZlTGV0dGVyID0gcmVzb2x2ZS5pc1dpbmRvd3NEcml2ZUxldHRlclxuXG5leHBvcnRzLnN0YXJ0c1dpdGhXaW5kb3dzRHJpdmVMZXR0ZXIgPSByZXNvbHZlLnN0YXJ0c1dpdGhXaW5kb3dzRHJpdmVMZXR0ZXJcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/bare-addon-resolve/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/bare-addon-resolve/lib/errors.js":
/*!*******************************************************!*\
  !*** ./node_modules/bare-addon-resolve/lib/errors.js ***!
  \*******************************************************/
/***/ ((module) => {

eval("module.exports = class AddonResolveError extends Error {\n  constructor(msg, code, fn = AddonResolveError) {\n    super(`${code}: ${msg}`)\n    this.code = code\n\n    if (Error.captureStackTrace) {\n      Error.captureStackTrace(this, fn)\n    }\n  }\n\n  get name() {\n    return 'AddonResolveError'\n  }\n\n  static INVALID_ADDON_SPECIFIER(msg) {\n    return new AddonResolveError(\n      msg,\n      'INVALID_ADDON_SPECIFIER',\n      AddonResolveError.INVALID_ADDON_SPECIFIER\n    )\n  }\n\n  static INVALID_PACKAGE_NAME(msg) {\n    return new AddonResolveError(\n      msg,\n      'INVALID_PACKAGE_NAME',\n      AddonResolveError.INVALID_PACKAGE_NAME\n    )\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvYmFyZS1hZGRvbi1yZXNvbHZlL2xpYi9lcnJvcnMuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBLGFBQWEsS0FBSyxJQUFJLElBQUk7QUFDMUI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9zdGVsbGFyLXByb2N1cmVtZW50LWRhcHAvLi9ub2RlX21vZHVsZXMvYmFyZS1hZGRvbi1yZXNvbHZlL2xpYi9lcnJvcnMuanM/NTAzNCJdLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9IGNsYXNzIEFkZG9uUmVzb2x2ZUVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICBjb25zdHJ1Y3Rvcihtc2csIGNvZGUsIGZuID0gQWRkb25SZXNvbHZlRXJyb3IpIHtcbiAgICBzdXBlcihgJHtjb2RlfTogJHttc2d9YClcbiAgICB0aGlzLmNvZGUgPSBjb2RlXG5cbiAgICBpZiAoRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UpIHtcbiAgICAgIEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKHRoaXMsIGZuKVxuICAgIH1cbiAgfVxuXG4gIGdldCBuYW1lKCkge1xuICAgIHJldHVybiAnQWRkb25SZXNvbHZlRXJyb3InXG4gIH1cblxuICBzdGF0aWMgSU5WQUxJRF9BRERPTl9TUEVDSUZJRVIobXNnKSB7XG4gICAgcmV0dXJuIG5ldyBBZGRvblJlc29sdmVFcnJvcihcbiAgICAgIG1zZyxcbiAgICAgICdJTlZBTElEX0FERE9OX1NQRUNJRklFUicsXG4gICAgICBBZGRvblJlc29sdmVFcnJvci5JTlZBTElEX0FERE9OX1NQRUNJRklFUlxuICAgIClcbiAgfVxuXG4gIHN0YXRpYyBJTlZBTElEX1BBQ0tBR0VfTkFNRShtc2cpIHtcbiAgICByZXR1cm4gbmV3IEFkZG9uUmVzb2x2ZUVycm9yKFxuICAgICAgbXNnLFxuICAgICAgJ0lOVkFMSURfUEFDS0FHRV9OQU1FJyxcbiAgICAgIEFkZG9uUmVzb2x2ZUVycm9yLklOVkFMSURfUEFDS0FHRV9OQU1FXG4gICAgKVxuICB9XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/bare-addon-resolve/lib/errors.js\n");

/***/ })

};
;